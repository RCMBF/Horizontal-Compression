import Init

namespace List
  /- Set-Like Conversion -/
  prefix:max "#" => List.eraseDups
  /- Set-Like Union: l₁ ∪ l₂ = {a | a ∈ l₁ ∨ a ∈ l₂} -/
  notation:66 l₁:40 " ∪ " l₂:40 => List.eraseDups (List.append l₁ l₂)
  /- Set-Like Subtraction: l₁ − l₂ = {a | a ∈ l₁ ∧ a ∉ l₂} -/
  notation:66 l₁:40 " − " l₂:40 => List.eraseDups (List.removeAll l₁ l₂)
end List


/- Types -/
/- Dag-Like Derivability Structure -/
/- DLDS: Labels -/
inductive Formula where
| atom (SYMBOL : String) : Formula
| implication (ANTECEDENT CONSEQUENT : Formula) : Formula
export Formula (atom implication)
prefix:max "#" => Formula.atom
infixl:66 ">>" => Formula.implication
def Formula.repr (FORMULA : Formula) : String :=
    match FORMULA with
    | (atom SYMBOL) => "#" ++ SYMBOL
    | (implication ANTECEDENT CONSEQUENT) => (Formula.repr ANTECEDENT) ++ ">>" ++ (Formula.repr CONSEQUENT)
instance : Repr Formula where reprPrec formula _ := Formula.repr formula
/- DLDS: Vertices -/
structure Vertex where
node :: (NUMBER : Nat)
        (LEVEL : Nat)
        (FORMULA : Formula)
        (HYPOTHESIS : Bool)
        (COLLAPSED : Bool)
        (PAST : List Nat)   /- Temporary Collapse Metadata -/
deriving Repr
export Vertex (node)
/- DLDS: Deduction Edges -/
structure Deduction where
edge :: (START : Vertex)
        (END : Vertex)
        (COLOUR : Nat)
        (DEPENDENCY : List Formula)
deriving Repr
export Deduction (edge)
/- DLDS: Ancestral Paths -/
structure Ancestral where
path :: (START : Vertex)
        (END : Vertex)
        (COLOURS : List Nat)
deriving Repr
export Ancestral (path)
/- DLDS: Graph -/
structure Graph where
dlds :: (NODES : List Vertex)
        (EDGES : List Deduction)
        (PATHS : List Ancestral)
deriving Repr
export Graph (dlds)
/- DLDS: Neighborhoods -/
structure Neighborhood where
rule :: (CENTER : Vertex)
        (INCOMING : List Deduction)
        (OUTGOING : List Deduction)
        (DIRECT : List Ancestral)
        (INDIRECT : List Ancestral)
deriving Repr
export Neighborhood (rule)

/- Instances of Decidability: Labels -/
@[inline] def Formula.decEq (FORMULA₁ FORMULA₂ : @& Formula) : Decidable (FORMULA₁ = FORMULA₂) :=
match FORMULA₁, FORMULA₂ with
| (atom SBL₁), (atom SBL₂) => by rewrite [Formula.atom.injEq];
                                 exact String.decEq SBL₁ SBL₂;
| (atom _), (implication _ _) => by exact isFalse (Formula.noConfusion);
| (implication _ _), (atom _) => by exact isFalse (Formula.noConfusion);
| (implication ANT₁ CON₁), (implication ANT₂ CON₂) => by
  rewrite [Formula.implication.injEq];
  have DecANT : Decidable (ANT₁ = ANT₂) := Formula.decEq ANT₁ ANT₂;
  have DecCON : Decidable (CON₁ = CON₂) := Formula.decEq CON₁ CON₂;
  exact @instDecidableAnd (ANT₁ = ANT₂) (CON₁ = CON₂) DecANT DecCON;
@[inline] instance : DecidableEq Formula := Formula.decEq
/- Instances of Decidability: Vertices -/
@[inline] def Vertex.decEq (NODE₁ NODE₂ : @& Vertex) : Decidable (NODE₁ = NODE₂) :=
match NODE₁, NODE₂ with
| (node NBR₁ LVL₁ FML₁ HPT₁ COL₁ PST₁), (node NBR₂ LVL₂ FML₂ HPT₂ COL₂ PST₂) => by
  rewrite [Vertex.node.injEq];
  have DecNBR : Decidable (NBR₁ = NBR₂) := Nat.decEq NBR₁ NBR₂;
  have DecLVL : Decidable (LVL₁ = LVL₂) := Nat.decEq LVL₁ LVL₂;
  have DecFML : Decidable (FML₁ = FML₂) := Formula.decEq FML₁ FML₂;
  have DecHPT : Decidable (HPT₁ = HPT₂) := Bool.decEq HPT₁ HPT₂;
  have DecCPS : Decidable (COL₁ = COL₂) := Bool.decEq COL₁ COL₂;
  have DecPST : Decidable (PST₁ = PST₂) := List.hasDecEq PST₁ PST₂;
  have DecAND₁ := @instDecidableAnd (COL₁ = COL₂) (PST₁ = PST₂) DecCPS DecPST;
  have DecAND₂ := @instDecidableAnd (HPT₁ = HPT₂) (COL₁ = COL₂ ∧ PST₁ = PST₂) DecHPT DecAND₁;
  have DecAND₃ := @instDecidableAnd (FML₁ = FML₂) (HPT₁ = HPT₂ ∧ COL₁ = COL₂ ∧ PST₁ = PST₂) DecFML DecAND₂;
  have DecAND₄ := @instDecidableAnd (LVL₁ = LVL₂) (FML₁ = FML₂ ∧ HPT₁ = HPT₂ ∧ COL₁ = COL₂ ∧ PST₁ = PST₂) DecLVL DecAND₃;
  exact @instDecidableAnd (NBR₁ = NBR₂) (LVL₁ = LVL₂ ∧ FML₁ = FML₂ ∧ HPT₁ = HPT₂ ∧ COL₁ = COL₂ ∧ PST₁ = PST₂) DecNBR DecAND₄;
@[inline] instance : DecidableEq Vertex := Vertex.decEq
/- Instances of Decidability: Deduction Edges -/
@[inline] def Deduction.decEq (EDGE₁ EDGE₂ : @& Deduction) : Decidable (EDGE₁ = EDGE₂) :=
match EDGE₁, EDGE₂ with
| (edge STT₁ END₁ CLR₁ DEP₁), (edge STT₂ END₂ CLR₂ DEP₂) => by
  rewrite [Deduction.edge.injEq];
  have DecSTT : Decidable (STT₁ = STT₂) := Vertex.decEq STT₁ STT₂;
  have DecEND : Decidable (END₁ = END₂) := Vertex.decEq END₁ END₂;
  have DecCLR : Decidable (CLR₁ = CLR₂) := Nat.decEq CLR₁ CLR₂;
  have DecDEP : Decidable (DEP₁ = DEP₂) := List.hasDecEq DEP₁ DEP₂;
  have DecAND₁ := @instDecidableAnd (CLR₁ = CLR₂) (DEP₁ = DEP₂) DecCLR DecDEP;
  have DecAND₂ := @instDecidableAnd (END₁ = END₂) (CLR₁ = CLR₂ ∧ DEP₁ = DEP₂) DecEND DecAND₁;
  exact @instDecidableAnd (STT₁ = STT₂) (END₁ = END₂ ∧ CLR₁ = CLR₂ ∧ DEP₁ = DEP₂) DecSTT DecAND₂;
@[inline] instance : DecidableEq Deduction := Deduction.decEq
/- Instances of Decidability: Ancestral Paths -/
@[inline] def Ancestral.decEq (PATH₁ PATH₂ : @& Ancestral) : Decidable (PATH₁ = PATH₂) :=
match PATH₁, PATH₂ with
| (path STT₁ END₁ CLRS₁), (path STT₂ END₂ CLRS₂) => by
  rewrite [Ancestral.path.injEq];
  have DecSTT : Decidable (STT₁ = STT₂) := Vertex.decEq STT₁ STT₂;
  have DecEND : Decidable (END₁ = END₂) := Vertex.decEq END₁ END₂;
  have DecCLRS : Decidable (CLRS₁ = CLRS₂) := List.hasDecEq CLRS₁ CLRS₂;
  have DecAND := @instDecidableAnd (END₁ = END₂) (CLRS₁ = CLRS₂) DecEND DecCLRS;
  exact @instDecidableAnd (STT₁ = STT₂) (END₁ = END₂ ∧ CLRS₁ = CLRS₂) DecSTT DecAND;
@[inline] instance : DecidableEq Ancestral := Ancestral.decEq
/- Instances of Decidability: Graph -/
@[inline] def Graph.decEq (DLDS₁ DLDS₂ : @& Graph) : Decidable (DLDS₁ = DLDS₂) := by
match DLDS₁, DLDS₂ with
| (dlds NODES₁ EDGES₁ PATHS₁), (dlds NODES₂ EDGES₂ PATHS₂) =>
  rewrite [Graph.dlds.injEq];
  have DecNODES : Decidable (NODES₁ = NODES₂) := List.hasDecEq NODES₁ NODES₂;
  have DecEDGES : Decidable (EDGES₁ = EDGES₂) := List.hasDecEq EDGES₁ EDGES₂;
  have DecPATHS : Decidable (PATHS₁ = PATHS₂) := List.hasDecEq PATHS₁ PATHS₂;
  have DecAND := @instDecidableAnd (EDGES₁ = EDGES₂) (PATHS₁ = PATHS₂) DecEDGES DecPATHS;
  exact @instDecidableAnd (NODES₁ = NODES₂) (EDGES₁ = EDGES₂ ∧ PATHS₁ = PATHS₂) DecNODES DecAND;
@[inline] instance : DecidableEq Graph := Graph.decEq
/- Instances of Decidability: Neighborhoods -/
@[inline] def Neighborhood.decEq (RULE₁ RULE₂ : @& Neighborhood) : Decidable (RULE₁ = RULE₂) :=
match RULE₁, RULE₂ with
| (rule CTR₁ INC₁ OUT₁ DIR₁ IND₁), (rule CTR₂ INC₂ OUT₂ DIR₂ IND₂) => by
  rewrite [Neighborhood.rule.injEq];
  have DecCTR : Decidable (CTR₁ = CTR₂) := Vertex.decEq CTR₁ CTR₂;
  have DecINC : Decidable (INC₁ = INC₂) := List.hasDecEq INC₁ INC₂;
  have DecOUT : Decidable (OUT₁ = OUT₂) := List.hasDecEq OUT₁ OUT₂;
  have DecDIR : Decidable (DIR₁ = DIR₂) := List.hasDecEq DIR₁ DIR₂;
  have DecIND : Decidable (IND₁ = IND₂) := List.hasDecEq IND₁ IND₂;
  have DecAND₁ := @instDecidableAnd (DIR₁ = DIR₂) (IND₁ = IND₂) DecDIR DecIND;
  have DecAND₂ := @instDecidableAnd (OUT₁ = OUT₂) (DIR₁ = DIR₂ ∧ IND₁ = IND₂) DecOUT DecAND₁;
  have DecAND₃ := @instDecidableAnd (INC₁ = INC₂) (OUT₁ = OUT₂ ∧ DIR₁ = DIR₂ ∧ IND₁ = IND₂) DecINC DecAND₂;
  exact @instDecidableAnd (CTR₁ = CTR₂) (INC₁ = INC₂ ∧ OUT₁ = OUT₂ ∧ DIR₁ = DIR₂ ∧ IND₁ = IND₂) DecCTR DecAND₃;
@[inline] instance : DecidableEq Neighborhood := Neighborhood.decEq

/- Unfold Equality: Vertex -/
theorem Vertex.node.injEq' {NODE₁ NODE₂ : Vertex} :
  -----------------------------------------------------------------------------------
  ( (NODE₁ = NODE₂) ↔ ( NODE₁.NUMBER = NODE₂.NUMBER
                      ∧ NODE₁.LEVEL = NODE₂.LEVEL
                      ∧ NODE₁.FORMULA = NODE₂.FORMULA
                      ∧ NODE₁.HYPOTHESIS = NODE₂.HYPOTHESIS
                      ∧ NODE₁.COLLAPSED = NODE₂.COLLAPSED
                      ∧ NODE₁.PAST = NODE₂.PAST ) ) := by
match NODE₁, NODE₂ with
| (node NBR₁ LVL₁ FML₁ HPT₁ COL₁ PST₁), (node NBR₂ LVL₂ FML₂ HPT₂ COL₂ PST₂) => simp only [Vertex.node.injEq];
/- Unfold Equality: Deduction -/
theorem Deduction.edge.injEq' {EDGE₁ EDGE₂ : Deduction} :
  -----------------------------------------------------------------------------------
  ( (EDGE₁ = EDGE₂) ↔ ( EDGE₁.START = EDGE₂.START
                      ∧ EDGE₁.END = EDGE₂.END
                      ∧ EDGE₁.COLOUR = EDGE₂.COLOUR
                      ∧ EDGE₁.DEPENDENCY = EDGE₂.DEPENDENCY ) ) := by
match EDGE₁, EDGE₂ with
| (edge STT₁ END₁ CLR₁ DEP₁), (edge STT₂ END₂ CLR₂ DEP₂) => simp only [Deduction.edge.injEq];
/- Unfold Equality: Ancestral -/
theorem Ancestral.path.injEq' {PATH₁ PATH₂ : Ancestral} :
  -----------------------------------------------------------------------------------
  ( (PATH₁ = PATH₂) ↔ ( PATH₁.START = PATH₂.START
                      ∧ PATH₁.END = PATH₂.END
                      ∧ PATH₁.COLOURS = PATH₂.COLOURS ) ) := by
match PATH₁, PATH₂ with
| (path STT₁ END₁ CLRS₁), (path STT₂ END₂ CLRS₂) => simp only [Ancestral.path.injEq];


/- Methods & Definitions -/
/- Get: Incoming Deductions -/--------------------------------------------------------------------------------------------------
def get_rule.incoming (NODE : Vertex) (DLDS : Graph) : List Deduction := loop NODE DLDS.EDGES
    where loop (NODE : Vertex) (EDGES : List Deduction) : List Deduction :=
          match EDGES with
          | [] => []
          | (EDGE::EDGES) => if   ( EDGE.END = NODE )
                             then ( EDGE :: loop NODE EDGES )
                             else ( loop NODE EDGES )
    ----------------------------------------------------------------------------------------------------------------------------
/- Get: Outgoing Deductions -/--------------------------------------------------------------------------------------------------
def get_rule.outgoing (NODE : Vertex) (DLDS : Graph) : List Deduction := loop NODE DLDS.EDGES
    where loop (NODE : Vertex) (EDGES : List Deduction) : List Deduction :=
          match EDGES with
          | [] => []
          | (EDGE::EDGES) => if   ( EDGE.START = NODE )
                             then ( EDGE :: loop NODE EDGES )
                             else ( loop NODE EDGES )
    ----------------------------------------------------------------------------------------------------------------------------
/- Get: Direct Ancestrals -/----------------------------------------------------------------------------------------------------
def get_rule.direct (NODE : Vertex) (DLDS : Graph) : List Ancestral := loop NODE DLDS.PATHS
    where loop (NODE : Vertex) (PATHS : List Ancestral) : List Ancestral :=
          match PATHS with
          | [] => []
          | (PATH::PATHS) => if   ( PATH.END = NODE )
                             then ( PATH :: loop NODE PATHS )
                             else ( loop NODE PATHS )
    ----------------------------------------------------------------------------------------------------------------------------
/- Get: Indirect Ancestrals -/--------------------------------------------------------------------------------------------------
def get_rule.indirect (NODE : Vertex) (DLDS : Graph) : List Ancestral := loop (get_rule.incoming NODE DLDS) DLDS.PATHS
    where loop (EDGES : List Deduction) (PATHS : List Ancestral) : List Ancestral :=
          match EDGES with
          | [] => []
          | (EDGE::EDGES) => get_rule.direct.loop EDGE.START PATHS ++ loop EDGES PATHS
    ----------------------------------------------------------------------------------------------------------------------------
/- Collapse: NODE × DLDS → Neighborhood -/--------------------------------------------------------------------------------------
def get_rule (NODE : Vertex) (DLDS : Graph) : Neighborhood := rule NODE
                                                                   ( get_rule.incoming NODE DLDS )
                                                                   ( get_rule.outgoing NODE DLDS )
                                                                   ( get_rule.direct NODE DLDS )
                                                                   ( get_rule.indirect NODE DLDS )
    ----------------------------------------------------------------------------------------------------------------------------

/- Collapse & Type Conditionals -/
/- Check: Past Collapses (Vertex) & Path Colours (Ancestral) -/-------------------------------------------------------------
def check_numbers (NUMBERS : List Nat) : Prop := ( NUMBERS ≠ [] )
                                               ∧ ( ∀{NUMBER : Nat}, ( NUMBER ∈ NUMBERS ) → ( NUMBER > 0 ) )
    ------------------------------------------------------------------------------------------------------------------------
/- Check: Nodes Set (Graph) -/----------------------------------------------------------------------------------------------
def check_dlds (DLDS : Graph) : Prop := ( ∀{NODE₁ NODE₂ : Vertex}, ( NODE₁ ∈ DLDS.NODES ) →
                                                                   ( NODE₂ ∈ DLDS.NODES ) →
                                          --------------------------------------
                                          ( ( NODE₁.NUMBER = NODE₂.NUMBER ) ↔ ( NODE₁ = NODE₂ ) ) )
                                      ∧ ( ∀{EDGE : Deduction}, ( EDGE ∈ DLDS.EDGES ) →
                                          --------------------------------------
                                          ( EDGE.START ∈ DLDS.NODES ∧ EDGE.END ∈ DLDS.NODES ) )
                                      ∧ ( ∀{PATH : Ancestral}, ( PATH ∈ DLDS.PATHS ) →
                                          --------------------------------------
                                          ( PATH.START ∈ DLDS.NODES ∧ PATH.END ∈ DLDS.NODES ) )
    ------------------------------------------------------------------------------------------------------------------------
/- Check: Collapse Nodes (Vertexes) & Incoming Edges (Deductions) -/--------------------------------------------------------
def check_collapse_nodes (RULEᵤ RULEᵥ : Neighborhood) : Prop := ( RULEᵤ.CENTER.NUMBER > RULEᵥ.CENTER.NUMBER )
                                                              ∧ ( RULEᵥ.CENTER.NUMBER ∉ RULEᵤ.CENTER.PAST )
                                                              ∧ ( RULEᵤ.CENTER.LEVEL = RULEᵥ.CENTER.LEVEL )
                                                              ∧ ( RULEᵤ.CENTER.FORMULA = RULEᵥ.CENTER.FORMULA )
                                                              ∧ ( ∀{INCᵤ INCᵥ : Deduction}, ( INCᵤ ∈ RULEᵤ.INCOMING ) →
                                                                                            ( INCᵥ ∈ RULEᵥ.INCOMING ) →
                                                                                            ( INCᵤ.START ≠ INCᵥ.START ) )
    ------------------------------------------------------------------------------------------------------------------------
/- Check: Outgoing Edges (Deductions) & Collapse Nodes (Vertexes) & Incoming Edges (Deductions) -/-------------------------
def check_collapse_edges (RULEᵤ RULEᵥ : Neighborhood) : Prop := ( ∃(OUTᵤ OUTᵥ : Deduction), ( OUTᵤ ∈ RULEᵤ.OUTGOING )
                                                                                          ∧ ( OUTᵥ ∈ RULEᵥ.OUTGOING )
                                                                                          ∧ ( OUTᵤ.COLOUR > 0 )
                                                                                          ∧ ( OUTᵥ.END = OUTᵤ.END )
                                                                                          ∧ ( OUTᵥ.COLOUR = OUTᵤ.COLOUR )
                                                                                          ∧ ( OUTᵥ.DEPENDENCY = OUTᵤ.DEPENDENCY ) )
                                                              ∧ ( RULEᵤ.CENTER.LEVEL = RULEᵥ.CENTER.LEVEL )
                                                              ∧ ( RULEᵤ.CENTER.FORMULA = RULEᵥ.CENTER.FORMULA )
                                                              ∧ ( ∀{INCᵤ INCᵥ : Deduction}, ( INCᵤ ∈ RULEᵤ.INCOMING ) →
                                                                                            ( INCᵥ ∈ RULEᵥ.INCOMING ) →
                                                                                            ( INCᵤ.START ≠ INCᵥ.START ) )
    ------------------------------------------------------------------------------------------------------------------------

/- Neighborhood Type Hierarchy -/
/- Neighborhood: Type 0 (Non-Collapsed Node Without Incoming Ancestral Paths) ⊇-Elimination -/
def type0_elimination (RULE : Neighborhood) : Prop :=
    ( RULE.CENTER.NUMBER > 0 ) ∧ ( RULE.CENTER.LEVEL > 0 ) ∧ ( RULE.CENTER.HYPOTHESIS = false )
  ∧ ( RULE.CENTER.COLLAPSED = false ) ∧ ( RULE.CENTER.PAST = [] )
  ∧ ( ∃(inc_nbr out_nbr : Nat),
      ∃(antecedent out_fml : Formula),
      ∃(major_hpt minor_hpt : Bool),
      ∃(major_dep minor_dep : List Formula),
      ------------------------------------------------------
      ( inc_nbr > 0 ) ∧ ( out_nbr > 0 )
    ∧ RULE.INCOMING = [ edge (node (inc_nbr+1) (RULE.CENTER.LEVEL+1) (antecedent>>RULE.CENTER.FORMULA) major_hpt false []) /- Left Child & Major Premise -/
                             RULE.CENTER
                             0
                             #major_dep,
                        edge (node inc_nbr (RULE.CENTER.LEVEL+1) antecedent minor_hpt false [])                            /- Right Child & Minor Premise -/
                             RULE.CENTER
                             0
                             #minor_dep ]
    ∧ RULE.OUTGOING = [ edge RULE.CENTER
                             (node out_nbr (RULE.CENTER.LEVEL-1) out_fml false false [])
                             0
                             (minor_dep ∪ major_dep) ]
    ∧ RULE.DIRECT   = []
    ∧ RULE.INDIRECT = [] )
    -----------------------------------------------------------------------------------------------------------------------------------------
/- Neighborhood: Type 0 (Non-Collapsed Node Without Incoming Ancestral Paths) ⊇-Introduction -/
def type0_introduction (RULE : Neighborhood) : Prop :=
    ( RULE.CENTER.NUMBER > 0 ) ∧ ( RULE.CENTER.LEVEL > 0 ) ∧ ( RULE.CENTER.HYPOTHESIS = false )
  ∧ ( RULE.CENTER.COLLAPSED = false ) ∧ ( RULE.CENTER.PAST = [] )
  ∧ ( ∃(inc_nbr out_nbr : Nat),
      ∃(antecedent consequent out_fml : Formula),
      ∃(inc_dep : List Formula),
    ------------------------------------------------------
      ( RULE.CENTER.FORMULA = antecedent>>consequent )
    ∧ ( inc_nbr > 0 ) ∧ ( out_nbr > 0 )
    ∧ RULE.INCOMING = [ edge (node inc_nbr (RULE.CENTER.LEVEL+1) consequent false false [])  /- Unique Child & Sole Premise -/
                             RULE.CENTER
                             0
                             #inc_dep ]
    ∧ RULE.OUTGOING = [ edge RULE.CENTER
                             (node out_nbr (RULE.CENTER.LEVEL-1) out_fml false false [])
                             0
                             (inc_dep − [antecedent]) ]
    ∧ RULE.DIRECT   = []
    ∧ RULE.INDIRECT = [] )
    -----------------------------------------------------------------------------------------------------------------------------------------
/- Neighborhood: Type 0 (Non-Collapsed Node Without Incoming Ancestral Paths) Hypothesis (Top Formula) -/
def type0_hypothesis (RULE : Neighborhood) : Prop :=
    ( RULE.CENTER.NUMBER > 0 ) ∧ ( RULE.CENTER.LEVEL > 0 ) ∧ ( RULE.CENTER.HYPOTHESIS = true )
  ∧ ( RULE.CENTER.COLLAPSED = false ) ∧ ( RULE.CENTER.PAST = [] )
  ∧ ( ∃(out_nbr : Nat),
      ∃(out_fml : Formula),
    ------------------------------------------------------
      ( out_nbr > 0 )
    ∧ RULE.INCOMING = []
    ∧ RULE.OUTGOING = [ edge RULE.CENTER
                             (node out_nbr (RULE.CENTER.LEVEL-1) out_fml false false [])
                             0
                             [RULE.CENTER.FORMULA] ]
    ∧ RULE.DIRECT   = []
    ∧ RULE.INDIRECT = [] )
    -----------------------------------------------------------------------------------------------------------------------------------------

/- Neighborhood: Type 2 (Non-Collapsed Node With Incoming Ancestral Paths) ⊇-Elimination -/
def type2_elimination (RULE : Neighborhood) : Prop :=
    ( RULE.CENTER.NUMBER > 0 ) ∧ ( RULE.CENTER.LEVEL > 0 ) ∧ ( RULE.CENTER.HYPOTHESIS = false )
  ∧ ( RULE.CENTER.COLLAPSED = false ) ∧ ( RULE.CENTER.PAST = [] )
  ∧ ( ∃(inc_nbr out_nbr anc_nbr anc_lvl : Nat),
      ∃(antecedent out_fml anc_fml : Formula),
      ∃(major_hpt minor_hpt out_hpt : Bool),
      ∃(major_dep minor_dep : List Formula),
      ∃(past colour : Nat)(pasts colours : List Nat),
      ------------------------------------------------------
      ( inc_nbr > 0 ) ∧ ( out_nbr > 0 )
    ∧ ( anc_nbr > 0 ) ∧ ( anc_lvl + List.length (0::colour::colours) = RULE.CENTER.LEVEL )
    ∧ ( colour ∈ (out_nbr::past::pasts) ) ∧ ( check_numbers (past::pasts) ) ∧ ( check_numbers (colour::colours) )
    ∧ RULE.INCOMING = [ edge (node (inc_nbr+1) (RULE.CENTER.LEVEL+1) (antecedent>>RULE.CENTER.FORMULA) major_hpt false []) /- Right Child & Major Premise -/
                             RULE.CENTER
                             0
                             #major_dep,
                        edge (node inc_nbr (RULE.CENTER.LEVEL+1) antecedent minor_hpt false [])                            /- Left Child & Minor Premise -/
                             RULE.CENTER
                             0
                             #minor_dep ]
    ∧ RULE.OUTGOING = [ edge RULE.CENTER
                             (node out_nbr (RULE.CENTER.LEVEL-1) out_fml out_hpt true (past::pasts))
                             0
                             (minor_dep ∪ major_dep) ]
    ∧ RULE.DIRECT   = [ path (node anc_nbr anc_lvl anc_fml false false [])
                             RULE.CENTER
                             (0::colour::colours) ]
    ∧ RULE.INDIRECT = [] )
    -----------------------------------------------------------------------------------------------------------------------------------------
/- Neighborhood: Type 2 (Non-Collapsed Node With Incoming Ancestral Paths) ⊇-Introduction -/
def type2_introduction (RULE : Neighborhood) : Prop :=
    ( RULE.CENTER.NUMBER > 0 ) ∧ ( RULE.CENTER.LEVEL > 0 ) ∧ ( RULE.CENTER.HYPOTHESIS = false )
  ∧ ( RULE.CENTER.COLLAPSED = false ) ∧ ( RULE.CENTER.PAST = [] )
  ∧ ( ∃(inc_nbr out_nbr anc_nbr anc_lvl : Nat),
      ∃(antecedent consequent out_fml anc_fml : Formula),
      ∃(out_hpt : Bool),
      ∃(inc_dep : List Formula),
      ∃(past colour : Nat)(pasts colours : List Nat),
    ------------------------------------------------------
      ( RULE.CENTER.FORMULA = antecedent>>consequent )
    ∧ ( inc_nbr > 0 ) ∧ ( out_nbr > 0 )
    ∧ ( anc_nbr > 0 ) ∧ ( anc_lvl + List.length (0::colour::colours) = RULE.CENTER.LEVEL )
    ∧ ( colour ∈ (out_nbr::past::pasts) ) ∧ ( check_numbers (past::pasts) ) ∧ ( check_numbers (colour::colours) )
    ∧ RULE.INCOMING = [ edge (node inc_nbr (RULE.CENTER.LEVEL+1) consequent false false [])  /- Unique Child & Sole Premise -/
                             RULE.CENTER
                             0
                             #inc_dep ]
    ∧ RULE.OUTGOING = [ edge RULE.CENTER
                             (node out_nbr (RULE.CENTER.LEVEL-1) out_fml out_hpt true (past::pasts))
                             0
                             (inc_dep − [antecedent]) ]
    ∧ RULE.DIRECT   = [ path (node anc_nbr anc_lvl anc_fml false false [])
                             RULE.CENTER
                             (0::colour::colours) ]
    ∧ RULE.INDIRECT = [] )
    -----------------------------------------------------------------------------------------------------------------------------------------
/- Neighborhood: Type 2 (Non-Collapsed Node With Incoming Ancestral Paths) Hypothesis (Top Formula) -/
def type2_hypothesis (RULE : Neighborhood) : Prop :=
    ( RULE.CENTER.NUMBER > 0 ) ∧ ( RULE.CENTER.LEVEL > 0 ) ∧ ( RULE.CENTER.HYPOTHESIS = true )
  ∧ ( RULE.CENTER.COLLAPSED = false ) ∧ ( RULE.CENTER.PAST = [] )
  ∧ ( ∃(out_nbr anc_nbr anc_lvl : Nat),
      ∃(out_fml anc_fml : Formula),
      ∃(out_hpt : Bool),
      ∃(past colour : Nat)(pasts colours : List Nat),
    ------------------------------------------------------
      ( out_nbr > 0 )
    ∧ ( anc_nbr > 0 ) ∧ ( anc_lvl + List.length (0::colour::colours) = RULE.CENTER.LEVEL )
    ∧ ( colour ∈ (out_nbr::past::pasts) ) ∧ ( check_numbers (past::pasts) ) ∧ ( check_numbers (colour::colours) )
    ∧ RULE.INCOMING = []
    ∧ RULE.OUTGOING = [ edge RULE.CENTER
                             (node out_nbr (RULE.CENTER.LEVEL-1) out_fml out_hpt true (past::pasts))
                             0
                             [RULE.CENTER.FORMULA] ]
    ∧ RULE.DIRECT   = [ path (node anc_nbr anc_lvl anc_fml false false [])
                             RULE.CENTER
                             (0::colour::colours) ]
    ∧ RULE.INDIRECT = [] )
    -----------------------------------------------------------------------------------------------------------------------------------------

/- Neighborhood: Check Incoming Edges (Type 1 & 3) -/--------------------------------------------------------------------------------------------------------------------------
def type_incoming (RULE : Neighborhood) : Prop := ∀{INC : Deduction}, ( INC ∈ RULE.INCOMING ) → ( check INC RULE.CENTER RULE.INDIRECT )
  where check (INC : Deduction) (CENTER : Vertex) (INDIRECT : List Ancestral) : Prop :=
        /- Start Node: -/------------------------------------------------------------------------------------------------------------------------------------------------------
        ( ( INC.START.NUMBER > 0 ) ∧ ( INC.START.LEVEL = CENTER.LEVEL + 1 )
        ∧ ( INC.START.COLLAPSED = false ) ∧ ( INC.START.PAST = [] ) )
        /- End Node: -/--------------------------------------------------------------------------------------------------------------------------------------------------------
      ∧ ( INC.END = CENTER )
        /- Colours: -/---------------------------------------------------------------------------------------------------------------------------------------------------------
      ∧ ( INC.COLOUR = 0 )                                                                                                /- := Incoming Edge => -/
        /- Deduction-Ancestral Duo: -/-----------------------------------------------------------------------------------------------------------------------------------------
      ∧ ( ∃(colour : Nat)(colours : List Nat)(anc : Vertex), ( path anc INC.START (0::colour::colours) ∈ INDIRECT ) )     /- => Indirect Path => -/
    ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------

/- Neighborhood: Check Outgoing Edges (Type 1) -/------------------------------------------------------------------------------------------------------------------------------
def type_outgoing₁ (RULE : Neighborhood) : Prop := ∀{OUT : Deduction}, ( OUT ∈ RULE.OUTGOING ) → ( type_outgoing₁.check_h₁ OUT RULE.CENTER
                                                                                                 ∨ type_outgoing₁.check_ie₁ OUT RULE.CENTER RULE.INDIRECT )
  where check_h₁ (OUT : Deduction) (CENTER : Vertex) : Prop :=
        /- Type 1 Hypothesis -/------------------------------------------------------------------------------------------------------------------------------------------------
        ( CENTER.HYPOTHESIS = true )
        /- Start Node: -/------------------------------------------------------------------------------------------------------------------------------------------------------
      ∧ ( OUT.START = CENTER )
        /- End Node: -/--------------------------------------------------------------------------------------------------------------------------------------------------------
      ∧ ( ( OUT.END.NUMBER > 0 ) ∧ ( OUT.END.LEVEL = CENTER.LEVEL - 1 )
        ∧ ( OUT.END.COLLAPSED = false ) ∧ ( OUT.END.PAST = [] ) )
        /- Colours: -/---------------------------------------------------------------------------------------------------------------------------------------------------------
      ∧ ( OUT.COLOUR = 0 )
        -----------------------------------------------------------------------------------------------------------------------------------------------------------------------
        check_ie₁ (OUT : Deduction) (CENTER : Vertex) (INDIRECT : List Ancestral) : Prop :=
        /- Type 1 Introduction & Elimination -/--------------------------------------------------------------------------------------------------------------------------------
        ( ( CENTER.HYPOTHESIS = false ) ∨ ( CENTER.COLLAPSED = true ) )
        /- Start Node: -/------------------------------------------------------------------------------------------------------------------------------------------------------
      ∧ ( OUT.START = CENTER )
        /- End Node: -/--------------------------------------------------------------------------------------------------------------------------------------------------------
      ∧ ( ( OUT.END.NUMBER > 0 ) ∧ ( OUT.END.LEVEL = CENTER.LEVEL - 1 )
        ∧ ( OUT.END.COLLAPSED = false ) ∧ ( OUT.END.PAST = [] ) )
        /- Colours: -/---------------------------------------------------------------------------------------------------------------------------------------------------------
      ∧ ( OUT.COLOUR ∈ (CENTER.NUMBER::CENTER.PAST) )                                                                             /- := Outgoing Edge => -/
        /- Deduction-Ancestral Duo: -/-----------------------------------------------------------------------------------------------------------------------------------------
      ∧ ( ∃(inc : Vertex), ( path OUT.END inc [0, OUT.COLOUR] ∈ INDIRECT ) )                                                      /- => Indirect Path => -/
    ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
/- Neighborhood: Check Outgoing Edges (Type 3) -/------------------------------------------------------------------------------------------------------------------------------
def type_outgoing₃ (RULE : Neighborhood) : Prop := ∀{OUT : Deduction}, ( OUT ∈ RULE.OUTGOING ) → ( ( type_outgoing₁.check_h₁ OUT RULE.CENTER
                                                                                                   ∨ type_outgoing₁.check_ie₁ OUT RULE.CENTER RULE.INDIRECT )
                                                                                                 ∨ ( type_outgoing₃.check_h₃ OUT RULE.CENTER RULE.DIRECT
                                                                                                   ∨ type_outgoing₃.check_ie₃ OUT RULE.CENTER RULE.INDIRECT ) )
  where check_h₃ (OUT : Deduction) (CENTER : Vertex) (DIRECT : List Ancestral) : Prop :=
        /- Type 3 Hypothesis -/------------------------------------------------------------------------------------------------------------------------------------------------
        ( CENTER.HYPOTHESIS = true )
        /- Start Node: -/------------------------------------------------------------------------------------------------------------------------------------------------------
      ∧ ( OUT.START = CENTER )
        /- End Node: -/--------------------------------------------------------------------------------------------------------------------------------------------------------
      ∧ ( ( OUT.END.NUMBER > 0 ) ∧ ( OUT.END.LEVEL = CENTER.LEVEL - 1 )
        ∧ ( OUT.END.COLLAPSED = true ) ∧ ( ∃(past : Nat)(pasts : List Nat), ( check_numbers (past::pasts) )
                                                                          ∧ ( OUT.END.PAST = (past::pasts) ) ) )
        /- Colours: -/---------------------------------------------------------------------------------------------------------------------------------------------------------
      ∧ ( OUT.COLOUR ∈ (CENTER.NUMBER::CENTER.PAST) )                                                                             /- := Outgoing Edge => -/
        /- Deduction-Ancestral Duo: -/-----------------------------------------------------------------------------------------------------------------------------------------
      ∧ ( ∃(colours : List Nat)(anc : Vertex), ( path anc CENTER (OUT.COLOUR::colours) ∈ DIRECT ) )                               /- => Direct Path . -/
        -----------------------------------------------------------------------------------------------------------------------------------------------------------------------
        check_ie₃ (OUT : Deduction) (CENTER : Vertex) (INDIRECT : List Ancestral) : Prop :=
        /- Type 3 Introduction & Elimination -/--------------------------------------------------------------------------------------------------------------------------------
        ( ( CENTER.HYPOTHESIS = false ) ∨ ( CENTER.COLLAPSED = true ) )
        /- Start Node: -/------------------------------------------------------------------------------------------------------------------------------------------------------
      ∧ ( OUT.START = CENTER )
        /- End Node: -/--------------------------------------------------------------------------------------------------------------------------------------------------------
      ∧ ( ( OUT.END.NUMBER > 0 ) ∧ ( OUT.END.LEVEL = CENTER.LEVEL - 1 )
        ∧ ( OUT.END.COLLAPSED = true ) ∧ ( ∃(past : Nat)(pasts : List Nat), ( check_numbers (past::pasts) )
                                                                          ∧ ( OUT.END.PAST = (past::pasts) ) ) )
        /- Colours: -/---------------------------------------------------------------------------------------------------------------------------------------------------------
      ∧ ( OUT.COLOUR ∈ (CENTER.NUMBER::CENTER.PAST) )                                                                             /- := Outgoing Edge => -/
        /- Deduction-Ancestral Duo: -/-----------------------------------------------------------------------------------------------------------------------------------------
      ∧ ( ∃(colours : List Nat)(inc anc : Vertex), ( path anc inc (0::OUT.COLOUR::colours) ∈ INDIRECT ) )                         /- => Indirect Path => -/
    ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------

/- Neighborhood: Check Direct Paths (Type 1 & 3) -/----------------------------------------------------------------------------------------------------------------------------
def type_direct (RULE : Neighborhood) : Prop := ∀{DIR : Ancestral}, ( DIR ∈ RULE.DIRECT ) → ( check DIR RULE.CENTER RULE.OUTGOING )
  where check (DIR : Ancestral) (CENTER : Vertex) (OUTGOING : List Deduction) : Prop :=
        /- Start Node: -/------------------------------------------------------------------------------------------------------------------------------------------------------
        ( ( DIR.START.NUMBER > 0 ) ∧ ( DIR.START.LEVEL ≤ CENTER.LEVEL - 1 ) ∧ ( DIR.START.HYPOTHESIS = false )
        ∧ ( DIR.START.COLLAPSED = false ) ∧ ( DIR.START.PAST = [] ) )
        /- End Node: -/--------------------------------------------------------------------------------------------------------------------------------------------------------
      ∧ ( DIR.END = CENTER )
        /- Colours: -/---------------------------------------------------------------------------------------------------------------------------------------------------------
      ∧ ( DIR.START.LEVEL + List.length (DIR.COLOURS) = CENTER.LEVEL )
      ∧ ( ∃(colour₁ colour₂ : Nat),
          ∃(colours : List Nat), ( check_numbers (colour₁::colour₂::colours) )
                               ∧ ( colour₁ ∈ (CENTER.NUMBER::CENTER.PAST) )
                               ∧ ( DIR.COLOURS = (colour₁::colour₂::colours) )                                                /- := Direct Path => -/
                                 /- Deduction-Ancestral Duo: -/----------------------------------------------------------------------------------------------------------------
                               ∧ ( ∃(out : Vertex),                                                                           /- => Outgoing Edge . -/
                                   ∃(dep_out : List Formula), ( out.COLLAPSED = true )
                                                            ∧ ( colour₂ ∈ (out.NUMBER::out.PAST) )
                                                            ∧ ( edge CENTER out colour₁ dep_out ∈ OUTGOING )
                                                            ∧ ( ∀{all_out : Deduction}, ( all_out ∈ OUTGOING ) →
                                                                                        ( ( all_out.COLOUR = colour₁ ) ↔ ( all_out = edge CENTER out colour₁ dep_out ) ) ) ) )
    ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------

/- Neighborhood: Check Indirect Paths (Type 1 & 3) -/--------------------------------------------------------------------------------------------------------------------------
def type_indirect (RULE : Neighborhood) : Prop := ∀{IND : Ancestral}, ( IND ∈ RULE.INDIRECT ) → ( check IND RULE.CENTER RULE.INCOMING RULE.OUTGOING )
  where check (IND : Ancestral) (CENTER : Vertex) (INCOMING OUTGOING : List Deduction) : Prop :=
        /- Start Node: -/------------------------------------------------------------------------------------------------------------------------------------------------------
        ( ( IND.START.NUMBER > 0 ) ∧ ( IND.START.LEVEL ≤ CENTER.LEVEL - 1 ) ∧ ( IND.START.HYPOTHESIS = false )
        ∧ ( IND.START.COLLAPSED = false ) ∧ ( IND.START.PAST = [] ) )
        /- End Node: -/--------------------------------------------------------------------------------------------------------------------------------------------------------
      ∧ ( ( IND.END.NUMBER > 0 ) ∧ ( IND.END.LEVEL = CENTER.LEVEL + 1 )
        ∧ ( IND.END.COLLAPSED = false ) ∧ ( IND.END.PAST = [] ) )
        /- Colours: -/---------------------------------------------------------------------------------------------------------------------------------------------------------
      ∧ ( IND.START.LEVEL + List.length (IND.COLOURS) = CENTER.LEVEL + 1 )
      ∧ ( ∃(colour : Nat),
          ∃(colours : List Nat), ( check_numbers (colour::colours) )
                               ∧ ( colour ∈ (CENTER.NUMBER::CENTER.PAST) )
                               ∧ ( IND.COLOURS = (0::colour::colours) )                                                         /- := Indirect Path => -/
                                 /- Deduction-Ancestral Trio: -/---------------------------------------------------------------------------------------------------------------
                               ∧ ( ∃(dep_inc : List Formula), ( edge IND.END CENTER 0 dep_inc ∈ INCOMING )                      /- => Incoming Edge => -/
                                                            ∧ ( ∀{all_inc : Deduction}, ( all_inc ∈ INCOMING ) →
                                                                                        ( ( all_inc.START = IND.END ) ↔ ( all_inc = edge IND.END CENTER 0 dep_inc ) ) ) )
                               ∧ ( ∃(out : Vertex),                                                                             /- => Outgoing Edge . -/
                                   ∃(dep_out : List Formula), ( ( colours = [] ) ↔ ( out = IND.START ) )
                                                            ∧ ( edge CENTER out colour dep_out ∈ OUTGOING )
                                                            ∧ ( ∀{all_out : Deduction}, ( all_out ∈ OUTGOING ) →
                                                                                        ( ( all_out.COLOUR = colour ) ↔ ( all_out = edge CENTER out colour dep_out ) ) ) ) )
    ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------

/- Neighborhood: Pre-Type 1 (Collapsed Nodes With Short Neighboring Ancestral Paths) Collapsed Node -/
def type1_pre_collapse (RULE : Neighborhood) : Prop :=
    /- Check Center -/-----------------------------------------------------------------------------------------------------------------------
    ( ( RULE.CENTER.NUMBER > 0 ) ∧ ( RULE.CENTER.LEVEL > 0 )
    ∧ ( RULE.CENTER.COLLAPSED = false )
    ∧ ( RULE.CENTER.PAST = [] )
    /- Check Deduction Edges -/--------------------------------------------------------------------------------------------------------------
    ∧ ( ( RULE.INCOMING = [] ) ↔ ( RULE.CENTER.HYPOTHESIS = true ) )
    ∧ ( List.length (RULE.INCOMING) ≤ 2 )
    ∧ ( ∃(out : Deduction), ( RULE.OUTGOING = [out] ) )
    ∧ ( ∀{OUT₁ OUT₂ : Deduction}, ( OUT₁ ∈ RULE.OUTGOING ) →
                                  ( OUT₂ ∈ RULE.OUTGOING ) →
                                  ( OUT₁.COLOUR > 0 ∨ OUT₂.COLOUR > 0 ) →
                                  ( ( OUT₁.COLOUR = OUT₂.COLOUR ) ↔ ( OUT₁ = OUT₂ ) ) )
    /- Check Ancestral Paths -/--------------------------------------------------------------------------------------------------------------
    ∧ ( RULE.DIRECT = [] )
    ∧ ( ∀{ind₁ ind₂ : Ancestral}, ( ind₁ ∈ RULE.INDIRECT ) →
                                  ( ind₂ ∈ RULE.INDIRECT ) → ( ( ind₁.COLOURS = ind₂.COLOURS ) ↔ ( ind₁.START = ind₂.START ) ) )
    ∧ ( List.length (RULE.INDIRECT) = List.length (RULE.INCOMING) )
    ∧ ( ∀{ind : Ancestral}, ( ind ∈ RULE.INDIRECT ) → ( ind.COLOURS = [0, RULE.CENTER.NUMBER] ) )
    /- Generic Properties -/-----------------------------------------------------------------------------------------------------------------
    ∧ ( type_incoming RULE ) ∧ ( type_outgoing₁ RULE )
    ∧ ( type_indirect RULE ) )
    -----------------------------------------------------------------------------------------------------------------------------------------
/- Neighborhood: Type 1 (Collapsed Nodes With Short Neighboring Ancestral Paths) Collapsed Node -/
def type1_collapse (RULE : Neighborhood) : Prop :=
    /- Check Center -/-----------------------------------------------------------------------------------------------------------------------
    ( ( RULE.CENTER.NUMBER > 0 ) ∧ ( RULE.CENTER.LEVEL > 0 )
    ∧ ( RULE.CENTER.COLLAPSED = true )
    ∧ ( ∃(past : Nat)(pasts : List Nat), ( check_numbers (past::pasts) )
                                       ∧ ( RULE.CENTER.PAST = (past::pasts) ) )
    /- Check Deduction Edges -/--------------------------------------------------------------------------------------------------------------
    ∧ ( ( RULE.INCOMING = [] ) → ( RULE.CENTER.HYPOTHESIS = true ) )
    ∧ ( ∃(out : Deduction)(outs : List Deduction), ( RULE.OUTGOING = (out::outs) ) )
    ∧ ( ∀{OUT₁ OUT₂ : Deduction}, ( OUT₁ ∈ RULE.OUTGOING ) →
                                  ( OUT₂ ∈ RULE.OUTGOING ) →
                                  ( OUT₁.COLOUR > 0 ∨ OUT₂.COLOUR > 0 ) →
                                  ( ( OUT₁.COLOUR = OUT₂.COLOUR ) ↔ ( OUT₁ = OUT₂ ) ) )
    /- Check Ancestral Paths -/--------------------------------------------------------------------------------------------------------------
    ∧ ( RULE.DIRECT = [] )
    ∧ ( List.length (RULE.INDIRECT) = List.length (RULE.INCOMING) )
    ∧ ( ∀{ind : Ancestral}, ( ind ∈ RULE.INDIRECT ) → ( ∃(colour : Nat), ( ind.COLOURS = [0, colour] ) ) )
    /- Generic Properties -/-----------------------------------------------------------------------------------------------------------------
    ∧ ( type_incoming RULE ) ∧ ( type_outgoing₁ RULE )
    ∧ ( type_indirect RULE ) )
    -----------------------------------------------------------------------------------------------------------------------------------------

/- Neighborhood: Pre-Type 3 (Collapsed Nodes With Long Neighboring Ancestral Paths) Collapsed Node -/
def type3_pre_collapse (RULE : Neighborhood) : Prop :=
    /- Check Center -/-----------------------------------------------------------------------------------------------------------------------
    ( ( RULE.CENTER.NUMBER > 0 ) ∧ ( RULE.CENTER.LEVEL > 0 )
    ∧ ( RULE.CENTER.COLLAPSED = false )
    ∧ ( RULE.CENTER.PAST = [] )
    /- Check Deduction Edges -/--------------------------------------------------------------------------------------------------------------
    ∧ ( ( RULE.INCOMING = [] ) ↔ ( RULE.CENTER.HYPOTHESIS = true ) )
    ∧ ( List.length (RULE.INCOMING) ≤ 2 )
    ∧ ( ∃(out : Deduction), ( RULE.OUTGOING = [out] ) )
    ∧ ( ∀{OUT₁ OUT₂ : Deduction}, ( OUT₁ ∈ RULE.OUTGOING ) →
                                  ( OUT₂ ∈ RULE.OUTGOING ) →
                                  ( OUT₁.COLOUR > 0 ∨ OUT₂.COLOUR > 0 ) →
                                  ( ( OUT₁.COLOUR = OUT₂.COLOUR ) ↔ ( OUT₁ = OUT₂ ) ) )
    /- Check Ancestral Paths -/--------------------------------------------------------------------------------------------------------------
    ∧ ( ( RULE.CENTER.HYPOTHESIS = false ) → ( RULE.DIRECT = [] ) )
    ∧ ( ( RULE.DIRECT ≠ [] ) → ( RULE.CENTER.HYPOTHESIS = true ) )
    ∧ ( ( RULE.DIRECT = [] ) ∨ ( ∃(dir : Ancestral), ( RULE.DIRECT = [dir] ) ) )
    ∧ ( ∀{ind₁ ind₂ : Ancestral}, ( ind₁ ∈ RULE.INDIRECT ) →
                                  ( ind₂ ∈ RULE.INDIRECT ) → ( ( ind₁.COLOURS = ind₂.COLOURS ) ↔ ( ind₁.START = ind₂.START ) ) )
    ∧ ( List.length (RULE.INDIRECT) = List.length (RULE.INCOMING) )
    /- Generic Properties -/-----------------------------------------------------------------------------------------------------------------
    ∧ ( type_incoming RULE ) ∧ ( type_outgoing₃ RULE )
    ∧ ( type_direct RULE ) ∧ ( type_indirect RULE ) )
    -----------------------------------------------------------------------------------------------------------------------------------------
/- Neighborhood: Type 3 (Collapsed Nodes With Long Neighboring Ancestral Paths) Collapsed Node -/
def type3_collapse (RULE : Neighborhood) : Prop :=
    /- Check Center -/-----------------------------------------------------------------------------------------------------------------------
    ( ( RULE.CENTER.NUMBER > 0 ) ∧ ( RULE.CENTER.LEVEL > 0 )
    ∧ ( RULE.CENTER.COLLAPSED = true )
    ∧ ( ∃(past : Nat)(pasts : List Nat), ( check_numbers (past::pasts) )
                                       ∧ ( RULE.CENTER.PAST = (past::pasts) ) )
    /- Check Deduction Edges -/--------------------------------------------------------------------------------------------------------------
    ∧ ( ( RULE.INCOMING = [] ) → ( RULE.CENTER.HYPOTHESIS = true ) )
    ∧ ( ∃(out : Deduction)(outs : List Deduction), ( RULE.OUTGOING = (out::outs) ) )
    ∧ ( ∀{OUT₁ OUT₂ : Deduction}, ( OUT₁ ∈ RULE.OUTGOING ) →
                                  ( OUT₂ ∈ RULE.OUTGOING ) →
                                  ( OUT₁.COLOUR > 0 ∨ OUT₂.COLOUR > 0 ) →
                                  ( ( OUT₁.COLOUR = OUT₂.COLOUR ) ↔ ( OUT₁ = OUT₂ ) ) )
    /- Check Ancestral Paths -/--------------------------------------------------------------------------------------------------------------
    ∧ ( ( RULE.CENTER.HYPOTHESIS = false ) → ( RULE.DIRECT = [] ) )
    ∧ ( ( RULE.DIRECT ≠ [] ) → ( RULE.CENTER.HYPOTHESIS = true ) )
    ∧ ( List.length (RULE.INDIRECT) = List.length (RULE.INCOMING) )
    /- Generic Properties -/-----------------------------------------------------------------------------------------------------------------
    ∧ ( type_incoming RULE ) ∧ ( type_outgoing₃ RULE )
    ∧ ( type_direct RULE ) ∧ ( type_indirect RULE ) )
    -----------------------------------------------------------------------------------------------------------------------------------------

/- Pre-Collapse Methods -/
/- Paint: Deduction Edge -/------------------------------------------------------------------------------------------------------------------
def pre_collapse.outgoing (COLOUR : Nat) (HYPOTHESIS : Bool) (OUTGOING : List Deduction) (DIRECT : List Ancestral) : List Deduction :=
    match HYPOTHESIS, OUTGOING, DIRECT with
    | _, [], _ => panic! "Zero Outgoing Edges!!!"
    | _, (_::_::_), _ => panic! "Multiple Outgoing Edges!!!"
    | _, _, (_::_::_) => panic! "Multiple Direct Paths!!!"
    -- Hypothesis ∧ Single Outgoing Edge ∧ Zero Direct Paths => Return Outgoing Edge (Unpainted)
    | true, [_], [] => OUTGOING
    -- Hypothesis ∧ Single Outgoing Edge ∧ Single Direct Path => Return Outgoing Edge (Painted)
    | true, [OUT], [_] => [ edge OUT.START OUT.END COLOUR OUT.DEPENDENCY ]
    -- Non-Hypothesis ∧ Single Outgoing Edge ∧ Zero Direct Paths => Return Outgoing Edge (Painted)
    | false, [OUT], [] => [ edge OUT.START OUT.END COLOUR OUT.DEPENDENCY ]
    -- Non-Hypothesis ∧ Single Outgoing Edge ∧ Single Direct Path => Return Outgoing Edge (Painted)
    | false, [OUT], [_] => [ edge OUT.START OUT.END COLOUR OUT.DEPENDENCY ]
    -----------------------------------------------------------------------------------------------------------------------------------------
/- Rewrite: Ancestral Paths -/---------------------------------------------------------------------------------------------------------------
def pre_collapse.direct (COLOUR : Nat) (HYPOTHESIS : Bool) (DIRECT : List Ancestral) : List Ancestral :=
    match HYPOTHESIS, DIRECT with
    | _, (_::_::_) => panic! "Multiple Direct Paths!!!"
    -- Hypothesis ∧ Zero Direct Paths => Return Nothing
    | true, [] => []
    -- Hypothesis ∧ Single Direct Path => Paint Direct Path
    | true, [PATH] => paint COLOUR PATH
    -- Non-Hypothesis ∧ Zero Direct Paths => Return Nothing
    | false, [] => []
    -- Non-Hypothesis ∧ Single Direct Path => Return Nothing
    | false, [_] => []
  where paint (COLOUR : Nat) (PATH : Ancestral) : List Ancestral :=
        match PATH.COLOURS with
        | [] => panic! "Blank Path!!!"
        | ((_+1)::_) => panic! "Broken Path!!!"
        -- Correctly Colored Path => Return Indirect Path(s)
        | (0::COLOURS) => [ path PATH.START PATH.END (COLOUR::COLOURS) ]
    -----------------------------------------------------------------------------------------------------------------------------------------
/- Create: Ancestral Paths -/----------------------------------------------------------------------------------------------------------------
def pre_collapse.indirect (COLOUR : Nat) (HYPOTHESIS : Bool) (INCOMING OUTGOING : List Deduction) (DIRECT : List Ancestral) : List Ancestral :=
    match HYPOTHESIS, INCOMING, OUTGOING, DIRECT with
    | true, (_::_), _, _ => panic! "Hypothesis With Incoming Edge(s)!!!"
    | false, [], _, _ => panic! "Non-Hypothesis Without Incoming Edge(s)"
    | _, _, [], _ => panic! "Zero Outgoing Edges!!!"
    | _, _, (_::_::_), _ => panic! "Multiple Outgoing Edges!!!"
    | _, _, _, (_::_::_) => panic! "Multiple Direct Paths!!!"
    -- Hypothesis ∧ Single Outgoing Edge ∧ Zero Direct Paths => Return Nothing
    | true, _, [_], [] => []
    -- Hypothesis ∧ Single Outgoing Edge ∧ Single Direct Path => Return Nothing
    | true, _, [_], [_] => []
    -- Non-Hypothesis ∧ Single Outgoing Edge ∧ Zero Direct Paths => Create Indirect Path(s)
    | false, (_::_), [OUT], [] => create COLOUR INCOMING OUT
    -- Non-Hypothesis ∧ Single Outgoing Edge ∧ Single Direct Path => Move-Up Direct Path(s)
    | false, (_::_), [_], [PATH] => move_up COLOUR INCOMING PATH
  where create (COLOUR : Nat) (INCOMING : List Deduction) (OUT : Deduction) : List Ancestral :=
        match INCOMING with
        | [] => []
        | (IN::INS) => ( path OUT.END IN.START [0, COLOUR] )
                    :: ( create COLOUR INS OUT )
        move_up (COLOUR : Nat) (INCOMING : List Deduction) (PATH : Ancestral) : List Ancestral :=
        match INCOMING, PATH.COLOURS with
        | _, [] => panic! "Blank Path!!!"
        | _, ((_+1)::_) => panic! "Broken Path!!!"
        -- Correctly Colored Path => Return Indirect Path(s)
        | [], (0::_) => []
        | (IN::INS), (0::COLOURS) => ( path PATH.START IN.START (0::COLOUR::COLOURS) )
                                  :: ( move_up COLOUR INS PATH )
    -----------------------------------------------------------------------------------------------------------------------------------------

/- Collapse Methods -/
/- Collapse: NODE × NODE → NODE -/-----------------------------------------------------------------------------------------------------------
def collapse.center (LEFT RIGHT : Vertex) : Vertex :=
    node ( LEFT.NUMBER )
         ( LEFT.LEVEL )
         ( LEFT.FORMULA )
         ( LEFT.HYPOTHESIS || RIGHT.HYPOTHESIS )
         ( true )
         ( RIGHT.NUMBER :: LEFT.PAST )
    -----------------------------------------------------------------------------------------------------------------------------------------
/- Rewrite: Deduction Edge End -/------------------------------------------------------------------------------------------------------------
def collapse.rewrite_incoming (COLLAPSE : Vertex) (EDGES : List Deduction) : List Deduction :=
    match EDGES with
    | [] => []
    | (EDGE::EDGES) => ( edge EDGE.START COLLAPSE EDGE.COLOUR EDGE.DEPENDENCY ) :: ( rewrite_incoming COLLAPSE EDGES )
    -----------------------------------------------------------------------------------------------------------------------------------------
/- Rewrite: Deduction Edge Start -/----------------------------------------------------------------------------------------------------------
def collapse.rewrite_outgoing (COLLAPSE : Vertex) (EDGES : List Deduction) : List Deduction :=
    match EDGES with
    | [] => []
    | (EDGE::EDGES) => ( edge COLLAPSE EDGE.END EDGE.COLOUR EDGE.DEPENDENCY ) :: ( rewrite_outgoing COLLAPSE EDGES )
    -----------------------------------------------------------------------------------------------------------------------------------------
/- Rewrite: Ancestral Edge End -/------------------------------------------------------------------------------------------------------------
def collapse.rewrite_direct (COLLAPSE : Vertex) (PATHS : List Ancestral) : List Ancestral :=
    match PATHS with
    | [] => []
    | (PATH::PATHS) => ( path PATH.START COLLAPSE PATH.COLOURS ) :: ( rewrite_direct COLLAPSE PATHS )
    -----------------------------------------------------------------------------------------------------------------------------------------

/- Collapse Definitions -/
/- Pre-Collapse: Neighborhood → Neighborhood -/----------------------------------------------------------------------------------------------
def pre_collapse (RULE : Neighborhood) : Neighborhood :=
    match RULE.CENTER.COLLAPSED with
    | true => RULE
    | false => rule ( RULE.CENTER )
                    ( RULE.INCOMING )
                    ( pre_collapse.outgoing RULE.CENTER.NUMBER RULE.CENTER.HYPOTHESIS RULE.OUTGOING RULE.DIRECT )
                    ( pre_collapse.direct RULE.CENTER.NUMBER RULE.CENTER.HYPOTHESIS RULE.DIRECT )
                    ( pre_collapse.indirect RULE.CENTER.NUMBER RULE.CENTER.HYPOTHESIS RULE.INCOMING RULE.OUTGOING RULE.DIRECT )
    -----------------------------------------------------------------------------------------------------------------------------------------
/- Collapse: Neighborhood × Neighborhood → Neighborhood -/-----------------------------------------------------------------------------------
def collapse (RULEᵤ RULEᵥ : Neighborhood) : Neighborhood :=
    rule ( collapse.center RULEᵤ.CENTER RULEᵥ.CENTER )
         ( collapse.rewrite_incoming (collapse.center RULEᵤ.CENTER RULEᵥ.CENTER) RULEᵥ.INCOMING
        ++ collapse.rewrite_incoming (collapse.center RULEᵤ.CENTER RULEᵥ.CENTER) RULEᵤ.INCOMING )
         ( collapse.rewrite_outgoing (collapse.center RULEᵤ.CENTER RULEᵥ.CENTER) RULEᵥ.OUTGOING
        ++ collapse.rewrite_outgoing (collapse.center RULEᵤ.CENTER RULEᵥ.CENTER) RULEᵤ.OUTGOING )
         ( collapse.rewrite_direct (collapse.center RULEᵤ.CENTER RULEᵥ.CENTER) RULEᵥ.DIRECT
        ++ collapse.rewrite_direct (collapse.center RULEᵤ.CENTER RULEᵥ.CENTER) RULEᵤ.DIRECT )
         ( RULEᵥ.INDIRECT
        ++ RULEᵤ.INDIRECT )
    -----------------------------------------------------------------------------------------------------------------------------------------
/- Collapse: Vertex × Vertex × Graph → Rule -/-----------------------------------------------------------------------------------------------
def collapse_nodes (U V : Vertex) (DLDS : Graph) : Neighborhood := collapse ( pre_collapse (get_rule U DLDS) )
                                                                            ( pre_collapse (get_rule V DLDS) )
    -----------------------------------------------------------------------------------------------------------------------------------------

/- Is-Collapse Methods (DLDS) -/
/- Updade: Deduction Edge End -/------------------------------------------------------------------------------------------------------------
def is_collapse.update_edges_end (OLD NEW : Vertex) (EDGES : List Deduction) : List Deduction :=
    match EDGES with
    | [] => []
    | (EDGE::EDGES) => ( loop OLD NEW EDGE ) :: ( update_edges_end OLD NEW EDGES )
  where loop (OLD NEW : Vertex) (EDGE : Deduction) : Deduction :=
        edge EDGE.START
            (if EDGE.END = OLD then NEW else EDGE.END)
            EDGE.COLOUR
            EDGE.DEPENDENCY
    -----------------------------------------------------------------------------------------------------------------------------------------
/- Updade: Deduction Edge Start -/----------------------------------------------------------------------------------------------------------
def is_collapse.update_edges_start (OLD NEW : Vertex) (EDGES : List Deduction) : List Deduction :=
    match EDGES with
    | [] => []
    | (EDGE::EDGES) => ( loop OLD NEW EDGE ) :: ( update_edges_start OLD NEW EDGES )
  where loop (OLD NEW : Vertex) (EDGE : Deduction) : Deduction :=
        edge (if EDGE.START = OLD then NEW else EDGE.START)
             EDGE.END
             EDGE.COLOUR
             EDGE.DEPENDENCY
    -----------------------------------------------------------------------------------------------------------------------------------------
/- Updade: Ancestral Edge End -/------------------------------------------------------------------------------------------------------------
def is_collapse.update_paths_end (OLD NEW : Vertex) (PATHS : List Ancestral) : List Ancestral :=
    match PATHS with
    | [] => []
    | (PATH::PATHS) => ( loop OLD NEW PATH ) :: ( update_paths_end OLD NEW PATHS )
  where loop (OLD NEW : Vertex) (PATH : Ancestral) : Ancestral :=
        path PATH.START
             (if PATH.END = OLD then NEW else PATH.END)
             PATH.COLOURS
    -----------------------------------------------------------------------------------------------------------------------------------------
/- Updade: Deduction Edge Start -/----------------------------------------------------------------------------------------------------------
def is_collapse.update_paths_start (OLD NEW : Vertex) (PATHS : List Ancestral) : List Ancestral :=
    match PATHS with
    | [] => []
    | (PATH::PATHS) => ( loop OLD NEW PATH ) :: ( update_paths_start OLD NEW PATHS )
  where loop (OLD NEW : Vertex) (PATH : Ancestral) : Ancestral :=
        path (if PATH.START = OLD then NEW else PATH.START)
             PATH.END
             PATH.COLOURS
    -----------------------------------------------------------------------------------------------------------------------------------------

/- Is-Collapse: Vertex × Vertex × Graph × Graph → Prop -/-------------------------------------------------------------------------------------------
def Graph.is_collapse (U V : Vertex) : Graph → Graph → Prop
                /- Incoming Nodes -/-------------------------------------------------------------------------------------------------------------
                /- Above & Right Side (Collapsed Child) -/---------------------------------------------------------------------------------------
| CLPS, DLDS => ( ∀{inc : Deduction}, ( U.COLLAPSED = true ) →
                                      ( inc ∈ get_rule.incoming U DLDS ) →
                  ---------------------------------------------------------------------
                  ( get_rule inc.START CLPS = rule ( inc.START )
                                                   ( get_rule.incoming inc.START DLDS )
                /- Outgoing Inc ∈ Incoming UV -/   ( is_collapse.update_edges_end U (collapse.center U V) (get_rule.outgoing inc.START DLDS) )
                /- Direct Inc ∈ Indirect UV -/     ( get_rule.direct inc.START DLDS )
                                                   ( get_rule.indirect inc.START DLDS ) ) )
                ---------------------------------------------------------------------------------------------------------------------------------
                /- Aboce & Right Side (Non-Collapsed Child) -/-----------------------------------------------------------------------------------
              ∧ ( ∀{inc : Deduction}, ( U.COLLAPSED = false ) →
                                      ( inc ∈ get_rule.incoming U DLDS ) →
                  ---------------------------------------------------------------------
                  ( get_rule inc.START CLPS = rule ( inc.START )
                                                   ( get_rule.incoming inc.START DLDS )
                /- Outgoing Inc ∈ Incoming UV -/   ( is_collapse.update_edges_end U (collapse.center U V) (get_rule.outgoing inc.START DLDS) )
                /- Direct Inc ∈ Indirect UV -/     ( get_rule.direct.loop ( inc.START )
                                                                          ( pre_collapse.indirect ( U.NUMBER )
                                                                                                  ( U.HYPOTHESIS )
                                                                                                  ( get_rule.incoming U DLDS )
                                                                                                  ( get_rule.outgoing U DLDS )
                                                                                                  ( get_rule.direct U DLDS ) ) )
                                                   ( get_rule.indirect inc.START DLDS ) ) )
                ---------------------------------------------------------------------------------------------------------------------------------
                /- Above & Left Side -/----------------------------------------------------------------------------------------------------------
              ∧ ( ∀{inc : Deduction}, ( inc ∈ get_rule.incoming V DLDS ) →
                  ---------------------------------------------------------------------
                  ( get_rule inc.START CLPS = rule ( inc.START )
                                                   ( get_rule.incoming inc.START DLDS )
                /- Outgoing Inc ∈ Incoming UV -/   ( is_collapse.update_edges_end V (collapse.center U V) (get_rule.outgoing inc.START DLDS) )
                /- Direct Inc ∈ Indirect UV -/     ( get_rule.direct.loop ( inc.START )
                                                                          ( pre_collapse.indirect ( V.NUMBER )
                                                                                                  ( V.HYPOTHESIS )
                                                                                                  ( get_rule.incoming V DLDS )
                                                                                                  ( get_rule.outgoing V DLDS )
                                                                                                  ( get_rule.direct V DLDS ) ) )
                                                   ( get_rule.indirect inc.START DLDS ) ) )
    ---------------------------------------------------------------------------------------------------------------------------------------------

/- End -/
namespace List
  /- List.Mem (∈) -/
  theorem Elem_Eq_True_Iff_Mem [DecidableEq α] {a : α} {as : List α} :
    ( a ∈ as ) ↔ ( elem a as = true ) := by
  exact Iff.intro List.elem_eq_true_of_mem List.mem_of_elem_eq_true;
  --
  theorem False_Iff_Mem_Nil [DecidableEq α] {a : α} :
    ( a ∈ [] ) ↔ ( False ) := by
  exact Iff.intro ( by intros; trivial; ) ( by intros; trivial; );
  --
  theorem Eq_Iff_Mem_Unit [DecidableEq α] {a₁ a₂ : α} :
    ( a₁ ∈ [a₂] ) ↔ ( a₁ = a₂ ) := by
  exact Iff.intro ( by intro mem_cases;
                       cases mem_cases with
                       | head _ => rfl;
                       | tail _ _ => trivial; )
                  ( by intro case_eq;
                       rewrite [case_eq];
                       exact List.Mem.head []; )
  --
  theorem Eq_Or_Mem_Iff_Mem_Cons [DecidableEq α] {a₁ a₂ : α} {as₂ : List α} :
    ( a₁ ∈ a₂::as₂ ) ↔ ( a₁ = a₂ ) ∨ ( a₁ ∈ as₂ ) := by
  exact Iff.intro ( by intro case_cons;
                       cases case_cons with
                       | head _ => exact Or.inl rfl;
                       | tail _ mem_cases => exact Or.inr mem_cases; )
                  ( by intro case_or;
                       cases case_or with
                       | inl case_eq => rewrite [case_eq];
                                        exact List.Mem.head as₂;
                       | inr mem_cases => exact List.Mem.tail a₂ mem_cases; )

  /- List.append (++) -/
  theorem NeNil_Or_NeNil_Of_NeNil_Append [DecidableEq α] {as₁ as₂ : List α} :
    ( as₁ ++ as₂ ≠ [] ) → ( as₁ ≠ [] ) ∨ ( as₂ ≠ [] ) := by
  match as₁ with
  | [] => intro case_append;
          rewrite [List.nil_append] at case_append;
          exact Or.inr case_append;
  | (HEAD::TAIL) => simp only [ne_eq];
                    intros; exact Or.inl not_false;
  --
  theorem Mem_Or_Mem_Of_Mem_Append [DecidableEq α] {a : α} {as₁ as₂ : List α} :
    ( a ∈ as₁ ++ as₂ ) → ( a ∈ as₁ ) ∨ ( a ∈ as₂ ) := by
  match as₁ with
  | [] => intro case_append;
          rewrite [List.nil_append] at case_append;
          exact Or.inr case_append;
  | (HEAD::TAIL) => intro case_append;
                    cases case_append with
                    | head _ => exact Or.inl (List.Mem.head TAIL);
                    | tail _ case_append => cases Mem_Or_Mem_Of_Mem_Append case_append with
                                            | inl mem_tail => exact Or.inl (List.Mem.tail HEAD mem_tail);
                                            | inr mem_as₂ => exact Or.inr mem_as₂;
  theorem Mem_Append_Of_Mem_Or_Mem [DecidableEq α] {a : α} {as₁ as₂ : List α} :
    ( a ∈ as₁ ) ∨ ( a ∈ as₂ ) → ( a ∈ as₁ ++ as₂ ) := by
  intro case_or;
  cases case_or with
  | inl mem_as₁ => exact mem_append_of_mem_left as₂ mem_as₁;
  | inr mem_as₂ => exact mem_append_of_mem_right as₁ mem_as₂;
  theorem Mem_Or_Mem_Iff_Mem_Append [DecidableEq α] {a : α} {as₁ as₂ : List α} :
    ( a ∈ as₁ ++ as₂ ) ↔ ( a ∈ as₁ ) ∨ ( a ∈ as₂ ) := by
  exact Iff.intro Mem_Or_Mem_Of_Mem_Append Mem_Append_Of_Mem_Or_Mem

  /- List.removeAll (--) -/
  theorem RemoveAll_Nil [DecidableEq α] {bs : List α} :
    ( List.removeAll [] bs = [] ) := by
  simp only [List.removeAll];
  trivial;
  theorem RemoveAll_Cons [DecidableEq α] {a : α} {as bs : List α} :
    ( List.removeAll (a::as) bs = if   ( a ∈ bs )
                                  then ( List.removeAll as bs )
                                  else ( a::List.removeAll as bs ) ) := by
  match as with
  | [] => simp only [Elem_Eq_True_Iff_Mem];
          simp only [List.removeAll];
          simp only [List.filter, List.notElem];
          split;
          case _ case_false => simp only [Bool.not_eq_true'] at case_false;
                               simp only [case_false, ite_false];
          case _ case_true => simp only [Bool.not_eq_false'] at case_true;
                              simp only [case_true, ite_true];
  | (HEAD::TAIL) => simp only [Elem_Eq_True_Iff_Mem];
                    simp only [List.removeAll, List.filter];
                    simp only [List.filter, List.notElem];
                    split;
                    case _ case_false => simp only [Bool.not_eq_true'] at case_false;
                                         simp only [case_false, ite_false];
                    case _ case_true => simp only [Bool.not_eq_false'] at case_true;
                                        simp only [case_true, ite_true];
  theorem Mem_Of_Mem_RemoveAll [DecidableEq α] {a : α} {as bs : List α} :
    ( a ∈ List.removeAll as bs ) → ( a ∈ as ) := by
  match as with
  | [] => intro mem_remove;
          rewrite [RemoveAll_Nil] at mem_remove;
          trivial;
  | (HEAD::TAIL) => intro mem_remove;
                    rewrite [RemoveAll_Cons] at mem_remove;
                    split at mem_remove;
                    case _ _ => apply List.Mem.tail HEAD;
                                exact (Mem_Of_Mem_RemoveAll mem_remove);
                    case _ _ => cases mem_remove with
                                | head _ => exact List.Mem.head TAIL;
                                | tail _ mem_remove => apply List.Mem.tail HEAD;
                                                       exact (Mem_Of_Mem_RemoveAll mem_remove);
end List


namespace COLLAPSE
  /- Lemma: Simplify "check_numbers [UNIT]" -/
  theorem Check_Numbers_Unit {UNIT : Nat} :
    ( UNIT > 0 ) →
    ---------------------------
    ( check_numbers [UNIT] ) := by
  intro prop_unit;
  simp only [check_numbers];
  exact And.intro ( by rewrite [ne_eq];
                       simp only [List.cons.injEq];
                       exact not_false; )
                  ( by intro colour mem_cases;
                       cases mem_cases with
                       | head _ => exact prop_unit;
                       | tail _ mem_cases => trivial; );
  /- Lemma: Simplify "check_numbers (HEAD::TAIL)" -/
  theorem Check_Numbers_Cons {HEAD : Nat} {TAIL : List Nat} :
    ( HEAD > 0 ) →
    ( check_numbers TAIL ) →
    ---------------------------
    ( check_numbers (HEAD::TAIL) ) := by
  intro prop_head prop_tail;
  simp only [check_numbers] at prop_tail ⊢;
  cases prop_tail with | intro prop_nil prop_mem =>
  exact And.intro ( by rewrite [ne_eq];
                       simp only [List.cons.injEq];
                       exact not_false; )
                  ( by intro colour mem_cases;
                       cases mem_cases with
                       | head _ => exact prop_head;
                       | tail _ mem_cases => exact prop_mem mem_cases; );

  /- Lemma: Simplify "END" at "get_rule.incoming" -/
  theorem Simp_End_Incoming {NODE : Vertex} {DLDS : Graph} {EDGE : Deduction} :
    ( EDGE ∈ get_rule.incoming NODE DLDS ) →
    ------------------------------------
    ( EDGE.END = NODE ) := by
  simp only [get_rule.incoming];
  induction DLDS.EDGES with
  | nil => intro mem_incoming;
           simp only [get_rule.incoming.loop] at mem_incoming;
           trivial;
  | cons HEAD TAIL LOOP => intro mem_incoming;
                           simp only [get_rule.incoming.loop] at mem_incoming;
                           split at mem_incoming;
                           case _ eq_head => cases mem_incoming with
                                             | head _ => exact eq_head;
                                             | tail _ mem_incoming => exact LOOP mem_incoming;
                           case _ ne_head => exact LOOP mem_incoming;
  /- Lemma: Simplify "START" at "get_rule.outgoing" -/
  theorem Simp_Start_Outgoing {NODE : Vertex} {DLDS : Graph} {EDGE : Deduction} :
    ( EDGE ∈ get_rule.outgoing NODE DLDS ) →
    ------------------------------------
    ( EDGE.START = NODE ) := by
  simp only [get_rule.outgoing];
  induction DLDS.EDGES with
  | nil => intro mem_incoming;
           simp only [get_rule.outgoing.loop] at mem_incoming;
           trivial;
  | cons HEAD TAIL LOOP => intro mem_incoming;
                           simp only [get_rule.outgoing.loop] at mem_incoming;
                           split at mem_incoming;
                           case _ eq_head => cases mem_incoming with
                                             | head _ => exact eq_head;
                                             | tail _ mem_incoming => exact LOOP mem_incoming;
                           case _ ne_head => exact LOOP mem_incoming;
  /- Lemma: Simplify "END" at "get_rule.direct" -/
  theorem Simp_End_Direct {NODE : Vertex} {DLDS : Graph} {PATH : Ancestral} :
    ( PATH ∈ get_rule.direct NODE DLDS ) →
    ------------------------------------
    ( PATH.END = NODE ) := by
  simp only [get_rule.direct];
  induction DLDS.PATHS with
  | nil => intro mem_direct;
           simp only [get_rule.direct.loop] at mem_direct;
           trivial;
  | cons HEAD TAIL LOOP => intro mem_direct;
                           simp only [get_rule.direct.loop] at mem_direct;
                           split at mem_direct;
                           case _ eq_head => cases mem_direct with
                                             | head _ => exact eq_head;
                                             | tail _ mem_direct => exact LOOP mem_direct;
                           case _ ne_head => exact LOOP mem_direct;

  /- Lemma: Simplify "get_rule.direct" at "get_rule.indirect" -/
  theorem Simp_Direct_Indirect₁₃ {NODE₀ NODE₁ : Vertex} {DLDS : Graph} :
    ( path (Start : Vertex) NODE₁ (Colours : List Nat) ∈ get_rule.indirect NODE₀ DLDS ) →
    ------------------------------------
    ( path (Start : Vertex) NODE₁ (Colours : List Nat) ∈ get_rule.direct NODE₁ DLDS ) := by
  simp only [get_rule.indirect];
  induction get_rule.incoming NODE₀ DLDS with
  | nil => intro prop_indirect₀;
           simp only [get_rule.indirect.loop] at prop_indirect₀;
           trivial;
  | cons HEAD TAIL LOOP => intro prop_indirect₀;
                           simp only [get_rule.indirect.loop] at prop_indirect₀;
                           simp only [List.Mem_Or_Mem_Iff_Mem_Append] at prop_indirect₀;
                           cases prop_indirect₀ with
                           | inl prop_head₀ => rewrite [←get_rule.direct] at prop_head₀;    /- Revert; Fold at "prop_head₀" -/
                                               rewrite [←COLLAPSE.Simp_End_Direct prop_head₀] at prop_head₀;
                                               exact prop_head₀;
                           | inr prop_tail₀ => exact LOOP prop_tail₀;
  /- Lemma: Simplify "get_rule.direct" at "get_rule.indirect" -/
  theorem Simp_Direct_Indirect₀₂ {NODE : Vertex} {DLDS : Graph} {EDGE : Deduction} :
    ( EDGE ∈ get_rule.incoming NODE DLDS ) →
    ( get_rule.indirect NODE DLDS = [] ) →
    ------------------------------------
    ( get_rule.direct EDGE.START DLDS = [] ) := by
  simp only [get_rule.indirect];
  induction get_rule.incoming NODE DLDS with
  | nil => intro _ prop_indirect;
           simp only [get_rule.indirect.loop] at prop_indirect;
           trivial;
  | cons HEAD TAIL LOOP => intro prop_incoming prop_indirect;
                           simp only [get_rule.indirect.loop] at prop_indirect;
                           simp only [List.append_eq_nil] at prop_indirect;
                           cases prop_indirect with | intro prop_indirect_head prop_indirect_tail =>
                           simp only [List.Eq_Or_Mem_Iff_Mem_Cons] at prop_incoming;
                           cases prop_incoming with
                           | inl prop_incoming_head => rewrite [←get_rule.direct] at prop_indirect_head;    /- Revert; Fold at "prop_indirect_head" -/
                                                       rewrite [←prop_incoming_head] at prop_indirect_head;
                                                       exact prop_indirect_head;
                           | inr prop_incoming_tail => exact LOOP prop_incoming_tail prop_indirect_tail;

  /- Lemma: Simplify "END" at "type_incoming" -/
  theorem Simp_Inc_End {INC : Deduction} {CENTER : Vertex} {INDIRECT : List Ancestral} :
    ( type_incoming.check INC CENTER INDIRECT ) →
    ---------------------------------------------------------------------------------
    ( INC.END = CENTER ) := by
  intro inc_case;
  simp only [type_incoming.check] at inc_case;
  cases inc_case with | intro prop_start inc_case =>
  cases inc_case with | intro prop_end prop_colour =>
  exact prop_end;
  /- Lemma: Simplify "START" at "type_outgoing₁" -/
  theorem Simp_Out_Start₁ {OUT : Deduction} {CENTER : Vertex} {INDIRECT : List Ancestral} :
    ( ( type_outgoing₁.check_h₁ OUT CENTER ) ∨ ( type_outgoing₁.check_ie₁ OUT CENTER INDIRECT ) ) →
    ---------------------------------------------------------------------------------
    ( OUT.START = CENTER ) := by
  intro out_cases;
  cases out_cases with
  | inl out_caseₕ₁ => simp only [type_outgoing₁.check_h₁] at out_caseₕ₁;
                       cases out_caseₕ₁ with | intro prop_hptₕ₁ out_caseₕ₁ =>
                       cases out_caseₕ₁ with | intro prop_startₕ₁ out_caseₕ₁ =>
                       exact prop_startₕ₁;
  | inr out_caseᵢₑ₁ => simp only [type_outgoing₁.check_ie₁] at out_caseᵢₑ₁;
                        cases out_caseᵢₑ₁ with | intro prop_hptᵢₑ₁ out_caseᵢₑ₁ =>
                        cases out_caseᵢₑ₁ with | intro prop_startᵢₑ₁ out_caseᵢₑ₁ =>
                        exact prop_startᵢₑ₁;
  /- Lemma: Simplify "START" at "type_outgoing₃" -/
  theorem Simp_Out_Start₃ {OUT : Deduction} {CENTER : Vertex} {DIRECT INDIRECT : List Ancestral} :
    ( ( ( type_outgoing₁.check_h₁ OUT CENTER ) ∨ ( type_outgoing₁.check_ie₁ OUT CENTER INDIRECT ) )
    ∨ ( ( type_outgoing₃.check_h₃ OUT CENTER DIRECT ) ∨ ( type_outgoing₃.check_ie₃ OUT CENTER INDIRECT ) ) ) →
    ---------------------------------------------------------------------------------
    ( OUT.START = CENTER ) := by
  intro out_cases;
  cases out_cases with
  | inl out_case₁ => cases out_case₁ with
                      | inl out_caseₕ₁ => simp only [type_outgoing₁.check_h₁] at out_caseₕ₁;
                                           cases out_caseₕ₁ with | intro prop_hptₕ₁ out_caseₕ₁ =>
                                           cases out_caseₕ₁ with | intro prop_startₕ₁ out_caseₕ₁ =>
                                           exact prop_startₕ₁;
                      | inr out_caseᵢₑ₁ => simp only [type_outgoing₁.check_ie₁] at out_caseᵢₑ₁;
                                            cases out_caseᵢₑ₁ with | intro prop_hptᵢₑ₁ out_caseᵢₑ₁ =>
                                            cases out_caseᵢₑ₁ with | intro prop_startᵢₑ₁ out_caseᵢₑ₁ =>
                                            exact prop_startᵢₑ₁;
  | inr out_case₃ => cases out_case₃ with
                      | inl out_caseₕ₃ => simp only [type_outgoing₁.check_h₁] at out_caseₕ₃;
                                           cases out_caseₕ₃ with | intro prop_hptₕ₃ out_caseₕ₃ =>
                                           cases out_caseₕ₃ with | intro prop_startₕ₃ out_caseₕ₃ =>
                                           exact prop_startₕ₃;
                      | inr out_caseᵢₑ₃ => simp only [type_outgoing₁.check_ie₁] at out_caseᵢₑ₃;
                                            cases out_caseᵢₑ₃ with | intro prop_hptᵢₑ₃ out_caseᵢₑ₃ =>
                                            cases out_caseᵢₑ₃ with | intro prop_startᵢₑ₃ out_caseᵢₑ₃ =>
                                            exact prop_startᵢₑ₃;
  /- Lemma: Simplify "COLOUR" at "type_outgoing₁" -/
  theorem Simp_Out_Colour₁ {OUT : Deduction} {CENTER : Vertex} {INDIRECT : List Ancestral} :
    ( ( type_outgoing₁.check_h₁ OUT CENTER ) ∨ ( type_outgoing₁.check_ie₁ OUT CENTER INDIRECT ) ) →
    ---------------------------------------------------------------------------------
    ( ( OUT.COLOUR = 0 )
    ∨ ( OUT.COLOUR ∈ (CENTER.NUMBER::CENTER.PAST) ) ) := by
  intro out_cases;
  cases out_cases with
  | inl out_caseₕ₁ => simp only [type_outgoing₁.check_h₁] at out_caseₕ₁;
                       cases out_caseₕ₁ with | intro prop_hptₕ₁ out_caseₕ₁ =>
                       cases out_caseₕ₁ with | intro prop_startₕ₁ out_caseₕ₁ =>
                       cases out_caseₕ₁ with | intro prop_endₕ₁ prop_colourₕ₁ =>
                       exact Or.inl prop_colourₕ₁;
  | inr out_caseᵢₑ₁ => simp only [type_outgoing₁.check_ie₁] at out_caseᵢₑ₁;
                        cases out_caseᵢₑ₁ with | intro prop_hptᵢₑ₁ out_caseᵢₑ₁ =>
                        cases out_caseᵢₑ₁ with | intro prop_startᵢₑ₁ out_caseᵢₑ₁ =>
                        cases out_caseᵢₑ₁ with | intro prop_endᵢₑ₁ out_caseᵢₑ₁ =>
                        cases out_caseᵢₑ₁ with | intro prop_colourᵢₑ₁ prop_out_indᵢₑ₁ =>
                        exact Or.inr prop_colourᵢₑ₁;
  /- Lemma: Simplify "COLOUR" at "type_outgoing₃" -/
  theorem Simp_Out_Colour₃ {OUT : Deduction} {CENTER : Vertex} {DIRECT INDIRECT : List Ancestral} :
    ( ( ( type_outgoing₁.check_h₁ OUT CENTER ) ∨ ( type_outgoing₁.check_ie₁ OUT CENTER INDIRECT ) )
    ∨ ( ( type_outgoing₃.check_h₃ OUT CENTER DIRECT ) ∨ ( type_outgoing₃.check_ie₃ OUT CENTER INDIRECT ) ) ) →
    ---------------------------------------------------------------------------------
    ( ( OUT.COLOUR = 0 )
    ∨ ( OUT.COLOUR ∈ (CENTER.NUMBER::CENTER.PAST) ) ) := by
  intro out_cases;
  cases out_cases with
  | inl out_case₁ => cases out_case₁ with
                      | inl out_caseₕ₁ => simp only [type_outgoing₁.check_h₁] at out_caseₕ₁;
                                           cases out_caseₕ₁ with | intro prop_hptₕ₁ out_caseₕ₁ =>
                                           cases out_caseₕ₁ with | intro prop_startₕ₁ out_caseₕ₁ =>
                                           cases out_caseₕ₁ with | intro prop_endₕ₁ prop_colourₕ₁ =>
                                           exact Or.inl prop_colourₕ₁;
                      | inr out_caseᵢₑ₁ => simp only [type_outgoing₁.check_ie₁] at out_caseᵢₑ₁;
                                            cases out_caseᵢₑ₁ with | intro prop_hptᵢₑ₁ out_caseᵢₑ₁ =>
                                            cases out_caseᵢₑ₁ with | intro prop_startᵢₑ₁ out_caseᵢₑ₁ =>
                                            cases out_caseᵢₑ₁ with | intro prop_endᵢₑ₁ out_caseᵢₑ₁ =>
                                            cases out_caseᵢₑ₁ with | intro prop_colourᵢₑ₁ prop_out_indᵢₑ₁ =>
                                            exact Or.inr prop_colourᵢₑ₁;
  | inr out_case₃ => cases out_case₃ with
                      | inl out_caseₕ₃ => simp only [type_outgoing₁.check_h₁] at out_caseₕ₃;
                                           cases out_caseₕ₃ with | intro prop_hptₕ₃ out_caseₕ₃ =>
                                           cases out_caseₕ₃ with | intro prop_startₕ₃ out_caseₕ₃ =>
                                           cases out_caseₕ₃ with | intro prop_endₕ₃ out_caseₕ₃ =>
                                           cases out_caseₕ₃ with | intro prop_colourₕ₃ prop_out_dirₕ₃ =>
                                           exact Or.inr prop_colourₕ₃;
                      | inr out_caseᵢₑ₃ => simp only [type_outgoing₁.check_ie₁] at out_caseᵢₑ₃;
                                            cases out_caseᵢₑ₃ with | intro prop_hptᵢₑ₃ out_caseᵢₑ₃ =>
                                            cases out_caseᵢₑ₃ with | intro prop_startᵢₑ₃ out_caseᵢₑ₃ =>
                                            cases out_caseᵢₑ₃ with | intro prop_endᵢₑ₃ out_caseᵢₑ₃ =>
                                            cases out_caseᵢₑ₃ with | intro prop_colourᵢₑ₃ prop_out_indᵢₑ₃ =>
                                            exact Or.inr prop_colourᵢₑ₃;

  /- Lemma: Simplify "U.COLLAPSED = true" at "Graph.is_collapse" -/
  theorem Simp_Rule_Above_Collapse {U V : Vertex} {DLDS CLPS : Graph} :
    ( U.COLLAPSED = true ) →
    ( CLPS.is_collapse U V DLDS ) →
    /- Incoming Nodes -/-------------------------------------------------------------
    ( ∀{inc : Deduction}, ( inc ∈ get_rule.incoming U DLDS ) →
      -----------------------------------------------------------------------------
    ( get_rule inc.START CLPS = rule ( inc.START )
                                     ( get_rule.incoming inc.START DLDS )
  /- Outgoing Inc ∈ Incoming UV -/   ( is_collapse.update_edges_end U (collapse.center U V) (get_rule.outgoing inc.START DLDS) )
  /- Direct Inc ∈ Indirect UV -/     ( get_rule.direct inc.START DLDS )
                                     ( get_rule.indirect inc.START DLDS ) ) ) := by
  intro prop_col prop_collapse;
  simp only [Graph.is_collapse] at prop_collapse;
  cases prop_collapse with | intro prop_incoming _ =>
  intro edge prop_mem;
  exact prop_incoming prop_col prop_mem;
  /- Lemma: Simplify "U.COLLAPSED = false" at "Graph.is_collapse" -/
  theorem Simp_Rule_Above_Left {U V : Vertex} {DLDS CLPS : Graph} :
    ( U.COLLAPSED = false ) →
    ( CLPS.is_collapse U V DLDS ) →
    /- Incoming Nodes -/-------------------------------------------------------------
    ( ∀{inc : Deduction}, ( inc ∈ get_rule.incoming U DLDS ) →
      -----------------------------------------------------------------------------
      ( get_rule inc.START CLPS = rule ( inc.START )
                                       ( get_rule.incoming inc.START DLDS )
    /- Outgoing Inc ∈ Incoming UV -/   ( is_collapse.update_edges_end U (collapse.center U V) (get_rule.outgoing inc.START DLDS) )
    /- Direct Inc ∈ Indirect UV -/     ( get_rule.direct.loop ( inc.START )
                                                              ( pre_collapse.indirect ( U.NUMBER )
                                                                                      ( U.HYPOTHESIS )
                                                                                      ( get_rule.incoming U DLDS )
                                                                                      ( get_rule.outgoing U DLDS )
                                                                                      ( get_rule.direct U DLDS ) ) )
                                       ( get_rule.indirect inc.START DLDS ) ) ) := by
  intro prop_col prop_collapse;
  simp only [Graph.is_collapse] at prop_collapse;
  cases prop_collapse with | intro _ prop_collapse =>
  cases prop_collapse with | intro prop_incoming _ =>
  intro edge prop_mem;
  exact prop_incoming prop_col prop_mem;
  /- Lemma: Simplify "V" at "Graph.is_collapse" -/
  theorem Simp_Rule_Above_Right {U V : Vertex} {DLDS CLPS : Graph} :
    ( CLPS.is_collapse U V DLDS ) →
    /- Incoming Nodes -/-------------------------------------------------------------
    ( ∀{inc : Deduction}, ( inc ∈ get_rule.incoming V DLDS ) →
      -----------------------------------------------------------------------------
      ( get_rule inc.START CLPS = rule ( inc.START )
                                       ( get_rule.incoming inc.START DLDS )
    /- Outgoing Inc ∈ Incoming UV -/   ( is_collapse.update_edges_end V (collapse.center U V) (get_rule.outgoing inc.START DLDS) )
    /- Direct Inc ∈ Indirect UV -/     ( get_rule.direct.loop ( inc.START )
                                                              ( pre_collapse.indirect ( V.NUMBER )
                                                                                      ( V.HYPOTHESIS )
                                                                                      ( get_rule.incoming V DLDS )
                                                                                      ( get_rule.outgoing V DLDS )
                                                                                      ( get_rule.direct V DLDS ) ) )
                                       ( get_rule.indirect inc.START DLDS ) ) ) := by
  intro prop_collapse;
  simp only [Graph.is_collapse] at prop_collapse;
  cases prop_collapse with | intro _ prop_collapse =>
  cases prop_collapse with | intro _ prop_incoming =>
  intro edge prop_mem;
  exact prop_incoming prop_mem;
end COLLAPSE

/- End -/
namespace DEFINE
  --333 set_option trace.Meta.Tactic.simp true
  /- Lemma: Define Check Procedure for "ind.COLOURS = [0, RULE.CENTER.NUMBER]" -/
  def check_path_colours (COLOURS : List Nat) (PATHS : List Ancestral) : Prop :=
      match PATHS with
      | [] => True
      | (PATH::PATHS) => ( PATH.COLOURS = COLOURS )
                       ∧ ( check_path_colours COLOURS PATHS )
  theorem Def_Check_Path_Colours {COLOURS : List Nat} {PATH : Ancestral} {PATHS : List Ancestral} :
    ( PATH ∈ PATHS ) →
    ( check_path_colours COLOURS PATHS ) →
    ---------------------------
    ( PATH.COLOURS = COLOURS ) := by
  match PATHS with
  | [] => intros; trivial;
  | (HEAD::TAIL) => intro mem_cases prop_check;
                    simp only [check_path_colours] at prop_check;
                    cases prop_check with | intro prop_check_head prop_check_tail =>
                    cases mem_cases with
                    | head _ => exact prop_check_head;
                    | tail _ mem_cases => exact Def_Check_Path_Colours mem_cases prop_check_tail;

  /- Lemma: Define Check Procedure for "( ind₁.COLOURS = ind₂.COLOURS ) ↔ ( ind₁.START = ind₂.START )" -/
  def check_path_starts (PATHS : List Ancestral) : Prop :=
      match PATHS with
      | [] => True
      | (PATH₁::PATHS₂) => ( loop PATH₁ PATHS₂ )
                         ∧ ( check_path_starts PATHS₂ )
    where loop (PATH₁ : Ancestral) (PATHS₂ : List Ancestral) : Prop :=
          match PATHS₂ with
          | [] => True
          | (PATH₂::PATHS₂) => ( PATH₁.COLOURS = PATH₂.COLOURS ↔ PATH₁.START = PATH₂.START )
                             ∧ ( loop PATH₁ PATHS₂ )
  theorem Loop_Check_Path_Starts {PATH₁ PATH₂ : Ancestral} {PATHS₂ : List Ancestral} :
    ( PATH₂ ∈ PATHS₂ ) →
    ( check_path_starts.loop PATH₁ PATHS₂ ) →
    ---------------------------
    ( ( PATH₁.COLOURS = PATH₂.COLOURS ) ↔ ( PATH₁.START = PATH₂.START ) ) := by
  match PATHS₂ with
  | [] => intros; trivial;
  | (HEAD::TAIL) => intro case_mem₂ prop_check_loop;
                    simp only [check_path_starts.loop] at prop_check_loop;
                    cases prop_check_loop with | intro prop_check_head prop_check_tail =>
                    cases case_mem₂ with
                    | head _ => exact prop_check_head;
                    | tail _ case_mem₂ => exact Loop_Check_Path_Starts case_mem₂ prop_check_tail;
  theorem Def_Check_Path_Starts {PATH₁ PATH₂ : Ancestral} {PATHS : List Ancestral} :
    ( PATH₁ ∈ PATHS ) →
    ( PATH₂ ∈ PATHS ) →
    ( check_path_starts PATHS ) →
    ---------------------------
    ( ( PATH₁.COLOURS = PATH₂.COLOURS ) ↔ ( PATH₁.START = PATH₂.START ) ) := by
  match PATHS with
  | [] => intros; trivial;
  | (HEAD::TAIL) => intro case_mem₁ case_mem₂ prop_check;
                    simp only [check_path_starts] at prop_check;
                    cases prop_check with | intro prop_check_loop prop_check_tail =>
                    cases case_mem₁ with
                    | head _ => cases case_mem₂ with
                                | head _ => simp only [eq_self_iff_true];
                                | tail _ case_mem₂ => exact Loop_Check_Path_Starts case_mem₂ prop_check_loop;
                    | tail _ case_mem₁ => cases case_mem₂ with
                                          | head _ => rewrite [eq_comm];
                                                      rewrite [Loop_Check_Path_Starts case_mem₁ prop_check_loop];
                                                      rewrite [eq_comm];
                                                      trivial;
                                          | tail _ case_mem₂ => exact Def_Check_Path_Starts case_mem₁ case_mem₂ prop_check_tail;

  /- Lemma: Define Check Procedure for "( INC.START = IND.END ) ↔ ( INC = edge IND.END RULE.CENTER 0 dep_inc )" -/
  def check_path_incoming (START END : Vertex) (DEPENDENCY : List Formula) (EDGES : List Deduction) : Prop :=
      match EDGES with
      | [] => True
      | (EDGE::EDGES) => ( EDGE.START = START ↔ EDGE = edge START END 0 DEPENDENCY )
                       ∧ ( check_path_incoming START END DEPENDENCY EDGES )
  theorem Def_Check_Path_Incoming {START END : Vertex} {DEPENDENCY : List Formula} {EDGE : Deduction} {EDGES : List Deduction} :
    ( EDGE ∈ EDGES ) →
    ( check_path_incoming START END DEPENDENCY EDGES ) →
    ---------------------------
    ( EDGE.START = START ↔ EDGE = edge START END 0 DEPENDENCY ) := by
  match EDGES with
  | [] => intros; trivial;
  | (HEAD::TAIL) => intro mem_cases prop_check;
                    simp only [check_path_incoming] at prop_check;
                    cases prop_check with | intro prop_check_head prop_check_tail =>
                    cases mem_cases with
                    | head _ => exact prop_check_head;
                    | tail _ mem_cases => exact Def_Check_Path_Incoming mem_cases prop_check_tail;

  /- Lemma: Define Check Procedure for "( OUT.COLOUR = colour ) ↔ ( OUT = edge RULE.CENTER out colour dep_out )" -/
  def check_path_outgoing (START END : Vertex) (COLOUR : Nat) (DEPENDENCY : List Formula) (EDGES : List Deduction) : Prop :=
      match EDGES with
      | [] => True
      | (EDGE::EDGES) => ( EDGE.COLOUR = COLOUR ↔ EDGE = edge START END COLOUR DEPENDENCY )
                       ∧ ( check_path_outgoing START END COLOUR DEPENDENCY EDGES )
  theorem Def_Check_Path_Outgoing {START END : Vertex} {COLOUR : Nat} {DEPENDENCY : List Formula} {EDGE : Deduction} {EDGES : List Deduction} :
    ( EDGE ∈ EDGES ) →
    ( check_path_outgoing START END COLOUR DEPENDENCY EDGES ) →
    ---------------------------
    ( EDGE.COLOUR = COLOUR ↔ EDGE = edge START END COLOUR DEPENDENCY ) := by
  match EDGES with
  | [] => intros; trivial;
  | (HEAD::TAIL) => intro mem_cases prop_check;
                    simp only [check_path_outgoing] at prop_check;
                    cases prop_check with | intro prop_check_head prop_check_tail =>
                    cases mem_cases with
                    | head _ => exact prop_check_head;
                    | tail _ mem_cases => exact Def_Check_Path_Outgoing mem_cases prop_check_tail;
end DEFINE


namespace REWRITE
  --333 set_option trace.Meta.Tactic.simp true
  /- Lemma: Method "rewrite_incoming" preserves "≠ []" -/
  theorem NeNil_RwIncoming {COLLAPSE : Vertex} {INCOMING : List Deduction} :
    -----------------------------------------------------------------------------------
    ( collapse.rewrite_incoming COLLAPSE INCOMING ≠ [] → INCOMING ≠ [] ) := by
  match INCOMING with
  | [] => intros; trivial;
  | (HEAD::TAIL) => simp only [ne_eq];
                    intros; trivial;
  /- Lemma: Method "rewrite_incoming" preserves "List.length" -/
  theorem Eq_Length_RwIncoming {COLLAPSE : Vertex} {INCOMING : List Deduction} :
    -----------------------------------------------------------------------------------
    ( List.length (collapse.rewrite_incoming COLLAPSE INCOMING) = List.length INCOMING ) := by
  match INCOMING with
  | [] => trivial;
  | (HEAD::TAIL) => simp only [collapse.rewrite_incoming];
                    simp only [List.length, Nat.succ.injEq];
                    exact Eq_Length_RwIncoming;
  /- Lemma: Applications of "rewrite_incoming" have fixed "EDGE.END" -/
  theorem Get_End_RwIncoming {COLLAPSE : Vertex} {RWRT : Deduction} {INCOMING : List Deduction} :
    ( RWRT ∈ collapse.rewrite_incoming COLLAPSE INCOMING ) →
    -----------------------------------------------------------------------------------
    ( RWRT.END = COLLAPSE ) := by
  match INCOMING with
  | [] => intros; trivial;
  | (HEAD::TAIL) => intro mem_cases;
                    simp only [collapse.rewrite_incoming] at mem_cases;
                    cases mem_cases with
                    | head _ => trivial;
                    | tail _ mem_cases => exact Get_End_RwIncoming mem_cases;
  /- Lemma: Predict "rewrite_incoming" membership -/
  theorem Mem_RwIncoming_Of_Mem {COLLAPSE : Vertex} {INC : Deduction} {INCOMING : List Deduction} :
    ( INC ∈ INCOMING ) →
    -----------------------------------------------------------------------------------
    ( edge INC.START COLLAPSE INC.COLOUR INC.DEPENDENCY ∈ collapse.rewrite_incoming COLLAPSE INCOMING ) := by
  match INCOMING with
  | [] => intros; trivial;
  | (HEAD::TAIL) => intro mem_cases;
                    simp only [collapse.rewrite_incoming];
                    cases mem_cases with
                    | head _ => exact List.Mem.head _;
                    | tail _ mem_cases => apply List.Mem.tail;
                                          exact Mem_RwIncoming_Of_Mem mem_cases;
  /- Lemma: Resolve "rewrite_incoming" mebership -/
  theorem Mem_Of_Mem_RwIncoming {COLLAPSE : Vertex} {RWRT : Deduction} {INCOMING : List Deduction} :
    ( RWRT ∈ collapse.rewrite_incoming COLLAPSE INCOMING ) →
    -----------------------------------------------------------------------------------
    ( ∃(ORIGINAL : Vertex), ( edge RWRT.START ORIGINAL RWRT.COLOUR RWRT.DEPENDENCY ∈ INCOMING ) ) := by
  match INCOMING with
  | [] => intros; trivial;
  | (HEAD::TAIL) => intro mem_cases;
                    simp only [collapse.rewrite_incoming] at mem_cases;
                    cases mem_cases with
                    | head _ => apply Exists.intro HEAD.END;
                                exact List.Mem.head _;
                    | tail _ mem_cases => have Case_Tail := Mem_Of_Mem_RwIncoming mem_cases;
                                          cases Case_Tail with | intro End_Tail Mem_Tail =>
                                          apply Exists.intro End_Tail;
                                          exact List.Mem.tail HEAD Mem_Tail;

  /- Lemma: Method "rewrite_outgoing" preserves "≠ []" -/
  theorem NeNil_RwOutgoing {COLLAPSE : Vertex} {OUTGOING : List Deduction} :
    -----------------------------------------------------------------------------------
    ( collapse.rewrite_outgoing COLLAPSE OUTGOING ≠ [] → OUTGOING ≠ [] ) := by
  match OUTGOING with
  | [] => intros; trivial;
  | (HEAD::TAIL) => simp only [ne_eq];
                    intros; trivial;
  /- Lemma: Method "rewrite_outgoing" preserves "List.length" -/
  theorem Eq_Length_RwOutgoing {COLLAPSE : Vertex} {OUTGOING : List Deduction} :
    -----------------------------------------------------------------------------------
    ( List.length (collapse.rewrite_outgoing COLLAPSE OUTGOING) = List.length OUTGOING ) := by
  match OUTGOING with
  | [] => trivial;
  | (HEAD::TAIL) => simp only [collapse.rewrite_outgoing];
                    simp only [List.length, Nat.succ.injEq];
                    exact Eq_Length_RwOutgoing;
  /- Lemma: Applications of "rewrite_outgoing" have fixed "EDGE.START" -/
  theorem Get_Start_RwOutgoing {COLLAPSE : Vertex} {RWRT : Deduction} {OUTGOING : List Deduction} :
    ( RWRT ∈ collapse.rewrite_outgoing COLLAPSE OUTGOING ) →
    -----------------------------------------------------------------------------------
    ( RWRT.START = COLLAPSE ) := by
  match OUTGOING with
  | [] => intros; trivial;
  | (HEAD::TAIL) => intro mem_cases;
                    simp only [collapse.rewrite_outgoing] at mem_cases;
                    cases mem_cases with
                    | head _ => trivial;
                    | tail _ mem_cases => exact Get_Start_RwOutgoing mem_cases;
  /- Lemma: Predict "rewrite_outgoing" membership -/
  theorem Mem_RwOutgoing_Of_Mem {COLLAPSE : Vertex} {OUT : Deduction} {OUTGOING : List Deduction} :
    ( OUT ∈ OUTGOING ) →
    -----------------------------------------------------------------------------------
    ( edge COLLAPSE OUT.END OUT.COLOUR OUT.DEPENDENCY ∈ collapse.rewrite_outgoing COLLAPSE OUTGOING ) := by
  match OUTGOING with
  | [] => intros; trivial;
  | (HEAD::TAIL) => intro mem_cases;
                    simp only [collapse.rewrite_outgoing];
                    cases mem_cases with
                    | head _ => exact List.Mem.head _;
                    | tail _ mem_cases => apply List.Mem.tail;
                                          exact Mem_RwOutgoing_Of_Mem mem_cases;
  /- Lemma: Resolve "rewrite_outgoing" mebership -/
  theorem Mem_Of_Mem_RwOutgoing {COLLAPSE : Vertex} {RWRT : Deduction} {OUTGOING : List Deduction} :
    ( RWRT ∈ collapse.rewrite_outgoing COLLAPSE OUTGOING ) →
    -----------------------------------------------------------------------------------
    ( ∃(ORIGINAL : Vertex), ( edge ORIGINAL RWRT.END RWRT.COLOUR RWRT.DEPENDENCY ∈ OUTGOING ) ) := by
  match OUTGOING with
  | [] => intros; trivial;
  | (HEAD::TAIL) => intro mem_cases;
                    simp only [collapse.rewrite_outgoing] at mem_cases;
                    cases mem_cases with
                    | head _ => apply Exists.intro HEAD.START;
                                exact List.Mem.head _;
                    | tail _ mem_cases => have Case_Tail := Mem_Of_Mem_RwOutgoing mem_cases;
                                          cases Case_Tail with | intro Start_Tail Mem_Tail =>
                                          apply Exists.intro Start_Tail;
                                          exact List.Mem.tail HEAD Mem_Tail;

  /- Lemma: Method "rewrite_direct" preserves "≠ []" -/
  theorem NeNil_RwDirect {COLLAPSE : Vertex} {DIRECT : List Ancestral} :
    -----------------------------------------------------------------------------------
    ( collapse.rewrite_direct COLLAPSE DIRECT ≠ [] → DIRECT ≠ [] ) := by
  match DIRECT with
  | [] => intros; trivial;
  | (HEAD::TAIL) => simp only [ne_eq];
                    intros; trivial;
  /- Lemma: Method "rewrite_direct" preserves "List.length" -/
  theorem Eq_Length_RwDirect {COLLAPSE : Vertex} {DIRECT : List Ancestral} :
    -----------------------------------------------------------------------------------
    ( List.length (collapse.rewrite_direct COLLAPSE DIRECT) = List.length DIRECT ) := by
  match DIRECT with
  | [] => trivial;
  | (HEAD::TAIL) => simp only [collapse.rewrite_direct];
                    simp only [List.length, Nat.succ.injEq];
                    exact Eq_Length_RwDirect;
  /- Lemma: Applications of "rewrite_direct" have fixed "PATH.END" -/
  theorem Get_End_RwDirect {COLLAPSE : Vertex} {RWRT : Ancestral} {DIRECT : List Ancestral} :
    ( RWRT ∈ collapse.rewrite_direct COLLAPSE DIRECT ) →
    -----------------------------------------------------------------------------------
    ( RWRT.END = COLLAPSE ) := by
  match DIRECT with
  | [] => intros; trivial;
  | (HEAD::TAIL) => intro mem_cases;
                    simp only [collapse.rewrite_direct] at mem_cases;
                    cases mem_cases with
                    | head _ => trivial;
                    | tail _ mem_cases => exact Get_End_RwDirect mem_cases;
  /- Lemma: Predict "rewrite_direct" membership -/
  theorem Mem_RwDirect_Of_Mem {COLLAPSE : Vertex} {DIR : Ancestral} {DIRECT : List Ancestral} :
    ( DIR ∈ DIRECT ) →
    -----------------------------------------------------------------------------------
    ( path DIR.START COLLAPSE DIR.COLOURS ∈ collapse.rewrite_direct COLLAPSE DIRECT ) := by
  match DIRECT with
  | [] => intros; trivial;
  | (HEAD::TAIL) => intro mem_cases;
                    simp only [collapse.rewrite_direct];
                    cases mem_cases with
                    | head _ => exact List.Mem.head _;
                    | tail _ mem_cases => apply List.Mem.tail;
                                          exact Mem_RwDirect_Of_Mem mem_cases;
  /- Lemma: Resolve "rewrite_direct" mebership -/
  theorem Mem_Of_Mem_RwDirect {COLLAPSE : Vertex} {RWRT : Ancestral} {DIRECT : List Ancestral} :
    ( RWRT ∈ collapse.rewrite_direct COLLAPSE DIRECT ) →
    -----------------------------------------------------------------------------------
    ( ∃(ORIGINAL : Vertex), ( path RWRT.START ORIGINAL RWRT.COLOURS ∈ DIRECT ) ) := by
  match DIRECT with
  | [] => intros; trivial;
  | (HEAD::TAIL) => intro mem_cases;
                    simp only [collapse.rewrite_direct] at mem_cases;
                    cases mem_cases with
                    | head _ => apply Exists.intro HEAD.END;
                                exact List.Mem.head _;
                    | tail _ mem_cases => have Case_Tail := Mem_Of_Mem_RwDirect mem_cases;
                                          cases Case_Tail with | intro Start_Tail Mem_Tail =>
                                          apply Exists.intro Start_Tail;
                                          exact List.Mem.tail HEAD Mem_Tail;
end REWRITE


namespace COVERAGE.T1_Of_T1
  /- Pre-Collapse: Type1 Collapse -/
  theorem Col_Of_PreCollapse_Col {RULE : Neighborhood} :
    ( type1_collapse RULE ) →
    ---------------------------
    ( type1_collapse (pre_collapse RULE) ) := by
  intro prop_type;
  simp only [type1_collapse] at prop_type;
  cases prop_type with | intro prop_nbr prop_type =>
  cases prop_type with | intro prop_lvl prop_type =>
  cases prop_type with | intro prop_col prop_type =>
  --
  simp only [pre_collapse];
  simp only [prop_col];
  --
  simp only [type1_collapse];
  apply And.intro ( by exact prop_nbr; );
  apply And.intro ( by exact prop_lvl; );
  apply And.intro ( by exact prop_col; );
  exact prop_type;
  -----------------------------------------------------------------------------------------------------------------------------------------
end COVERAGE.T1_Of_T1

namespace COVERAGE.T3_Of_T3
  /- Pre-Collapse: Type3 Collapse -/
  theorem Col_Of_PreCollapse_Col {RULE : Neighborhood} :
    ( type3_collapse RULE ) →
    ---------------------------
    ( type3_collapse (pre_collapse RULE) ) := by
  intro prop_type;
  simp only [type3_collapse] at prop_type;
  cases prop_type with | intro prop_nbr prop_type =>
  cases prop_type with | intro prop_lvl prop_type =>
  cases prop_type with | intro prop_col prop_type =>
  --
  simp only [pre_collapse];
  simp only [prop_col];
  --
  simp only [type3_collapse];
  apply And.intro ( by exact prop_nbr; );
  apply And.intro ( by exact prop_lvl; );
  apply And.intro ( by exact prop_col; );
  exact prop_type;
  -----------------------------------------------------------------------------------------------------------------------------------------
end COVERAGE.T3_Of_T3

namespace COVERAGE.T3_Of_T1
  /- Lemma: Type 3 Pre-Collapse from Type 1 Pre-Collapse -/
  theorem PreCol_Of_Pre {RULE : Neighborhood} :
    ( type1_pre_collapse RULE ) →
    ---------------------------
    ( type3_pre_collapse RULE ) := by
  intro prop_type;
  simp only [type1_pre_collapse] at prop_type;
  cases prop_type with | intro prop_nbr prop_type =>
  cases prop_type with | intro prop_lvl prop_type =>
  cases prop_type with | intro prop_col prop_type =>
  cases prop_type with | intro prop_pst prop_type =>
  cases prop_type with | intro prop_inc_nil prop_type =>
  cases prop_type with | intro prop_inc_len prop_type =>
  cases prop_type with | intro prop_out_unit prop_type =>
  cases prop_type with | intro prop_out_colours prop_type =>
  cases prop_type with | intro prop_dir_nil prop_type =>
  cases prop_type with | intro prop_ind_starts prop_type =>
  cases prop_type with | intro prop_ind_len prop_type =>
  cases prop_type with | intro prop_ind_colours prop_type =>
  cases prop_type with | intro prop_incoming prop_type =>
  cases prop_type with | intro prop_outgoing prop_indirect =>
  --
  simp only [type3_pre_collapse];
  /- Check Center-/
  apply And.intro ( by exact prop_nbr; );                         /- := RULE.CENTER.NUMBER > 0 -/
  apply And.intro ( by exact prop_lvl; );                         /- := RULE.CENTER.LEVEL > 0 -/
  apply And.intro ( by exact prop_col; );                         /- := RULE.CENTER.COLLAPSED = false -/
  apply And.intro ( by exact prop_pst; );                         /- := RULE.CENTER.PAST = [] -/
  /- Check Deduction Edges -/
  apply And.intro ( by exact prop_inc_nil; );                     /- := ( RULE.INCOMING = [] ) ↔ ( RULE.CENTER.HYPOTHESIS = true ) -/
  apply And.intro ( by exact prop_inc_len; );                     /- := List.length (RULE.INCOMING) ≤ 2 -/
  apply And.intro ( by exact prop_out_unit; );                    /- := RULE.OUTGOING = [out] -/
  apply And.intro ( by exact prop_out_colours; );                 /- := OUT₁.COLOUR = OUT₂.COLOUR ↔ OUT₁ = OUT₂ -/
  /- Check Ancestral Paths -/
  apply And.intro ( by rewrite [prop_dir_nil];                    /- := ( RULE.CENTER.HYPOTHESIS = false ) → ( RULE.DIRECT = [] ) -/
                       intros; trivial; );
  apply And.intro ( by rewrite [prop_dir_nil];                    /- := RULE.DIRECT ≠ [] → RULE.CENTER.HYPOTHESIS = true -/
                       intros; trivial; );
  apply And.intro ( by exact Or.inl prop_dir_nil; );              /- := ( RULE.DIRECT ≠ [] ) ∨ ( RULE.DIRECT = [dir] ) -/
  apply And.intro ( by exact prop_ind_starts; );                  /- := ( ind₁.COLOURS = ind₂.COLOURS ) ↔ ( ind₁.START = ind₂.START ) -/
  apply And.intro ( by exact prop_ind_len; );                     /- := List.length (RULE.INCOMING) = List.length (RULE.INDIRECT) -/
  apply And.intro ( by exact prop_incoming; );                    /- := type_incoming RULE -/
  apply And.intro ( by simp only [type_outgoing₃];                /- := type_outgoing RULE -/
                       intro out out_cases;
                       exact Or.inl (prop_outgoing out_cases); );
  apply And.intro ( by simp only [type_direct];                   /- := type_direct RULE -/
                       rewrite [prop_dir_nil];
                       intro dir dir_cases;
                       trivial; );
  exact prop_indirect;                                            /- := type_indirect RULE -/
  -----------------------------------------------------------------------------------------------------------------------------------------
  /- Lemma: Type 3 Collapse from Type 1 Collapse -/
  theorem Col_Of_Col {RULE : Neighborhood} :
    ( type1_collapse RULE ) →
    ---------------------------
    ( type3_collapse RULE ) := by
  intro prop_type;
  simp only [type1_collapse] at prop_type;
  cases prop_type with | intro prop_nbr prop_type =>
  cases prop_type with | intro prop_lvl prop_type =>
  cases prop_type with | intro prop_col prop_type =>
  cases prop_type with | intro prop_pst prop_type =>
  cases prop_type with | intro prop_inc_nil prop_type =>
  cases prop_type with | intro prop_out_cons prop_type =>
  cases prop_type with | intro prop_out_colours prop_type =>
  cases prop_type with | intro prop_dir_nil prop_type =>
  cases prop_type with | intro prop_ind_len prop_type =>
  cases prop_type with | intro prop_ind_colours prop_type =>
  cases prop_type with | intro prop_incoming prop_type =>
  cases prop_type with | intro prop_outgoing prop_indirect =>
  --
  simp only [type3_collapse];
  /- Check Center-/
  apply And.intro ( by exact prop_nbr; );                         /- := RULE.CENTER.NUMBER > 0 -/
  apply And.intro ( by exact prop_lvl; );                         /- := RULE.CENTER.LEVEL > 0 -/
  apply And.intro ( by exact prop_col; );                         /- := RULE.CENTER.COLLAPSED = true -/
  apply And.intro ( by exact prop_pst; );                         /- := RULE.CENTER.PAST = (past::pasts) -/
  /- Check Deduction Edges -/
  apply And.intro ( by exact prop_inc_nil; );                     /- := ( RULE.INCOMING = [] ) → ( RULE.CENTER.HYPOTHESIS = true ) -/
  apply And.intro ( by exact prop_out_cons; );                    /- := RULE.OUTGOING = (out::outs) -/
  apply And.intro ( by exact prop_out_colours; );                 /- := OUT₁.COLOUR = OUT₂.COLOUR ↔ OUT₁ = OUT₂ -/
  /- Check Ancestral Paths -/
  apply And.intro ( by rewrite [prop_dir_nil];                    /- := ( RULE.CENTER.HYPOTHESIS = false ) → ( RULE.DIRECT = [] ) -/
                       intros; trivial; );
  apply And.intro ( by rewrite [prop_dir_nil];                    /- := RULE.DIRECT ≠ [] → RULE.CENTER.HYPOTHESIS = true -/
                       intros; trivial; );
  apply And.intro ( by exact prop_ind_len; );                     /- := List.length (RULE.INCOMING) = List.length (RULE.INDIRECT) -/
  apply And.intro ( by exact prop_incoming; );                    /- := type_incoming RULE -/
  apply And.intro ( by simp only [type_outgoing₃];                /- := type_outgoing RULE -/
                       intro out out_cases;
                       exact Or.inl (prop_outgoing out_cases); );
  apply And.intro ( by simp only [type_direct];                   /- := type_direct RULE -/
                       rewrite [prop_dir_nil];
                       intro dir dir_cases;
                       trivial; );
  exact prop_indirect;                                            /- := type_indirect RULE -/
  -----------------------------------------------------------------------------------------------------------------------------------------
end COVERAGE.T3_Of_T1


namespace COVERAGE.T1_Of_T0
  --333 set_option trace.Meta.Tactic.simp true
  /- Pre-Collapse: Type0 ⊇-Elimination -/
  theorem PreCol_Of_PreCollapse_Elim {RULE : Neighborhood} :
    ( type0_elimination RULE ) →
    ---------------------------
    ( type1_pre_collapse (pre_collapse RULE) ) := by
  intro prop_type;
  simp only [type0_elimination] at prop_type;
  cases prop_type with | intro prop_nbr prop_type =>
  cases prop_type with | intro prop_lvl prop_type =>
  cases prop_type with | intro prop_hpt prop_type =>
  cases prop_type with | intro prop_col prop_type =>
  cases prop_type with | intro prop_pst prop_type =>
  cases prop_type with | intro inc_nbr prop_type =>
  cases prop_type with | intro out_nbr prop_type =>
  cases prop_type with | intro antecedent prop_type =>
  cases prop_type with | intro out_fml prop_type =>
  cases prop_type with | intro major_hpt prop_type =>
  cases prop_type with | intro minor_hpt prop_type =>
  cases prop_type with | intro major_dep prop_type =>
  cases prop_type with | intro minor_dep prop_type =>
  cases prop_type with | intro prop_inc_nbr prop_type =>
  cases prop_type with | intro prop_out_nbr prop_type =>
  cases prop_type with | intro prop_incoming prop_type =>
  cases prop_type with | intro prop_outgoing prop_type =>
  cases prop_type with | intro prop_direct prop_indirect =>
  /- Unfold Goal: -/
  simp only [pre_collapse];
  simp only [prop_hpt, prop_col];
  simp only [prop_incoming, prop_outgoing, prop_direct];
  simp only [pre_collapse.outgoing];
  simp only [pre_collapse.direct];
  simp only [pre_collapse.indirect];
  simp only [pre_collapse.indirect.create];
  simp only [type1_pre_collapse];
  /- Check Center -/
  apply And.intro ( by exact prop_nbr; );                   /- := RULE.CENTER.NUMBER > 0 -/
  apply And.intro ( by exact prop_lvl; );                   /- := RULE.CENTER.LEVEL > 0 -/
  apply And.intro ( by exact prop_col; );                   /- := RULE.CENTER.COLLAPSED = false -/
  apply And.intro ( by exact prop_pst; );                   /- := RULE.CENTER.PAST = [] -/
  /- Check Deduction Edges -/
  apply And.intro ( by rewrite [prop_hpt]; trivial; );          /- := ( RULE.INCOMING = [] ) ↔ ( RULE.CENTER.HYPOTHESIS = true ) -/
  apply And.intro ( by simp only [List.length]; trivial; );     /- := List.length (RULE.INCOMING) ≤ 2 -/
  apply And.intro ( by simp only [List.cons.injEq];             /- := RULE.OUTGOING = [out] -/
                       simp only [exists_and_right];
                       simp only [exists_eq'];
                       trivial; );
  apply And.intro ( by intro out₁ out₂ out_mem₁ out_mem₂;               /- := OUT₁.COLOUR = OUT₂.COLOUR ↔ OUT₁ = OUT₂ -/
                       simp only [List.Eq_Iff_Mem_Unit] at out_mem₁ out_mem₂;
                       simp only [out_mem₁, out_mem₂];
                       intros; trivial; );
  /- Check Ancestral Paths -/
  apply And.intro ( by trivial; );                                      /- := RULE.DIRECT = [] -/
  apply And.intro ( by intro ind₁ ind₂ ind_mem₁ ind_mem₂;               /- := ( ind₁.COLOURS = ind₂.COLOURS ) ↔ ( ind₁.START = ind₂.START ) -/
                       apply DEFINE.Def_Check_Path_Starts ind_mem₁ ind_mem₂;
                       simp only [DEFINE.check_path_starts];
                       simp only [DEFINE.check_path_starts.loop];
                       trivial; );
  apply And.intro ( by simp only [List.length]; );                      /- := List.length (RULE.INDIRECT) = List.length (RULE.INCOMING) -/
  apply And.intro ( by intro ind ind_mem;                               /- := ind.COLOURS = [0, RULE.CENTER.NUMBER] -/
                       apply DEFINE.Def_Check_Path_Colours ind_mem;
                       simp only [DEFINE.check_path_colours];
                       trivial; );
  /- Check Incoming Edges -/--------------------------------------------------------------------------------------------------------------------------
  apply And.intro ( by intro inc inc_cases;
                       simp only [type_incoming, type_incoming.check, and_assoc];
                       cases inc_cases with
                       | head _ => simp only [Vertex.node.injEq, true_and, and_true];
                                   apply And.intro ( by exact Nat.zero_lt_succ inc_nbr; );                                  /- := INC.START.NUMBER > 0 -/
                                   /- Match-Verification Loop: -/
                                   apply Exists.intro RULE.CENTER.NUMBER;                                                   /- colour (Path Notation) -/
                                   apply Exists.intro [];                                                                   /- colours (Path Notation) -/
                                   apply Exists.intro (node out_nbr (RULE.CENTER.LEVEL - 1) out_fml false false []);        /- anc (Ancestral Node) -/
                                   exact ( by repeat ( first | exact List.Mem.head _ | apply List.Mem.tail ); );            /- := path anc INC.START (0::colour::colours) ∈ INDIRECT -/
                       | tail _ inc_cases => cases inc_cases with
                                             | head _ => simp only [Vertex.node.injEq, true_and, and_true];
                                                         apply And.intro ( by exact prop_inc_nbr; );                                              /- := INC.START.NUMBER > 0 -/
                                                         /- Match-Verification Loop: -/
                                                         apply Exists.intro RULE.CENTER.NUMBER;                                                   /- colour (Path Notation) -/
                                                         apply Exists.intro [];                                                                   /- colours (Path Notation) -/
                                                         apply Exists.intro (node out_nbr (RULE.CENTER.LEVEL - 1) out_fml false false []);        /- anc (Ancestral Node) -/
                                                         exact ( by repeat ( first | exact List.Mem.head _ | apply List.Mem.tail ); );            /- := path anc INC.START (0::colour::colours) ∈ INDIRECT -/
                                             | tail _ inc_cases => trivial; );
  /- Check Outgoing Edges -/--------------------------------------------------------------------------------------------------------------------------
  apply And.intro ( by intro out out_cases;
                       simp only [type_outgoing₁];
                       apply Or.inr; simp only [type_outgoing₁.check_ie₁, and_assoc];                  /- := Type 0 Elimination -/
                       cases out_cases with
                       | head _ => simp only [Vertex.node.injEq, true_and];
                                   apply And.intro ( by exact Or.inl prop_hpt; );                      /- := CENTER.HYPOTHESIS = false ∨ CENTER.COLLAPSED = true -/
                                   apply And.intro ( by exact prop_out_nbr; );                         /- := OUT.END.NUMBER > 0 -/
                                   apply And.intro ( by exact List.Mem.head RULE.CENTER.PAST; );       /- := OUT.COLOUR ∈ (RULE.CENTER.NUMBER::RULE.CENTER.PAST) -/
                                   /- Match-Verification Loop: -/
                                   apply Exists.intro (node inc_nbr (RULE.CENTER.LEVEL+1) antecedent minor_hpt false []);   /- inc (Incoming Node) -/
                                   exact ( by repeat ( first | exact List.Mem.head _ | apply List.Mem.tail ); );            /- := path OUT.END inc [0, OUT.COLOUR] ∈ INDIRECT -/
                       | tail _ out_cases => trivial; );
  /- Check Indirect Paths -/--------------------------------------------------------------------------------------------------------------------------
  intro ind ind_cases;
  simp only [type_indirect, type_indirect.check, and_assoc];
  cases ind_cases with
  | head _ => simp only [Vertex.node.injEq, true_and];
              apply And.intro ( by exact prop_out_nbr; );                                         /- := IND.START.NUMBER > 0 -/
              apply And.intro ( by exact Nat.le_refl (RULE.CENTER.LEVEL - 1); );                  /- := IND.START.LEVEL ≤ RULE.CENTER.LEVEL - 1 -/
              apply And.intro ( by exact Nat.zero_lt_succ inc_nbr; );                             /- := IND.END.NUMBER > 0 -/
              apply And.intro ( by simp only [List.length];                                       /- := IND.START.LEVEL + List.length (IND.COLOURS) = RULE.CENTER.LEVEL + 1 -/
                                   simp only [Nat.zero_add, ←Nat.add_assoc];
                                   simp only [Nat.sub_add_cancel prop_lvl]; );
              apply Exists.intro RULE.CENTER.NUMBER;                                              /- colour (Path Notation) -/
              apply Exists.intro [];                                                              /- colours (Path Notation) -/
              apply And.intro ( by exact COLLAPSE.Check_Numbers_Unit prop_nbr );                  /- := check_numbers (colour::colours) -/
              apply And.intro ( by exact List.Mem.head RULE.CENTER.PAST; );                       /- := colour ∈ (RULE.CENTER.NUMBER::RULE.CENTER.PAST) -/
              apply And.intro ( by trivial; );                                                    /- := IND.COLOURS = (0::colour::colours) -/
              /- Match-Verification Loop: -/
              exact And.intro ( by apply Exists.intro #major_dep;                                                              /- dep_inc (Incoming Dependency) -/
                                   apply And.intro ( by repeat ( first | exact List.Mem.head _ | apply List.Mem.tail ); );    /- := edge IND.END RULE.CENTER 0 dep_inc ∈ RULE.INCOMING -/
                                   intro inc inc_cases;                                                                       /- := ( INC.START = IND.END ) ↔ ( INC = edge IND.END RULE.CENTER 0 dep_inc ) -/
                                   apply DEFINE.Def_Check_Path_Incoming inc_cases;
                                   simp only [DEFINE.check_path_incoming];
                                   /- Resolve Missmatch: -/
                                   simp only [Deduction.edge.injEq, true_and, and_true];
                                   simp only [Vertex.node.injEq, true_and, and_true];
                                   simp only [iff_self_and, and_imp];
                                   have succ_ne_self := Nat.succ_ne_self inc_nbr;
                                   simp only [ne_eq, eq_comm] at succ_ne_self;
                                   intro succ_eq_self;
                                   trivial; )
                              ( by apply Exists.intro (node out_nbr (RULE.CENTER.LEVEL - 1) out_fml false false []);          /- out (Outgoing Node) -/
                                   apply Exists.intro (minor_dep ∪ major_dep);                                                /- dep_out (Outgoing Dependency) -/
                                   apply And.intro ( by simp only [Vertex.node.injEq]; );                                     /- := ( colours = [] ) ↔ ( out = IND.START ) -/
                                   apply And.intro ( by repeat ( first | exact List.Mem.head _ | apply List.Mem.tail ); );    /- := edge RULE.CENTER out colour dep_out ∈ RULE.OUTGOING -/
                                   intro out out_cases;                                                                       /- := ( OUT.COLOUR = colour ) ↔ ( OUT = edge RULE.CENTER out colour dep_out ) -/
                                   apply DEFINE.Def_Check_Path_Outgoing out_cases;
                                   simp only [DEFINE.check_path_outgoing];
                                   /- Perfect Match! -/
                                   trivial; );
  | tail _ ind_cases => cases ind_cases with
                        | head _ => simp only [Vertex.node.injEq, true_and];
                                    apply And.intro ( by exact prop_out_nbr; );                                         /- := IND.START.NUMBER > 0 -/
                                    apply And.intro ( by exact Nat.le_refl (RULE.CENTER.LEVEL - 1); );                  /- := IND.START.LEVEL ≤ RULE.CENTER.LEVEL - 1 -/
                                    apply And.intro ( by exact prop_inc_nbr; );                                         /- := IND.END.NUMBER > 0 -/
                                    apply And.intro ( by simp only [List.length];                                       /- := IND.START.LEVEL + List.length (IND.COLOURS) = RULE.CENTER.LEVEL + 1 -/
                                                         simp only [Nat.zero_add, ←Nat.add_assoc];
                                                         simp only [Nat.sub_add_cancel prop_lvl]; );
                                    apply Exists.intro RULE.CENTER.NUMBER;                                              /- colour (Path Notation) -/
                                    apply Exists.intro [];                                                              /- colours (Path Notation) -/
                                    apply And.intro ( by exact COLLAPSE.Check_Numbers_Unit prop_nbr );                  /- := check_numbers (colour::colours) -/
                                    apply And.intro ( by exact List.Mem.head RULE.CENTER.PAST; );                       /- := colour ∈ (RULE.CENTER.NUMBER::RULE.CENTER.PAST) -/
                                    apply And.intro ( by trivial; );                                                    /- := IND.COLOURS = (0::colour::colours) -/
                                    /- Match-Verification Loop: -/
                                    exact And.intro ( by apply Exists.intro #minor_dep;                                                              /- dep_inc (Incoming Dependency) -/
                                                         apply And.intro ( by repeat ( first | exact List.Mem.head _ | apply List.Mem.tail ); );    /- := edge IND.END RULE.CENTER 0 dep_inc ∈ RULE.INCOMING -/
                                                         intro inc inc_cases;                                                                       /- := ( INC.START = IND.END ) ↔ ( INC = edge IND.END RULE.CENTER 0 dep_inc ) -/
                                                         apply DEFINE.Def_Check_Path_Incoming inc_cases;
                                                         simp only [DEFINE.check_path_incoming];
                                                         /- Resolve Missmatch: -/
                                                         simp only [Deduction.edge.injEq, true_and, and_true];
                                                         simp only [Vertex.node.injEq, true_and, and_true];
                                                         simp only [iff_self_and, and_imp];
                                                         have succ_ne_self := Nat.succ_ne_self inc_nbr;
                                                         simp only [ne_eq] at succ_ne_self;
                                                         intro succ_eq_self;
                                                         trivial; )
                                                    ( by apply Exists.intro (node out_nbr (RULE.CENTER.LEVEL - 1) out_fml false false []);          /- out (Outgoing Node) -/
                                                         apply Exists.intro (minor_dep ∪ major_dep);                                                /- dep_out (Outgoing Dependency) -/
                                                         apply And.intro ( by simp only [Vertex.node.injEq]; );                                     /- := ( colours = [] ) ↔ ( out = IND.START ) -/
                                                         apply And.intro ( by repeat ( first | exact List.Mem.head _ | apply List.Mem.tail ); );    /- := edge RULE.CENTER out colour dep_out ∈ RULE.OUTGOING -/
                                                         intro out out_cases;                                                                       /- := ( OUT.COLOUR = colour ) ↔ ( OUT = edge RULE.CENTER out colour dep_out ) -/
                                                         apply DEFINE.Def_Check_Path_Outgoing out_cases;
                                                         simp only [DEFINE.check_path_outgoing];
                                                         /- Perfect Match! -/
                                                         trivial; );
                        | tail _ ind_cases => trivial;
  -----------------------------------------------------------------------------------------------------------------------------------------

  /- Pre-Collapse: Type0 ⊇-Introduction -/
  theorem PreCol_Of_PreCollapse_Intro {RULE : Neighborhood} :
    ( type0_introduction RULE ) →
    ---------------------------
    ( type1_pre_collapse (pre_collapse RULE) ) := by
  intro prop_type;
  simp only [type0_introduction] at prop_type;
  cases prop_type with | intro prop_nbr prop_type =>
  cases prop_type with | intro prop_lvl prop_type =>
  cases prop_type with | intro prop_hpt prop_type =>
  cases prop_type with | intro prop_col prop_type =>
  cases prop_type with | intro prop_pst prop_type =>
  cases prop_type with | intro inc_nbr prop_type =>
  cases prop_type with | intro out_nbr prop_type =>
  cases prop_type with | intro antecedent prop_type =>
  cases prop_type with | intro consequent prop_type =>
  cases prop_type with | intro out_fml prop_type =>
  cases prop_type with | intro inc_dep prop_type =>
  cases prop_type with | intro prop_fml prop_type =>
  cases prop_type with | intro prop_inc_nbr prop_type =>
  cases prop_type with | intro prop_out_nbr prop_type =>
  cases prop_type with | intro prop_incoming prop_type =>
  cases prop_type with | intro prop_outgoing prop_type =>
  cases prop_type with | intro prop_direct prop_indirect =>
  /- Unfold Goal: -/
  simp only [pre_collapse];
  simp only [prop_hpt, prop_col];
  simp only [prop_incoming, prop_outgoing, prop_direct];
  simp only [pre_collapse.outgoing];
  simp only [pre_collapse.direct];
  simp only [pre_collapse.indirect];
  simp only [pre_collapse.indirect.create];
  simp only [type1_pre_collapse];
  /- Check Center -/
  apply And.intro ( by exact prop_nbr; );                   /- := RULE.CENTER.NUMBER > 0 -/
  apply And.intro ( by exact prop_lvl; );                   /- := RULE.CENTER.LEVEL > 0 -/
  apply And.intro ( by exact prop_col; );                   /- := RULE.CENTER.COLLAPSED = false -/
  apply And.intro ( by exact prop_pst; );                   /- := RULE.CENTER.PAST = [] -/
  /- Check Deduction Edges -/
  apply And.intro ( by rewrite [prop_hpt]; trivial; );          /- := ( RULE.INCOMING = [] ) ↔ ( RULE.CENTER.HYPOTHESIS = true ) -/
  apply And.intro ( by simp only [List.length]; trivial; );     /- := List.length (RULE.INCOMING) ≤ 2 -/
  apply And.intro ( by simp only [List.cons.injEq];             /- := RULE.OUTGOING = [out] -/
                       simp only [exists_and_right];
                       simp only [exists_eq'];
                       trivial; );
  apply And.intro ( by intro out₁ out₂ out_mem₁ out_mem₂;               /- := OUT₁.COLOUR = OUT₂.COLOUR ↔ OUT₁ = OUT₂ -/
                       simp only [List.Eq_Iff_Mem_Unit] at out_mem₁ out_mem₂;
                       simp only [out_mem₁, out_mem₂];
                       intros; trivial; );
  /- Check Ancestral Paths -/
  apply And.intro ( by trivial; );                                      /- := RULE.DIRECT = [] -/
  apply And.intro ( by intro ind₁ ind₂ ind_mem₁ ind_mem₂;               /- := ( ind₁.COLOURS = ind₂.COLOURS ) ↔ ( ind₁.START = ind₂.START ) -/
                       apply DEFINE.Def_Check_Path_Starts ind_mem₁ ind_mem₂;
                       simp only [DEFINE.check_path_starts];
                       simp only [DEFINE.check_path_starts.loop];
                       trivial; );
  apply And.intro ( by simp only [List.length]; );                      /- := List.length (RULE.INDIRECT) = List.length (RULE.INCOMING) -/
  apply And.intro ( by intro ind ind_mem;                               /- := ind.COLOURS = [0, RULE.CENTER.NUMBER] -/
                       apply DEFINE.Def_Check_Path_Colours ind_mem;
                       simp only [DEFINE.check_path_colours];
                       trivial; );
  /- Check Incoming Edges -/--------------------------------------------------------------------------------------------------------------------------
  apply And.intro ( by intro inc inc_cases;
                       simp only [type_incoming, type_incoming.check, and_assoc];
                       cases inc_cases with
                       | head _ => simp only [Vertex.node.injEq, true_and, and_true];
                                   apply And.intro ( by exact prop_inc_nbr; );                                              /- := INC.START.NUMBER > 0 -/
                                   /- Match-Verification Loop: -/
                                   apply Exists.intro RULE.CENTER.NUMBER;                                                   /- colour (Path Notation) -/
                                   apply Exists.intro [];                                                                   /- colours (Path Notation) -/
                                   apply Exists.intro (node out_nbr (RULE.CENTER.LEVEL - 1) out_fml false false []);        /- anc (Ancestral Node) -/
                                   exact ( by repeat ( first | exact List.Mem.head _ | apply List.Mem.tail ); );            /- := path anc INC.START (0::colour::colours) ∈ INDIRECT -/
                       | tail _ inc_cases => trivial; );
  /- Check Outgoing Edges -/--------------------------------------------------------------------------------------------------------------------------
  apply And.intro ( by intro out out_cases;
                       simp only [type_outgoing₁];
                       apply Or.inr; simp only [type_outgoing₁.check_ie₁, and_assoc];                  /- := Type 0 Introduction -/
                       cases out_cases with
                       | head _ => simp only [Vertex.node.injEq, true_and];
                                   apply And.intro ( by exact Or.inl prop_hpt; );                      /- := CENTER.HYPOTHESIS = false ∨ CENTER.COLLAPSED = true -/
                                   apply And.intro ( by exact prop_out_nbr; );                         /- := OUT.END.NUMBER > 0 -/
                                   apply And.intro ( by exact List.Mem.head RULE.CENTER.PAST; );       /- := OUT.COLOUR ∈ (RULE.CENTER.NUMBER::RULE.CENTER.PAST) -/
                                   /- Match-Verification Loop: -/
                                   apply Exists.intro (node inc_nbr (RULE.CENTER.LEVEL+1) consequent false false []);       /- inc (Incoming Node) -/
                                   exact ( by repeat ( first | exact List.Mem.head _ | apply List.Mem.tail ); );            /- := path OUT.END inc [0, OUT.COLOUR] ∈ INDIRECT -/
                       | tail _ out_cases => trivial; );
  /- Check Indirect Paths -/--------------------------------------------------------------------------------------------------------------------------
  intro ind ind_cases;
  simp only [type_indirect, type_indirect.check, and_assoc];
  cases ind_cases with
  | head _ => simp only [Vertex.node.injEq, true_and];
              apply And.intro ( by exact prop_out_nbr; );                                         /- := IND.START.NUMBER > 0 -/
              apply And.intro ( by exact Nat.le_refl (RULE.CENTER.LEVEL - 1); );                  /- := IND.START.LEVEL ≤ RULE.CENTER.LEVEL - 1 -/
              apply And.intro ( by exact prop_inc_nbr; );                                         /- := IND.END.NUMBER > 0 -/
              apply And.intro ( by simp only [List.length];                                       /- := IND.START.LEVEL + List.length (IND.COLOURS) = RULE.CENTER.LEVEL + 1 -/
                                   simp only [Nat.zero_add, ←Nat.add_assoc];
                                   simp only [Nat.sub_add_cancel prop_lvl]; );
              apply Exists.intro RULE.CENTER.NUMBER;                                              /- colour (Path Notation) -/
              apply Exists.intro [];                                                              /- colours (Path Notation) -/
              apply And.intro ( by exact COLLAPSE.Check_Numbers_Unit prop_nbr );                  /- := check_numbers (colour::colours) -/
              apply And.intro ( by exact List.Mem.head RULE.CENTER.PAST; );                       /- := colour ∈ (RULE.CENTER.NUMBER::RULE.CENTER.PAST) -/
              apply And.intro ( by trivial; );                                                    /- := IND.COLOURS = (0::colour::colours) -/
              /- Match-Verification Loop: -/
              exact And.intro ( by apply Exists.intro #inc_dep;                                                               /- dep_inc (Incoming Dependency) -/
                                   apply And.intro ( by repeat ( first | exact List.Mem.head _ | apply List.Mem.tail ); );    /- := edge IND.END RULE.CENTER 0 dep_inc ∈ RULE.INCOMING -/
                                   intro inc inc_cases;                                                                       /- := ( INC.START = IND.END ) ↔ ( INC = edge IND.END RULE.CENTER 0 dep_inc ) -/
                                   apply DEFINE.Def_Check_Path_Incoming inc_cases;
                                   simp only [DEFINE.check_path_incoming];
                                   /- Perfect Match! -/
                                   trivial; )
                              ( by apply Exists.intro (node out_nbr (RULE.CENTER.LEVEL - 1) out_fml false false []);          /- out (Outgoing Node) -/
                                   apply Exists.intro (inc_dep − [antecedent]);                                               /- dep_out (Outgoing Dependency) -/
                                   apply And.intro ( by simp only [Vertex.node.injEq]; );                                     /- := ( colours = [] ) ↔ ( out = IND.START ) -/
                                   apply And.intro ( by repeat ( first | exact List.Mem.head _ | apply List.Mem.tail ); );    /- := edge RULE.CENTER out colour dep_out ∈ RULE.OUTGOING -/
                                   intro out out_cases;                                                                       /- := ( OUT.COLOUR = colour ) ↔ ( OUT = edge RULE.CENTER out colour dep_out ) -/
                                   apply DEFINE.Def_Check_Path_Outgoing out_cases;
                                   simp only [DEFINE.check_path_outgoing];
                                   /- Perfect Match! -/
                                   trivial; );
  | tail _ ind_cases => trivial;
  -----------------------------------------------------------------------------------------------------------------------------------------

  /- Pre-Collapse: Type0 Hypothesis (Top Formula) -/
  theorem PreCol_Of_PreCollapse_Top {RULE : Neighborhood} :
    ( type0_hypothesis RULE ) →
    ---------------------------
    ( type1_pre_collapse (pre_collapse RULE) ) := by
  intro prop_type;
  simp only [type0_hypothesis] at prop_type;
  cases prop_type with | intro prop_nbr prop_type =>
  cases prop_type with | intro prop_lvl prop_type =>
  cases prop_type with | intro prop_hpt prop_type =>
  cases prop_type with | intro prop_col prop_type =>
  cases prop_type with | intro prop_pst prop_type =>
  cases prop_type with | intro out_nbr prop_type =>
  cases prop_type with | intro out_fml prop_type =>
  cases prop_type with | intro prop_out_nbr prop_type =>
  cases prop_type with | intro prop_incoming prop_type =>
  cases prop_type with | intro prop_outgoing prop_type =>
  cases prop_type with | intro prop_direct prop_indirect =>
  /- Unfold Goal: -/
  simp only [pre_collapse];
  simp only [prop_hpt, prop_col];
  simp only [prop_incoming, prop_outgoing, prop_direct];
  simp only [pre_collapse.outgoing];
  simp only [pre_collapse.direct];
  simp only [pre_collapse.indirect];
  simp only [type1_pre_collapse];
  /- Check Center -/
  apply And.intro ( by exact prop_nbr; );                   /- := RULE.CENTER.NUMBER > 0 -/
  apply And.intro ( by exact prop_lvl; );                   /- := RULE.CENTER.LEVEL > 0 -/
  apply And.intro ( by exact prop_col; );                   /- := RULE.CENTER.COLLAPSED = false -/
  apply And.intro ( by exact prop_pst; );                   /- := RULE.CENTER.PAST = [] -/
  /- Check Deduction Edges -/
  apply And.intro ( by rewrite [prop_hpt]; trivial; );          /- := ( RULE.INCOMING = [] ) ↔ ( RULE.CENTER.HYPOTHESIS = true ) -/
  apply And.intro ( by simp only [List.length]; trivial; );     /- := List.length (RULE.INCOMING) ≤ 2 -/
  apply And.intro ( by simp only [List.cons.injEq];             /- := RULE.OUTGOING = [out] -/
                       simp only [exists_and_right];
                       simp only [exists_eq'];
                       trivial; );
  apply And.intro ( by intro out₁ out₂ out_mem₁ out_mem₂;               /- := OUT₁.COLOUR = OUT₂.COLOUR ↔ OUT₁ = OUT₂ -/
                       simp only [List.Eq_Iff_Mem_Unit] at out_mem₁ out_mem₂;
                       simp only [out_mem₁, out_mem₂];
                       intros; trivial; );
  /- Check Ancestral Paths -/
  apply And.intro ( by trivial; );                                      /- := RULE.DIRECT = [] -/
  apply And.intro ( by intro ind₁ ind₂ ind_mem₁ ind_mem₂;               /- := ( ind₁.COLOURS = ind₂.COLOURS ) ↔ ( ind₁.START = ind₂.START ) -/
                       apply DEFINE.Def_Check_Path_Starts ind_mem₁ ind_mem₂;
                       simp only [DEFINE.check_path_starts]; );
  apply And.intro ( by simp only [List.length]; );                      /- := List.length (RULE.INDIRECT) = List.length (RULE.INCOMING) -/
  apply And.intro ( by intro ind ind_mem;                               /- := ind.COLOURS = [0, RULE.CENTER.NUMBER] -/
                       apply DEFINE.Def_Check_Path_Colours ind_mem;
                       simp only [DEFINE.check_path_colours]; );
  /- Check Incoming Edges -/--------------------------------------------------------------------------------------------------------------------------
  apply And.intro ( by intro inc inc_cases; trivial; );
  /- Check Outgoing Edges -/--------------------------------------------------------------------------------------------------------------------------
  apply And.intro ( by intro out out_cases;
                       simp only [type_outgoing₁];
                       apply Or.inl; simp only [type_outgoing₁.check_h₁, and_assoc];                   /- := Type 0 Hypothesis -/
                       cases out_cases with
                       | head _ => simp only [Vertex.node.injEq, true_and];
                                   apply And.intro ( by exact prop_hpt; );                             /- := CENTER.HYPOTHESIS = true -/
                                   apply And.intro ( by exact prop_out_nbr; );                         /- := OUT.END.NUMBER > 0 -/
                                   trivial;                                                            /- := OUT.COLOUR = 0 -/
                       | tail _ out_cases => trivial; );
  /- Check Indirect Paths -/--------------------------------------------------------------------------------------------------------------------------
  intro ind ind_cases; trivial;
  -----------------------------------------------------------------------------------------------------------------------------------------
end COVERAGE.T1_Of_T0


namespace COVERAGE.T3_Of_T2
  --333 set_option trace.Meta.Tactic.simp true
  /- Pre-Collapse: Type2 ⊇-Elimination -/
  theorem PreCol_Of_PreCollapse_Elim {RULE : Neighborhood} :
    ( type2_elimination RULE ) →
    ---------------------------
    ( type3_pre_collapse (pre_collapse RULE) ) := by
  intro prop_type;
  simp only [type2_elimination] at prop_type;
  cases prop_type with | intro prop_nbr prop_type =>
  cases prop_type with | intro prop_lvl prop_type =>
  cases prop_type with | intro prop_hpt prop_type =>
  cases prop_type with | intro prop_col prop_type =>
  cases prop_type with | intro prop_pst prop_type =>
  cases prop_type with | intro inc_nbr prop_type =>
  cases prop_type with | intro out_nbr prop_type =>
  cases prop_type with | intro anc_nbr prop_type =>
  cases prop_type with | intro anc_lvl prop_type =>
  cases prop_type with | intro antecedent prop_type =>
  cases prop_type with | intro out_fml prop_type =>
  cases prop_type with | intro anc_fml prop_type =>
  cases prop_type with | intro major_hpt prop_type =>
  cases prop_type with | intro minor_hpt prop_type =>
  cases prop_type with | intro out_hpt prop_type =>
  cases prop_type with | intro major_dep prop_type =>
  cases prop_type with | intro minor_dep prop_type =>
  cases prop_type with | intro past prop_type =>
  cases prop_type with | intro colour prop_type =>
  cases prop_type with | intro pasts prop_type =>
  cases prop_type with | intro colours prop_type =>
  cases prop_type with | intro prop_inc_nbr prop_type =>
  cases prop_type with | intro prop_out_nbr prop_type =>
  cases prop_type with | intro prop_anc_nbr prop_type =>
  cases prop_type with | intro prop_anc_lvl prop_type =>
  cases prop_type with | intro prop_colour prop_type =>
  cases prop_type with | intro prop_pasts prop_type =>
  cases prop_type with | intro prop_colours prop_type =>
  cases prop_type with | intro prop_incoming prop_type =>
  cases prop_type with | intro prop_outgoing prop_type =>
  cases prop_type with | intro prop_direct prop_indirect =>
  /- Unfold Goal: -/
  simp only [pre_collapse];
  simp only [prop_hpt, prop_col];
  simp only [prop_incoming, prop_outgoing, prop_direct];
  simp only [pre_collapse.outgoing];
  simp only [pre_collapse.direct];
  simp only [pre_collapse.indirect];
  simp only [pre_collapse.indirect.move_up];
  simp only [type3_pre_collapse];
  /- Check Center -/
  apply And.intro ( by exact prop_nbr; );                   /- := RULE.CENTER.NUMBER > 0 -/
  apply And.intro ( by exact prop_lvl; );                   /- := RULE.CENTER.LEVEL > 0 -/
  apply And.intro ( by exact prop_col; );                   /- := RULE.CENTER.COLLAPSED = false -/
  apply And.intro ( by exact prop_pst; );                   /- := RULE.CENTER.PAST = [] -/
  /- Check Deduction Edges -/
  apply And.intro ( by rewrite [prop_hpt]; trivial; );          /- := ( RULE.INCOMING = [] ) ↔ ( RULE.CENTER.HYPOTHESIS = true ) -/
  apply And.intro ( by simp only [List.length]; trivial; );     /- := List.length (RULE.INCOMING) ≤ 2 -/
  apply And.intro ( by simp only [List.cons.injEq];             /- := RULE.OUTGOING = [out] -/
                       simp only [exists_and_right];
                       simp only [exists_eq'];
                       trivial; );
  apply And.intro ( by intro out₁ out₂ out_mem₁ out_mem₂;               /- := OUT₁.COLOUR = OUT₂.COLOUR ↔ OUT₁ = OUT₂ -/
                       simp only [List.Eq_Iff_Mem_Unit] at out_mem₁ out_mem₂;
                       simp only [out_mem₁, out_mem₂];
                       intros; trivial; );
  /- Check Ancestral Paths -/
  apply And.intro ( by rewrite [prop_hpt]; trivial; );                  /- := ( RULE.CENTER.HYPOTHESIS = false ) → ( RULE.DIRECT = [] ) -/
  apply And.intro ( by rewrite [prop_hpt]; trivial; );                  /- := ( RULE.DIRECT ≠ [] ) → ( RULE.CENTER.HYPOTHESIS = true ) -/
  apply And.intro ( by exact Or.inl trivial; );                         /- := ( RULE.DIRECT = [] ) ∨ ( RULE.DIRECT = [dir] ) -/
  apply And.intro ( by intro ind₁ ind₂ ind_mem₁ ind_mem₂;               /- := ( ind₁.COLOURS = ind₂.COLOURS ) ↔ ( ind₁.START = ind₂.START ) -/
                       apply DEFINE.Def_Check_Path_Starts ind_mem₁ ind_mem₂;
                       simp only [DEFINE.check_path_starts];
                       simp only [DEFINE.check_path_starts.loop];
                       trivial; );
  apply And.intro ( by simp only [List.length]; );                      /- := List.length (RULE.INDIRECT) = List.length (RULE.INCOMING) -/
  /- Check Incoming Edges -/--------------------------------------------------------------------------------------------------------------------------
  apply And.intro ( by intro inc inc_cases;
                       simp only [type_incoming, type_incoming.check, and_assoc];
                       cases inc_cases with
                       | head _ => simp only [Vertex.node.injEq, true_and, and_true];
                                   apply And.intro ( by exact Nat.zero_lt_succ inc_nbr; );                                  /- := INC.START.NUMBER > 0 -/
                                   /- Match-Verification Loop: -/
                                   apply Exists.intro RULE.CENTER.NUMBER;                                                   /- colour (Path Notation) -/
                                   apply Exists.intro (colour::colours);                                                    /- colours (Path Notation) -/
                                   apply Exists.intro (node anc_nbr anc_lvl anc_fml false false []);                        /- anc (Ancestral Node) -/
                                   exact ( by repeat ( first | exact List.Mem.head _ | apply List.Mem.tail ); );            /- := path anc INC.START (0::colour::colours) ∈ INDIRECT -/
                       | tail _ inc_cases => cases inc_cases with
                                             | head _ => simp only [Vertex.node.injEq, true_and, and_true];
                                                         apply And.intro ( by exact prop_inc_nbr; );                                              /- := INC.START.NUMBER > 0 -/
                                                         /- Match-Verification Loop: -/
                                                         apply Exists.intro RULE.CENTER.NUMBER;                                                   /- colour (Path Notation) -/
                                                         apply Exists.intro (colour::colours);                                                    /- colours (Path Notation) -/
                                                         apply Exists.intro (node anc_nbr anc_lvl anc_fml false false []);                        /- anc (Ancestral Node) -/
                                                         exact ( by repeat ( first | exact List.Mem.head _ | apply List.Mem.tail ); );            /- := path anc INC.START (0::colour::colours) ∈ INDIRECT -/
                                             | tail _ inc_cases => trivial; );
  /- Check Outgoing Edges -/--------------------------------------------------------------------------------------------------------------------------
  apply And.intro ( by intro out out_cases;
                       simp only [type_outgoing₃];
                       apply Or.inr; apply Or.inr; simp only [type_outgoing₃.check_ie₃, and_assoc];                 /- := Type 2 Elimination -/
                       cases out_cases with
                       | head _ => simp only [Vertex.node.injEq, true_and];
                                   apply And.intro ( by exact Or.inl prop_hpt; );                                   /- := CENTER.HYPOTHESIS = false ∨ CENTER.COLLAPSED = true -/
                                   apply And.intro ( by exact prop_out_nbr; );                                      /- := OUT.END.NUMBER > 0 -/
                                   apply And.intro ( by apply Exists.intro past;                                    /- := check_numbers (past::pasts) ∧ OUT.END.PAST = (past::pasts) -/
                                                        apply Exists.intro pasts;
                                                        simp only [prop_pasts];
                                                        trivial; );
                                   apply And.intro ( by exact List.Mem.head RULE.CENTER.PAST; );                    /- := OUT.COLOUR ∈ (RULE.CENTER.NUMBER::RULE.CENTER.PAST) -/
                                   /- Match-Verification Loop: -/
                                   apply Exists.intro (colour::colours);                                                    /- colours (Path Notation) -/
                                   apply Exists.intro (node inc_nbr (RULE.CENTER.LEVEL+1) antecedent minor_hpt false []);   /- inc (Incoming Node) -/
                                   apply Exists.intro (node anc_nbr anc_lvl anc_fml false false []);                        /- anc (Ancestral Node) -/
                                   exact ( by repeat ( first | exact List.Mem.head _ | apply List.Mem.tail ); );            /- := path anc inc (0::OUT.COLOUR::colours) ∈ INDIRECT -/
                       | tail _ out_cases => trivial; );
  /- Check Direct Paths -/----------------------------------------------------------------------------------------------------------------------------
  apply And.intro ( by intro dir dir_cases; trivial; );
  /- Check Indirect Paths -/--------------------------------------------------------------------------------------------------------------------------
  intro ind ind_cases;
  simp only [type_indirect, type_indirect.check, and_assoc];
  cases ind_cases with
  | head _ => simp only [Vertex.node.injEq, true_and];
              apply And.intro ( by exact prop_anc_nbr; );                                         /- := IND.START.NUMBER > 0 -/
              apply And.intro ( by rewrite [←prop_anc_lvl];                                       /- := IND.START.LEVEL ≤ RULE.CENTER.LEVEL - 1 -/
                                   simp only [List.length];
                                   exact Nat.le_add_right anc_lvl (List.length colours + 1); );
              apply And.intro ( by exact Nat.zero_lt_succ inc_nbr; );                             /- := IND.END.NUMBER > 0 -/
              apply And.intro ( by rewrite [←prop_anc_lvl];                                       /- := IND.START.LEVEL + List.length (IND.COLOURS) = RULE.CENTER.LEVEL + 1 -/
                                   simp only [List.length];
                                   trivial; );
              apply Exists.intro RULE.CENTER.NUMBER;                                              /- colour (Path Notation) -/
              apply Exists.intro (colour::colours);                                               /- colours (Path Notation) -/
              apply And.intro ( by exact COLLAPSE.Check_Numbers_Cons prop_nbr prop_colours; );    /- := check_numbers (colour::colours) -/
              apply And.intro ( by exact List.Mem.head RULE.CENTER.PAST; );                       /- := colour ∈ (RULE.CENTER.NUMBER::RULE.CENTER.PAST) -/
              apply And.intro ( by trivial; );                                                    /- := IND.COLOURS = (0::colour::colours) -/
              /- Match-Verification Loop: -/
              exact And.intro ( by apply Exists.intro #major_dep;                                                              /- dep_inc (Incoming Dependency) -/
                                   apply And.intro ( by repeat ( first | exact List.Mem.head _ | apply List.Mem.tail ); );    /- := edge IND.END RULE.CENTER 0 dep_inc ∈ RULE.INCOMING -/
                                   intro inc inc_cases;                                                                       /- := ( INC.START = IND.END ) ↔ ( INC = edge IND.END RULE.CENTER 0 dep_inc ) -/
                                   apply DEFINE.Def_Check_Path_Incoming inc_cases;
                                   simp only [DEFINE.check_path_incoming];
                                   /- Resolve Missmatch: -/
                                   simp only [Deduction.edge.injEq, true_and, and_true];
                                   simp only [Vertex.node.injEq, true_and, and_true];
                                   simp only [iff_self_and, and_imp];
                                   have succ_ne_self := Nat.succ_ne_self inc_nbr;
                                   simp only [ne_eq, eq_comm] at succ_ne_self;
                                   intro succ_eq_self;
                                   trivial; )
                              ( by apply Exists.intro (node out_nbr (RULE.CENTER.LEVEL-1) out_fml out_hpt true (past::pasts));  /- out (Outgoing Node) -/
                                   apply Exists.intro (minor_dep ∪ major_dep);                                                  /- dep_out (Outgoing Dependency) -/
                                   apply And.intro ( by simp only [Vertex.node.injEq];                                          /- := ( colours = [] ) ↔ ( out = IND.START ) -/
                                                        simp only [false_iff, not_and];
                                                        intro _ prop_ctr_lvl;
                                                        rewrite [←prop_anc_lvl] at prop_ctr_lvl;
                                                        simp only [List.length] at prop_ctr_lvl;
                                                        simp only [Nat.add_sub_assoc (Nat.le_add_left 1 (List.length colours+1))] at prop_ctr_lvl;
                                                        simp only [Nat.add_sub_cancel] at prop_ctr_lvl;
                                                        have lt_self := Nat.add_lt_add_left (Nat.zero_lt_succ (List.length colours)) anc_lvl;
                                                        simp only [prop_ctr_lvl, Nat.add_zero, Nat.lt_irrefl] at lt_self; );
                                   apply And.intro ( by repeat ( first | exact List.Mem.head _ | apply List.Mem.tail ); );      /- := edge RULE.CENTER out colour dep_out ∈ RULE.OUTGOING -/
                                   intro out out_cases;                                                                         /- := ( OUT.COLOUR = colour ) ↔ ( OUT = edge RULE.CENTER out colour dep_out ) -/
                                   apply DEFINE.Def_Check_Path_Outgoing out_cases;
                                   simp only [DEFINE.check_path_outgoing];
                                   /- Perfect Match! -/
                                   trivial; );
  | tail _ ind_cases => cases ind_cases with
                        | head _ => simp only [Vertex.node.injEq, true_and];
                                    apply And.intro ( by exact prop_anc_nbr; );                                         /- := IND.START.NUMBER > 0 -/
                                    apply And.intro ( by rewrite [←prop_anc_lvl];                                       /- := IND.START.LEVEL ≤ RULE.CENTER.LEVEL - 1 -/
                                                         simp only [List.length];
                                                         exact Nat.le_add_right anc_lvl (List.length colours + 1); );
                                    apply And.intro ( by exact prop_inc_nbr; );                                         /- := IND.END.NUMBER > 0 -/
                                    apply And.intro ( by rewrite [←prop_anc_lvl];                                       /- := IND.START.LEVEL + List.length (IND.COLOURS) = RULE.CENTER.LEVEL + 1 -/
                                                         simp only [List.length];
                                                         trivial; );
                                    apply Exists.intro RULE.CENTER.NUMBER;                                              /- colour (Path Notation) -/
                                    apply Exists.intro (colour::colours);                                               /- colours (Path Notation) -/
                                    apply And.intro ( by exact COLLAPSE.Check_Numbers_Cons prop_nbr prop_colours; );    /- := check_numbers (colour::colours) -/
                                    apply And.intro ( by exact List.Mem.head RULE.CENTER.PAST; );                       /- := colour ∈ (RULE.CENTER.NUMBER::RULE.CENTER.PAST) -/
                                    apply And.intro ( by trivial; );                                                    /- := IND.COLOURS = (0::colour::colours) -/
                                    /- Match-Verification Loop: -/
                                    exact And.intro ( by apply Exists.intro #minor_dep;                                                              /- dep_inc (Incoming Dependency) -/
                                                         apply And.intro ( by repeat ( first | exact List.Mem.head _ | apply List.Mem.tail ); );    /- := edge IND.END RULE.CENTER 0 dep_inc ∈ RULE.INCOMING -/
                                                         intro inc inc_cases;                                                                       /- := ( INC.START = IND.END ) ↔ ( INC = edge IND.END RULE.CENTER 0 dep_inc ) -/
                                                         apply DEFINE.Def_Check_Path_Incoming inc_cases;
                                                         simp only [DEFINE.check_path_incoming];
                                                         /- Resolve Missmatch: -/
                                                         simp only [Deduction.edge.injEq, true_and, and_true];
                                                         simp only [Vertex.node.injEq, true_and, and_true];
                                                         simp only [iff_self_and, and_imp];
                                                         have succ_ne_self := Nat.succ_ne_self inc_nbr;
                                                         simp only [ne_eq] at succ_ne_self;
                                                         intro succ_eq_self;
                                                         trivial; )
                                                    ( by apply Exists.intro (node out_nbr (RULE.CENTER.LEVEL-1) out_fml out_hpt true (past::pasts));  /- out (Outgoing Node) -/
                                                         apply Exists.intro (minor_dep ∪ major_dep);                                                  /- dep_out (Outgoing Dependency) -/
                                                         apply And.intro ( by simp only [Vertex.node.injEq];                                          /- := ( colours = [] ) ↔ ( out = IND.START ) -/
                                                                              simp only [false_iff, not_and];
                                                                              intro _ prop_ctr_lvl;
                                                                              rewrite [←prop_anc_lvl] at prop_ctr_lvl;
                                                                              simp only [List.length] at prop_ctr_lvl;
                                                                              simp only [Nat.add_sub_assoc (Nat.le_add_left 1 (List.length colours+1))] at prop_ctr_lvl;
                                                                              simp only [Nat.add_sub_cancel] at prop_ctr_lvl;
                                                                              have lt_self := Nat.add_lt_add_left (Nat.zero_lt_succ (List.length colours)) anc_lvl;
                                                                              simp only [prop_ctr_lvl, Nat.add_zero, Nat.lt_irrefl] at lt_self; );
                                                         apply And.intro ( by repeat ( first | exact List.Mem.head _ | apply List.Mem.tail ); );      /- := edge RULE.CENTER out colour dep_out ∈ RULE.OUTGOING -/
                                                         intro out out_cases;                                                                         /- := ( OUT.COLOUR = colour ) ↔ ( OUT = edge RULE.CENTER out colour dep_out ) -/
                                                         apply DEFINE.Def_Check_Path_Outgoing out_cases;
                                                         /- Perfect Match! -/
                                                         simp only [DEFINE.check_path_outgoing];
                                                         trivial; );
                        | tail _ ind_cases => trivial;
  -----------------------------------------------------------------------------------------------------------------------------------------

  /- Pre-Collapse: Type2 ⊇-Introduction -/
  theorem PreCol_Of_PreCollapse_Intro {RULE : Neighborhood} :
    ( type2_introduction RULE ) →
    ---------------------------
    ( type3_pre_collapse (pre_collapse RULE) ) := by
  intro prop_type;
  simp only [type2_introduction] at prop_type;
  cases prop_type with | intro prop_nbr prop_type =>
  cases prop_type with | intro prop_lvl prop_type =>
  cases prop_type with | intro prop_hpt prop_type =>
  cases prop_type with | intro prop_col prop_type =>
  cases prop_type with | intro prop_pst prop_type =>
  cases prop_type with | intro inc_nbr prop_type =>
  cases prop_type with | intro out_nbr prop_type =>
  cases prop_type with | intro anc_nbr prop_type =>
  cases prop_type with | intro anc_lvl prop_type =>
  cases prop_type with | intro antecedent prop_type =>
  cases prop_type with | intro consequent prop_type =>
  cases prop_type with | intro out_fml prop_type =>
  cases prop_type with | intro anc_fml prop_type =>
  cases prop_type with | intro out_hpt prop_type =>
  cases prop_type with | intro inc_dep prop_type =>
  cases prop_type with | intro past prop_type =>
  cases prop_type with | intro colour prop_type =>
  cases prop_type with | intro pasts prop_type =>
  cases prop_type with | intro colours prop_type =>
  cases prop_type with | intro prop_fml prop_type =>
  cases prop_type with | intro prop_inc_nbr prop_type =>
  cases prop_type with | intro prop_out_nbr prop_type =>
  cases prop_type with | intro prop_anc_nbr prop_type =>
  cases prop_type with | intro prop_anc_lvl prop_type =>
  cases prop_type with | intro prop_colour prop_type =>
  cases prop_type with | intro prop_pasts prop_type =>
  cases prop_type with | intro prop_colours prop_type =>
  cases prop_type with | intro prop_incoming prop_type =>
  cases prop_type with | intro prop_outgoing prop_type =>
  cases prop_type with | intro prop_direct prop_indirect =>
  /- Unfold Goal: -/
  simp only [pre_collapse];
  simp only [prop_hpt, prop_col];
  simp only [prop_incoming, prop_outgoing, prop_direct];
  simp only [pre_collapse.outgoing];
  simp only [pre_collapse.direct];
  simp only [pre_collapse.indirect];
  simp only [pre_collapse.indirect.move_up];
  simp only [type3_pre_collapse];
  /- Check Center -/
  apply And.intro ( by exact prop_nbr; );                   /- := RULE.CENTER.NUMBER > 0 -/
  apply And.intro ( by exact prop_lvl; );                   /- := RULE.CENTER.LEVEL > 0 -/
  apply And.intro ( by exact prop_col; );                   /- := RULE.CENTER.COLLAPSED = false -/
  apply And.intro ( by exact prop_pst; );                   /- := RULE.CENTER.PAST = [] -/
  /- Check Deduction Edges -/
  apply And.intro ( by rewrite [prop_hpt]; trivial; );          /- := ( RULE.INCOMING = [] ) ↔ ( RULE.CENTER.HYPOTHESIS = true ) -/
  apply And.intro ( by simp only [List.length]; trivial; );     /- := List.length (RULE.INCOMING) ≤ 2 -/
  apply And.intro ( by simp only [List.cons.injEq];             /- := RULE.OUTGOING = [out] -/
                       simp only [exists_and_right];
                       simp only [exists_eq'];
                       trivial; );
  apply And.intro ( by intro out₁ out₂ out_mem₁ out_mem₂;               /- := OUT₁.COLOUR = OUT₂.COLOUR ↔ OUT₁ = OUT₂ -/
                       simp only [List.Eq_Iff_Mem_Unit] at out_mem₁ out_mem₂;
                       simp only [out_mem₁, out_mem₂];
                       intros; trivial; );
  /- Check Ancestral Paths -/
  apply And.intro ( by rewrite [prop_hpt]; trivial; );                  /- := ( RULE.CENTER.HYPOTHESIS = false ) → ( RULE.DIRECT = [] ) -/
  apply And.intro ( by rewrite [prop_hpt]; trivial; );                  /- := ( RULE.DIRECT ≠ [] ) → ( RULE.CENTER.HYPOTHESIS = true ) -/
  apply And.intro ( by exact Or.inl trivial; );                         /- := ( RULE.DIRECT ≠ [] ) ∨ ( RULE.DIRECT = [dir] ) -/
  apply And.intro ( by intro ind₁ ind₂ ind_mem₁ ind_mem₂;               /- := ( ind₁.COLOURS = ind₂.COLOURS ) ↔ ( ind₁.START = ind₂.START ) -/
                       apply DEFINE.Def_Check_Path_Starts ind_mem₁ ind_mem₂;
                       simp only [DEFINE.check_path_starts];
                       simp only [DEFINE.check_path_starts.loop];
                       trivial; );
  apply And.intro ( by simp only [List.length]; );                      /- := List.length (RULE.INDIRECT) = List.length (RULE.INCOMING) -/
  /- Check Incoming Edges -/--------------------------------------------------------------------------------------------------------------------------
  apply And.intro ( by intro inc inc_cases;
                       simp only [type_incoming, type_incoming.check, and_assoc];
                       cases inc_cases with
                       | head _ => simp only [Vertex.node.injEq, true_and, and_true];
                                   apply And.intro ( by exact prop_inc_nbr; );                                              /- := INC.START.NUMBER > 0 -/
                                   /- Match-Verification Loop: -/
                                   apply Exists.intro RULE.CENTER.NUMBER;                                                   /- colour (Path Notation) -/
                                   apply Exists.intro (colour::colours);                                                    /- colours (Path Notation) -/
                                   apply Exists.intro (node anc_nbr anc_lvl anc_fml false false []);                        /- anc (Ancestral Node) -/
                                   exact ( by repeat ( first | exact List.Mem.head _ | apply List.Mem.tail ); );            /- := path anc INC.START (0::colour::colours) ∈ INDIRECT -/
                       | tail _ inc_cases => trivial; );
  /- Check Outgoing Edges -/--------------------------------------------------------------------------------------------------------------------------
  apply And.intro ( by intro out out_cases;
                       simp only [type_outgoing₃];
                       apply Or.inr; apply Or.inr; simp only [type_outgoing₃.check_ie₃, and_assoc];                 /- := Type 2 Introduction -/
                       cases out_cases with
                       | head _ => simp only [Vertex.node.injEq, true_and];
                                   apply And.intro ( by exact Or.inl prop_hpt; );                                   /- := CENTER.HYPOTHESIS = false ∨ CENTER.COLLAPSED = true -/
                                   apply And.intro ( by exact prop_out_nbr; );                                      /- := OUT.END.NUMBER > 0 -/
                                   apply And.intro ( by apply Exists.intro past;                                    /- := check_numbers (past::pasts) ∧ OUT.END.PAST = (past::pasts) -/
                                                        apply Exists.intro pasts;
                                                        simp only [prop_pasts];
                                                        trivial; );
                                   apply And.intro ( by exact List.Mem.head RULE.CENTER.PAST; );                    /- := OUT.COLOUR ∈ (RULE.CENTER.NUMBER::RULE.CENTER.PAST) -/
                                   /- Match-Verification Loop: -/
                                   apply Exists.intro (colour::colours);                                                    /- colours (Path Notation) -/
                                   apply Exists.intro (node inc_nbr (RULE.CENTER.LEVEL+1) consequent false false []);       /- inc (Incoming Node) -/
                                   apply Exists.intro (node anc_nbr anc_lvl anc_fml false false []);                        /- anc (Ancestral Node) -/
                                   exact ( by repeat ( first | exact List.Mem.head _ | apply List.Mem.tail ); );            /- := path anc inc (0::OUT.COLOUR::colours) ∈ INDIRECT -/
                       | tail _ out_cases => trivial; );
  /- Check Direct Paths -/----------------------------------------------------------------------------------------------------------------------------
  apply And.intro ( by intro dir dir_cases; trivial; );
  /- Check Indirect Paths -/--------------------------------------------------------------------------------------------------------------------------
  intro ind ind_cases;
  simp only [type_indirect, type_indirect.check, and_assoc];
  cases ind_cases with
  | head _ => simp only [Vertex.node.injEq, true_and];
              apply And.intro ( by exact prop_anc_nbr; );                                         /- := IND.START.NUMBER > 0 -/
              apply And.intro ( by rewrite [←prop_anc_lvl];                                       /- := IND.START.LEVEL ≤ RULE.CENTER.LEVEL - 1 -/
                                   simp only [List.length];
                                   exact Nat.le_add_right anc_lvl (List.length colours + 1); );
              apply And.intro ( by exact prop_inc_nbr; );                                         /- := IND.END.NUMBER > 0 -/
              apply And.intro ( by rewrite [←prop_anc_lvl];                                       /- := IND.START.LEVEL + List.length (IND.COLOURS) = RULE.CENTER.LEVEL + 1 -/
                                   simp only [List.length];
                                   trivial; );
              apply Exists.intro RULE.CENTER.NUMBER;                                              /- colour (Path Notation) -/
              apply Exists.intro (colour::colours);                                               /- colours (Path Notation) -/
              apply And.intro ( by exact COLLAPSE.Check_Numbers_Cons prop_nbr prop_colours; );    /- := check_numbers (colour::colours) -/
              apply And.intro ( by exact List.Mem.head RULE.CENTER.PAST; );                       /- := colour ∈ (RULE.CENTER.NUMBER::RULE.CENTER.PAST) -/
              apply And.intro ( by trivial; );                                                    /- := IND.COLOURS = (0::colour::colours) -/
              /- Match-Verification Loop: -/
              exact And.intro ( by apply Exists.intro #inc_dep;                                                               /- dep_inc (Incoming Dependency) -/
                                   apply And.intro ( by repeat ( first | exact List.Mem.head _ | apply List.Mem.tail ); );    /- := edge IND.END RULE.CENTER 0 dep_inc ∈ RULE.INCOMING -/
                                   intro inc inc_cases;                                                                       /- := ( INC.START = IND.END ) ↔ ( INC = edge IND.END RULE.CENTER 0 dep_inc ) -/
                                   apply DEFINE.Def_Check_Path_Incoming inc_cases;
                                   simp only [DEFINE.check_path_incoming];
                                   /- Perfect Match! -/
                                   trivial; )
                              ( by apply Exists.intro (node out_nbr (RULE.CENTER.LEVEL-1) out_fml out_hpt true (past::pasts));  /- out (Outgoing Node) -/
                                   apply Exists.intro (inc_dep − [antecedent]);                                                 /- dep_out (Outgoing Dependency) -/
                                   apply And.intro ( by simp only [Vertex.node.injEq];                                          /- := ( colours = [] ) ↔ ( out = IND.START ) -/
                                                        simp only [false_iff, not_and];
                                                        intro _ prop_ctr_lvl;
                                                        rewrite [←prop_anc_lvl] at prop_ctr_lvl;
                                                        simp only [List.length] at prop_ctr_lvl;
                                                        simp only [Nat.add_sub_assoc (Nat.le_add_left 1 (List.length colours+1))] at prop_ctr_lvl;
                                                        simp only [Nat.add_sub_cancel] at prop_ctr_lvl;
                                                        have lt_self := Nat.add_lt_add_left (Nat.zero_lt_succ (List.length colours)) anc_lvl;
                                                        simp only [prop_ctr_lvl, Nat.add_zero, Nat.lt_irrefl] at lt_self; );
                                   apply And.intro ( by repeat ( first | exact List.Mem.head _ | apply List.Mem.tail ); );      /- := edge RULE.CENTER out colour dep_out ∈ RULE.OUTGOING -/
                                   intro out out_cases;                                                                         /- := ( OUT.COLOUR = colour ) ↔ ( OUT = edge RULE.CENTER out colour dep_out ) -/
                                   apply DEFINE.Def_Check_Path_Outgoing out_cases;
                                   simp only [DEFINE.check_path_outgoing];
                                   /- Perfect Match! -/
                                   trivial; );
  | tail _ ind_cases => trivial;
  -----------------------------------------------------------------------------------------------------------------------------------------

  /- Pre-Collapse: Type2 Hypothesis (Top Formula) -/
  theorem PreCol_Of_PreCollapse_Top {RULE : Neighborhood} :
    ( type2_hypothesis RULE ) →
    ---------------------------
    ( type3_pre_collapse (pre_collapse RULE) ) := by
  intro prop_type;
  simp only [type2_hypothesis] at prop_type;
  cases prop_type with | intro prop_nbr prop_type =>
  cases prop_type with | intro prop_lvl prop_type =>
  cases prop_type with | intro prop_hpt prop_type =>
  cases prop_type with | intro prop_col prop_type =>
  cases prop_type with | intro prop_pst prop_type =>
  cases prop_type with | intro out_nbr prop_type =>
  cases prop_type with | intro anc_nbr prop_type =>
  cases prop_type with | intro anc_lvl prop_type =>
  cases prop_type with | intro out_fml prop_type =>
  cases prop_type with | intro anc_fml prop_type =>
  cases prop_type with | intro out_hpt prop_type =>
  cases prop_type with | intro past prop_type =>
  cases prop_type with | intro colour prop_type =>
  cases prop_type with | intro pasts prop_type =>
  cases prop_type with | intro colours prop_type =>
  cases prop_type with | intro prop_out_nbr prop_type =>
  cases prop_type with | intro prop_anc_nbr prop_type =>
  cases prop_type with | intro prop_anc_lvl prop_type =>
  cases prop_type with | intro prop_colour prop_type =>
  cases prop_type with | intro prop_pasts prop_type =>
  cases prop_type with | intro prop_colours prop_type =>
  cases prop_type with | intro prop_incoming prop_type =>
  cases prop_type with | intro prop_outgoing prop_type =>
  cases prop_type with | intro prop_direct prop_indirect =>
  /- Unfold Goal: -/
  simp only [pre_collapse];
  simp only [prop_hpt, prop_col];
  simp only [prop_incoming, prop_outgoing, prop_direct];
  simp only [pre_collapse.outgoing];
  simp only [pre_collapse.direct];
  simp only [pre_collapse.direct.paint];
  simp only [pre_collapse.indirect];
  simp only [type3_pre_collapse];
  /- Check Center -/
  apply And.intro ( by exact prop_nbr; );                   /- := RULE.CENTER.NUMBER > 0 -/
  apply And.intro ( by exact prop_lvl; );                   /- := RULE.CENTER.LEVEL > 0 -/
  apply And.intro ( by exact prop_col; );                   /- := RULE.CENTER.COLLAPSED = false -/
  apply And.intro ( by exact prop_pst; );                   /- := RULE.CENTER.PAST = [] -/
  /- Check Deduction Edges -/
  apply And.intro ( by rewrite [prop_hpt]; trivial; );          /- := ( RULE.INCOMING = [] ) ↔ ( RULE.CENTER.HYPOTHESIS = true ) -/
  apply And.intro ( by simp only [List.length]; trivial; );     /- := List.length (RULE.INCOMING) ≤ 2 -/
  apply And.intro ( by simp only [List.cons.injEq];             /- := RULE.OUTGOING = [out] -/
                       simp only [exists_and_right];
                       simp only [exists_eq'];
                       trivial; );
  apply And.intro ( by intro out₁ out₂ out_mem₁ out_mem₂;               /- := OUT₁.COLOUR = OUT₂.COLOUR ↔ OUT₁ = OUT₂ -/
                       simp only [List.Eq_Iff_Mem_Unit] at out_mem₁ out_mem₂;
                       simp only [out_mem₁, out_mem₂];
                       intros; trivial; );
  /- Check Ancestral Paths -/
  apply And.intro ( by rewrite [prop_hpt]; trivial; );                  /- := ( RULE.CENTER.HYPOTHESIS = false ) → ( RULE.DIRECT = [] ) -/
  apply And.intro ( by rewrite [prop_hpt, ne_eq];                       /- := ( RULE.DIRECT ≠ [] ) → ( RULE.CENTER.HYPOTHESIS = true ) -/
                       simp only [List.cons.injEq];
                       trivial; );
  apply And.intro ( by simp only [List.cons.injEq];                     /- := ( RULE.DIRECT ≠ [] ) ∨ ( RULE.DIRECT = [dir] ) -/
                       simp only [exists_and_right];
                       simp only [exists_eq'];
                       trivial; );
  apply And.intro ( by intro ind₁ ind₂ ind_mem₁ ind_mem₂;               /- := ( ind₁.COLOURS = ind₂.COLOURS ) ↔ ( ind₁.START = ind₂.START ) -/
                       apply DEFINE.Def_Check_Path_Starts ind_mem₁ ind_mem₂;
                       simp only [DEFINE.check_path_starts]; );
  apply And.intro ( by simp only [List.length]; );                      /- := List.length (RULE.INDIRECT) = List.length (RULE.INCOMING) -/
  /- Check Incoming Edges -/--------------------------------------------------------------------------------------------------------------------------
  apply And.intro ( by intro inc inc_cases; trivial; );
  /- Check Outgoing Edges -/--------------------------------------------------------------------------------------------------------------------------
  apply And.intro ( by intro out out_cases;
                       simp only [type_outgoing₃];
                       apply Or.inr; apply Or.inl; simp only [type_outgoing₃.check_h₃, and_assoc];                  /- := Type 2 hypothesis -/
                       cases out_cases with
                       | head _ => simp only [Vertex.node.injEq, true_and];
                                   apply And.intro ( by exact prop_hpt; );                                          /- := CENTER.HYPOTHESIS = true -/
                                   apply And.intro ( by exact prop_out_nbr; );                                      /- := OUT.END.NUMBER > 0 -/
                                   apply And.intro ( by apply Exists.intro past;                                    /- := check_numbers (past::pasts) ∧ OUT.END.PAST = (past::pasts) -/
                                                        apply Exists.intro pasts;
                                                        simp only [prop_pasts];
                                                        trivial; );
                                   apply And.intro ( by exact List.Mem.head RULE.CENTER.PAST; );                    /- := OUT.COLOUR ∈ (RULE.CENTER.NUMBER::RULE.CENTER.PAST) -/
                                   /- Match-Verification Loop: -/
                                   apply Exists.intro (colour::colours);                                                    /- colours (Path Notation) -/
                                   apply Exists.intro (node anc_nbr anc_lvl anc_fml false false []);                        /- anc (Ancestral Node) -/
                                   exact ( by repeat ( first | exact List.Mem.head _ | apply List.Mem.tail ); );            /- := path anc CENTER (OUT.COLOUR::colours) ∈ DIRECT -/
                       | tail _ out_cases => trivial; );
  /- Check Direct Paths -/----------------------------------------------------------------------------------------------------------------------------
  apply And.intro ( by intro dir dir_cases;
                       simp only [type_direct, type_direct.check, and_assoc];
                       cases dir_cases with
                       | head _ => simp only [Vertex.node.injEq, true_and];
                                   apply And.intro ( by exact prop_anc_nbr; );                                         /- := DIR.START.NUMBER > 0 -/
                                   apply And.intro ( by rewrite [←prop_anc_lvl];                                       /- := DIR.START.LEVEL ≤ RULE.CENTER.LEVEL - 1 -/
                                                        simp only [List.length];
                                                        exact Nat.le_add_right anc_lvl (List.length colours + 1); );
                                   apply And.intro ( by rewrite [←prop_anc_lvl];                                       /- := DIR.START.LEVEL + List.length (DIR.COLOURS) = RULE.CENTER.LEVEL + 1 -/
                                                        simp only [List.length]; );
                                   apply Exists.intro RULE.CENTER.NUMBER;                                              /- colour₁ (Path Notation) -/
                                   apply Exists.intro colour;                                                          /- colour₂ (Path Notation) -/
                                   apply Exists.intro colours;                                                         /- colours (Path Notation) -/
                                   apply And.intro ( by exact COLLAPSE.Check_Numbers_Cons prop_nbr prop_colours; );    /- := check_numbers (colour::colours) -/
                                   apply And.intro ( by exact List.Mem.head RULE.CENTER.PAST; );                       /- := colour ∈ (RULE.CENTER.NUMBER::RULE.CENTER.PAST) -/
                                   apply And.intro ( by trivial; );                                                    /- := DIR.COLOURS = (0::colour::colours) -/
                                   /- Match-Verification Loop: -/
                                   apply Exists.intro (node out_nbr (RULE.CENTER.LEVEL-1) out_fml out_hpt true (past::pasts));  /- out (Outgoing Node) -/
                                   apply Exists.intro ([RULE.CENTER.FORMULA]);                                                  /- dep_out (Outgoing Dependency) -/
                                   apply And.intro ( by trivial; );                                                             /- := out.COLLAPSED = true -/
                                   apply And.intro ( by exact prop_colour; );                                                   /- := colour₂ ∈ (out.NUMBER::out.PAST) -/
                                   apply And.intro ( by repeat ( first | exact List.Mem.head _ | apply List.Mem.tail ); );      /- := edge RULE.CENTER out colour dep_out ∈ RULE.OUTGOING -/
                                   intro out out_cases;                                                                         /- := ( OUT.COLOUR = colour ) ↔ ( OUT = edge RULE.CENTER out colour dep_out ) -/
                                   apply DEFINE.Def_Check_Path_Outgoing out_cases;
                                   simp only [DEFINE.check_path_outgoing];
                                   /- Perfect Match! -/
                                   trivial;
                       | tail _ ind_cases => trivial; );
  /- Check Indirect Paths -/--------------------------------------------------------------------------------------------------------------------------
  intro ind ind_cases; trivial;
  -----------------------------------------------------------------------------------------------------------------------------------------
end COVERAGE.T3_Of_T2


namespace COVERAGE.T1_Of_T1.NODES
  --333 set_option trace.Meta.Tactic.simp true
  /- Lemma: Collapse Execution (Type 0 & Type 0 => Type 1) (Nodes) -/
  theorem Col_Of_Collapse_Pre_Pre {RULEᵤ RULEᵥ : Neighborhood} :
    ( check_collapse_nodes RULEᵤ RULEᵥ ) →
    ( type1_pre_collapse RULEᵤ ) →
    ( type1_pre_collapse RULEᵥ ) →
    ---------------------------
    ( type1_collapse (collapse RULEᵤ RULEᵥ) ) := by
  intro prop_check_collapse prop_typeᵤ prop_typeᵥ;
  --
  simp only [check_collapse_nodes] at prop_check_collapse;
  cases prop_check_collapse with | intro prop_lt_nbr prop_check_collapse =>
  cases prop_check_collapse with | intro prop_ne_pst prop_check_collapse =>
  cases prop_check_collapse with | intro prop_eq_lvl prop_check_collapse =>
  cases prop_check_collapse with | intro prop_eq_fml prop_check_incoming =>
  --
  simp only [type1_pre_collapse] at prop_typeᵤ;
  cases prop_typeᵤ with | intro prop_nbrᵤ prop_typeᵤ =>
  cases prop_typeᵤ with | intro prop_lvlᵤ prop_typeᵤ =>
  cases prop_typeᵤ with | intro prop_colᵤ prop_typeᵤ =>
  cases prop_typeᵤ with | intro prop_pstᵤ prop_typeᵤ =>
  cases prop_typeᵤ with | intro prop_inc_nilᵤ prop_typeᵤ =>
  cases prop_typeᵤ with | intro prop_inc_lenᵤ prop_typeᵤ =>
  cases prop_typeᵤ with | intro prop_out_unitᵤ prop_typeᵤ =>
  cases prop_typeᵤ with | intro prop_out_coloursᵤ prop_typeᵤ =>
  cases prop_typeᵤ with | intro prop_dir_nilᵤ prop_typeᵤ =>
  cases prop_typeᵤ with | intro prop_ind_startsᵤ prop_typeᵤ =>
  cases prop_typeᵤ with | intro prop_ind_lenᵤ prop_typeᵤ =>
  cases prop_typeᵤ with | intro prop_ind_coloursᵤ prop_typeᵤ =>
  cases prop_typeᵤ with | intro prop_incomingᵤ prop_typeᵤ =>
  cases prop_typeᵤ with | intro prop_outgoingᵤ prop_indirectᵤ =>
  --
  cases prop_out_unitᵤ with | intro outᵤ prop_out_unitᵤ =>
  --
  simp only [type1_pre_collapse] at prop_typeᵥ;
  cases prop_typeᵥ with | intro prop_nbrᵥ prop_typeᵥ =>
  cases prop_typeᵥ with | intro prop_lvlᵥ prop_typeᵥ =>
  cases prop_typeᵥ with | intro prop_colᵥ prop_typeᵥ =>
  cases prop_typeᵥ with | intro prop_pstᵥ prop_typeᵥ =>
  cases prop_typeᵥ with | intro prop_inc_nilᵥ prop_typeᵥ =>
  cases prop_typeᵥ with | intro prop_inc_lenᵥ prop_typeᵥ =>
  cases prop_typeᵥ with | intro prop_out_unitᵥ prop_typeᵥ =>
  cases prop_typeᵥ with | intro prop_out_coloursᵥ prop_typeᵥ =>
  cases prop_typeᵥ with | intro prop_dir_nilᵥ prop_typeᵥ =>
  cases prop_typeᵥ with | intro prop_ind_startsᵥ prop_typeᵥ =>
  cases prop_typeᵥ with | intro prop_ind_lenᵥ prop_typeᵥ =>
  cases prop_typeᵥ with | intro prop_ind_coloursᵥ prop_typeᵥ =>
  cases prop_typeᵥ with | intro prop_incomingᵥ prop_typeᵥ =>
  cases prop_typeᵥ with | intro prop_outgoingᵥ prop_indirectᵥ =>
  --
  cases prop_out_unitᵥ with | intro outᵥ prop_out_unitᵥ =>
  --
  simp only [collapse];
  simp only [collapse.center];
  simp only [type1_collapse];
  /- Check Center-/
  apply And.intro ( by exact prop_nbrᵤ; );                                        /- := RULE.CENTER.NUMBER > 0 -/
  apply And.intro ( by exact prop_lvlᵤ; );                                        /- := RULE.CENTER.LEVEL > 0 -/
  apply And.intro ( by trivial; );                                                /- := RULE.CENTER.COLLAPSED = true -/
  apply And.intro ( by apply Exists.intro RULEᵥ.CENTER.NUMBER;                    /- := check_numbers (past :: pasts) ∧ RULE.CENTER.PAST = (past::pasts) -/
                       apply Exists.intro RULEᵤ.CENTER.PAST;
                       apply And.intro ( by simp only [prop_pstᵤ];
                                            exact COLLAPSE.Check_Numbers_Unit prop_nbrᵥ; );
                       trivial; );
  /- Check Deduction Edges -/
  apply And.intro ( by intro prop_inc_nil;                                        /- := ( RULE.INCOMING = [] ) → ( RULE.CENTER.HYPOTHESIS = true ) -/
                       simp only [List.append_eq_nil] at prop_inc_nil;
                       simp only [←List.length_eq_zero] at prop_inc_nil prop_inc_nilᵥ;
                       simp only [REWRITE.Eq_Length_RwIncoming] at prop_inc_nil;
                       simp only [prop_inc_nilᵥ] at prop_inc_nil;
                       simp only [Bool.or_eq_true];
                       exact Or.inr (And.left prop_inc_nil); );
  apply And.intro ( by simp only [prop_out_unitᵥ];                                                                    /- := RULE.OUTGOING = (out::outs) -/
                       apply Exists.intro ( edge ( collapse.center RULEᵤ.CENTER RULEᵥ.CENTER )                        /- RULEᵥ.OUTGOING -/
                                                 ( outᵥ.END )
                                                 ( outᵥ.COLOUR )
                                                 ( outᵥ.DEPENDENCY ) );
                       apply Exists.intro ( collapse.rewrite_outgoing ( collapse.center RULEᵤ.CENTER RULEᵥ.CENTER )   /- RULEᵤ.OUTGOING -/
                                                                      ( RULEᵤ.OUTGOING ) );
                       simp only [collapse.rewrite_outgoing];
                       simp only [collapse.center];
                       trivial; );
  apply And.intro ( by intro out₁ out₂ out_mem₁ out_mem₂ gt_zero₁₂;                          /- := OUT₁.COLOUR = OUT₂.COLOUR ↔ OUT₁ = OUT₂ -/
                       rewrite [prop_out_unitᵥ] at out_mem₁ out_mem₂;
                       simp only [collapse.rewrite_outgoing] at out_mem₁ out_mem₂;
                       simp only [List.Mem_Or_Mem_Iff_Mem_Append] at out_mem₁ out_mem₂;
                       simp only [List.Eq_Iff_Mem_Unit] at out_mem₁ out_mem₂;
                       simp only [Deduction.edge.injEq'];
                       --
                       simp only [type_outgoing₁] at prop_outgoingᵤ prop_outgoingᵥ;
                       rewrite [prop_out_unitᵥ] at prop_outgoingᵥ;
                       have Out_Colourᵥ := COLLAPSE.Simp_Out_Colour₁ (prop_outgoingᵥ (List.Mem.head []));
                       simp only [prop_pstᵥ, List.Eq_Iff_Mem_Unit] at Out_Colourᵥ;
                       --
                       cases out_mem₁ with
                       | inl out_mem₁ᵥ => cases out_mem₂ with
                                          | inl out_mem₂ᵥ => rewrite [out_mem₁ᵥ, out_mem₂ᵥ]; simp only [true_and];
                                          | inr out_mem₂ᵤ => rewrite [out_mem₁ᵥ] at gt_zero₁₂ ⊢;                              /- := out₁ = outᵥ -/
                                                             rewrite [REWRITE.Get_Start_RwOutgoing out_mem₂ᵤ];                /- := out₂.START = collapse.center RULEᵤ.CENTER RULEᵥ.CENTER -/
                                                             --
                                                             have Out_Cases₂ᵤ := REWRITE.Mem_Of_Mem_RwOutgoing out_mem₂ᵤ;                 /- := out₂ ∈ RULEᵥ.OUTGOING -/
                                                             cases Out_Cases₂ᵤ with | intro Originalᵤ Out_Mem₂ᵤ =>
                                                             have Out_Colour₂ᵤ := COLLAPSE.Simp_Out_Colour₁ (prop_outgoingᵤ Out_Mem₂ᵤ);   /- := out₂.COLOUR = 0 ∨ out₂.COLOUR ∈ RULEᵥ.CENTER.NUMBER :: RULEᵥ.CENTER.PAST -/
                                                             --
                                                             simp only [true_and] at gt_zero₁₂ Out_Colour₂ᵤ ⊢;
                                                             have NE_Colour : outᵥ.COLOUR ≠ out₂.COLOUR := by rewrite [ne_eq, ←imp_false];
                                                                                                              intro EQ_Colour;
                                                                                                              cases Out_Colourᵥ with
                                                                                                              | inl EQ_Zeroᵥ => apply absurd gt_zero₁₂; rewrite [←EQ_Colour, EQ_Zeroᵥ]; trivial;
                                                                                                              | inr GT_Zeroᵥ => cases Out_Colour₂ᵤ with
                                                                                                                                | inl EQ_Zero₂ᵤ => apply absurd gt_zero₁₂; rewrite [EQ_Colour, EQ_Zero₂ᵤ]; trivial;
                                                                                                                                | inr GT_Zero₂ᵤ => simp only [List.Eq_Or_Mem_Iff_Mem_Cons] at GT_Zero₂ᵤ;
                                                                                                                                                   rewrite [←EQ_Colour, GT_Zeroᵥ] at GT_Zero₂ᵤ;
                                                                                                                                                   apply absurd GT_Zero₂ᵤ;
                                                                                                                                                   simp only [not_or];
                                                                                                                                                   exact And.intro ( by exact Nat.ne_of_lt prop_lt_nbr; )
                                                                                                                                                                   ( by exact prop_ne_pst; );
                                                             simp only [NE_Colour, false_and, and_false];
                       | inr out_mem₁ᵤ => cases out_mem₂ with
                                          | inl out_mem₂ᵥ => rewrite [REWRITE.Get_Start_RwOutgoing out_mem₁ᵤ];                /- := out₁.START = collapse.center RULEᵤ.CENTER RULEᵥ.CENTER -/
                                                             rewrite [out_mem₂ᵥ] at gt_zero₁₂ ⊢;                              /- := out₂ = outᵥ -/
                                                             --
                                                             have Out_Cases₁ᵤ := REWRITE.Mem_Of_Mem_RwOutgoing out_mem₁ᵤ;                 /- := out₁ ∈ RULEᵥ.OUTGOING -/
                                                             cases Out_Cases₁ᵤ with | intro Originalᵤ Out_Mem₁ᵤ =>
                                                             have Out_Colour₁ᵤ := COLLAPSE.Simp_Out_Colour₁ (prop_outgoingᵤ Out_Mem₁ᵤ);   /- := out₁.COLOUR = 0 ∨ out₁.COLOUR ∈ RULEᵥ.CENTER.NUMBER :: RULEᵥ.CENTER.PAST -/
                                                             --
                                                             simp only [true_and] at gt_zero₁₂ Out_Colour₁ᵤ ⊢;
                                                             have NE_Colour : out₁.COLOUR ≠ outᵥ.COLOUR := by rewrite [ne_eq, ←imp_false];
                                                                                                              intro EQ_Colour;
                                                                                                              cases Out_Colourᵥ with
                                                                                                              | inl EQ_Zeroᵥ => apply absurd gt_zero₁₂; rewrite [EQ_Colour, EQ_Zeroᵥ]; trivial;
                                                                                                              | inr GT_Zeroᵥ => cases Out_Colour₁ᵤ with
                                                                                                                                | inl EQ_Zero₁ᵤ => apply absurd gt_zero₁₂; rewrite [←EQ_Colour, EQ_Zero₁ᵤ]; trivial;
                                                                                                                                | inr GT_Zero₁ᵤ => simp only [List.Eq_Or_Mem_Iff_Mem_Cons] at GT_Zero₁ᵤ;
                                                                                                                                                   rewrite [EQ_Colour, GT_Zeroᵥ] at GT_Zero₁ᵤ;
                                                                                                                                                   apply absurd GT_Zero₁ᵤ;
                                                                                                                                                   simp only [not_or];
                                                                                                                                                   exact And.intro ( by exact Nat.ne_of_lt prop_lt_nbr; )
                                                                                                                                                                   ( by exact prop_ne_pst; );
                                                             simp only [NE_Colour, false_and, and_false];
                                          | inr out_mem₂ᵤ => rewrite [REWRITE.Get_Start_RwOutgoing out_mem₁ᵤ];              /- := out₁.START = collapse.center RULEᵤ.CENTER RULEᵥ.CENTER -/
                                                             rewrite [REWRITE.Get_Start_RwOutgoing out_mem₂ᵤ];              /- := out₂.START = collapse.center RULEᵤ.CENTER RULEᵥ.CENTER -/
                                                             simp only [true_and] at gt_zero₁₂ ⊢;
                                                             --
                                                             have Out_Cases₁ᵤ := REWRITE.Mem_Of_Mem_RwOutgoing out_mem₁ᵤ;               /- := out₁ ∈ RULEᵥ.OUTGOING -/
                                                             cases Out_Cases₁ᵤ with | intro Original₁ᵤ Out_Mem₁ᵤ =>
                                                             have Out_Start₁ᵤ := COLLAPSE.Simp_Out_Start₁ (prop_outgoingᵤ Out_Mem₁ᵤ);   /- := out₁.START = RULEᵤ.CENTER -/
                                                             have Out_Cases₂ᵤ := REWRITE.Mem_Of_Mem_RwOutgoing out_mem₂ᵤ;               /- := out₂ ∈ RULEᵥ.OUTGOING -/
                                                             cases Out_Cases₂ᵤ with | intro Original₂ᵤ Out_Mem₂ᵤ =>
                                                             have Out_Start₂ᵤ := COLLAPSE.Simp_Out_Start₁ (prop_outgoingᵤ Out_Mem₂ᵤ);   /- := out₂.START = RULEᵤ.CENTER -/
                                                             --
                                                             have Iff_Out_Colourᵤ := prop_out_coloursᵤ Out_Mem₁ᵤ Out_Mem₂ᵤ gt_zero₁₂;
                                                             simp only [Deduction.edge.injEq] at Out_Start₁ᵤ Out_Start₂ᵤ Iff_Out_Colourᵤ;
                                                             simp only [Out_Start₁ᵤ, Out_Start₂ᵤ, true_and] at Iff_Out_Colourᵤ;
                                                             exact Iff_Out_Colourᵤ; );
  /- Check Ancestral Paths -/
  apply And.intro ( by rewrite [prop_dir_nilᵤ, prop_dir_nilᵥ];        /- := RULE.DIRECT = [] -/
                       simp only [collapse.rewrite_direct];
                       trivial; );
  apply And.intro ( by simp only [List.length_append];                /- := List.length (RULE.INDIRECT) = List.length (RULE.INCOMING) -/
                       simp only [REWRITE.Eq_Length_RwIncoming];
                       simp only [prop_ind_lenᵤ, prop_ind_lenᵥ]; );
  apply And.intro ( by intro ind ind_cases;                           /- := ind.COLOURS = [0, colour] -/
                       simp only [List.Mem_Or_Mem_Iff_Mem_Append] at ind_cases;
                       cases ind_cases with
                       | inl ind_casesᵥ => apply Exists.intro RULEᵥ.CENTER.NUMBER;
                                           exact prop_ind_coloursᵥ ind_casesᵥ;
                       | inr ind_casesᵤ => apply Exists.intro RULEᵤ.CENTER.NUMBER;
                                           exact prop_ind_coloursᵤ ind_casesᵤ; );
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  /- Incoming Edges -/------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  apply And.intro ( by simp only [type_incoming] at prop_incomingᵤ prop_incomingᵥ ⊢;
                       simp only [List.Mem_Or_Mem_Iff_Mem_Append];
                       intro inc inc_cases;
                       cases inc_cases with
                       | inl inc_casesᵥ => have Inc_Caseᵥ := REWRITE.Mem_Of_Mem_RwIncoming inc_casesᵥ;            /- := inc ∈ RULEᵥ.INCOMING -/
                                           cases Inc_Caseᵥ with | intro Originalᵥ Inc_Memᵥ =>
                                           have Prop_Incomingᵥ := prop_incomingᵥ Inc_Memᵥ;                        /- := type_incoming.check inc RULEᵥ.CENTER -/
                                           simp only [type_incoming.check] at Prop_Incomingᵥ ⊢;
                                           cases Prop_Incomingᵥ with | intro Prop_Startᵥ Prop_Incomingᵥ =>
                                           cases Prop_Incomingᵥ with | intro Prop_Endᵥ Prop_Incomingᵥ =>
                                           cases Prop_Incomingᵥ with | intro Prop_Colourᵥ Prop_Inc_Indᵥ =>
                                           --
                                           apply And.intro ( by rewrite [prop_eq_lvl];                            /- := Start Node -/
                                                                exact Prop_Startᵥ; );
                                           apply And.intro ( by exact REWRITE.Get_End_RwIncoming inc_casesᵥ; );   /- := End Node -/
                                           apply And.intro ( by exact Prop_Colourᵥ; );                            /- := Colours -/
                                           /- := Check Incoming-Indirect Duo: -/
                                           cases Prop_Inc_Indᵥ with | intro Colourᵥ Prop_Inc_Indᵥ =>
                                           cases Prop_Inc_Indᵥ with | intro Coloursᵥ Prop_Inc_Indᵥ =>
                                           cases Prop_Inc_Indᵥ with | intro Ancᵥ Prop_Inc_Indᵥ =>
                                           --
                                           apply Exists.intro Colourᵥ;
                                           apply Exists.intro Coloursᵥ;
                                           apply Exists.intro Ancᵥ;
                                           exact ( by simp only [List.Mem_Or_Mem_Iff_Mem_Append];                 /- := path anc INC.START (0::colour::colours) ∈ INDIRECT -/
                                                      apply Or.inl;
                                                      exact Prop_Inc_Indᵥ; );
                       | inr inc_casesᵤ => have Inc_Caseᵤ := REWRITE.Mem_Of_Mem_RwIncoming inc_casesᵤ;            /- := inc ∈ RULEᵤ.INCOMING -/
                                           cases Inc_Caseᵤ with | intro Originalᵤ Inc_Memᵤ =>
                                           have Prop_Incomingᵤ := prop_incomingᵤ Inc_Memᵤ;                        /- := type_incoming.check inc RULEᵤ.CENTER -/
                                           simp only [type_incoming.check] at Prop_Incomingᵤ ⊢;
                                           cases Prop_Incomingᵤ with | intro Prop_Startᵤ Prop_Incomingᵤ =>
                                           cases Prop_Incomingᵤ with | intro Prop_Endᵤ Prop_Incomingᵤ =>
                                           cases Prop_Incomingᵤ with | intro Prop_Colourᵤ Prop_Inc_Indᵤ =>
                                           --
                                           apply And.intro ( by exact Prop_Startᵤ; );                             /- := Start Node -/
                                           apply And.intro ( by exact REWRITE.Get_End_RwIncoming inc_casesᵤ; );   /- := End Node -/
                                           apply And.intro ( by exact Prop_Colourᵤ; );                            /- := Colours -/
                                           /- := Check Incoming-Indirect Duo: -/
                                           cases Prop_Inc_Indᵤ with | intro Colourᵤ Prop_Inc_Indᵤ =>
                                           cases Prop_Inc_Indᵤ with | intro Coloursᵤ Prop_Inc_Indᵤ =>
                                           cases Prop_Inc_Indᵤ with | intro Ancᵤ Prop_Inc_Indᵤ =>
                                           --
                                           apply Exists.intro Colourᵤ;
                                           apply Exists.intro Coloursᵤ;
                                           apply Exists.intro Ancᵤ;
                                           exact ( by simp only [List.Mem_Or_Mem_Iff_Mem_Append];                 /- := path anc INC.START (0::colour::colours) ∈ INDIRECT -/
                                                      apply Or.inr;
                                                      exact Prop_Inc_Indᵤ; ); );
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  /- Outgoing Edges -/------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  apply And.intro ( by simp only [type_outgoing₁] at prop_outgoingᵤ prop_outgoingᵥ ⊢;
                       simp only [List.Mem_Or_Mem_Iff_Mem_Append];
                       intro out out_cases;
                       cases out_cases with
                       | inl out_casesᵥ => have Out_Caseᵥ := REWRITE.Mem_Of_Mem_RwOutgoing out_casesᵥ;          /- := out ∈ RULEᵥ.OUTGOING -/
                                           cases Out_Caseᵥ with | intro Originalᵥ Out_Memᵥ =>
                                           have Prop_Outgoingᵥ := prop_outgoingᵥ Out_Memᵥ;                      /- := type_outgoing.check out RULEᵥ.CENTER -/
                                           cases Prop_Outgoingᵥ with
                                           | inl Prop_Outgoingₕ₁ᵥ => simp only [type_outgoing₁.check_h₁] at Prop_Outgoingₕ₁ᵥ ⊢;
                                                                     cases Prop_Outgoingₕ₁ᵥ with | intro Prop_HPTₕ₁ᵥ Prop_Outgoingₕ₁ᵥ =>
                                                                     cases Prop_Outgoingₕ₁ᵥ with | intro Prop_Startₕ₁ᵥ Prop_Outgoingₕ₁ᵥ =>
                                                                     cases Prop_Outgoingₕ₁ᵥ with | intro Prop_Endₕ₁ᵥ Prop_Colourₕ₁ᵥ =>
                                                                     --
                                                                     apply Or.inl;
                                                                     apply And.intro ( by rewrite [Bool.or_eq_true_iff];                       /- := Type 1 Hypothesis -/
                                                                                          exact Or.inr Prop_HPTₕ₁ᵥ; );
                                                                     apply And.intro ( by exact REWRITE.Get_Start_RwOutgoing out_casesᵥ; );    /- := Start Node -/
                                                                     apply And.intro ( by rewrite [prop_eq_lvl];                               /- := End Node -/
                                                                                          exact Prop_Endₕ₁ᵥ; );
                                                                     exact Prop_Colourₕ₁ᵥ;                                                     /- := Colours -/
                                           | inr Prop_Outgoingᵢₑ₁ᵥ => simp only [type_outgoing₁.check_ie₁] at Prop_Outgoingᵢₑ₁ᵥ ⊢;
                                                                      cases Prop_Outgoingᵢₑ₁ᵥ with | intro Prop_HPTᵢₑ₁ᵥ Prop_Outgoingᵢₑ₁ᵥ =>
                                                                      cases Prop_Outgoingᵢₑ₁ᵥ with | intro Prop_Startᵢₑ₁ᵥ Prop_Outgoingᵢₑ₁ᵥ =>
                                                                      cases Prop_Outgoingᵢₑ₁ᵥ with | intro Prop_Endᵢₑ₁ᵥ Prop_Outgoingᵢₑ₁ᵥ =>
                                                                      cases Prop_Outgoingᵢₑ₁ᵥ with | intro Prop_Colourᵢₑ₁ᵥ Prop_Out_Indᵢₑ₁ᵥ =>
                                                                      --
                                                                      apply Or.inr;
                                                                      apply And.intro ( by exact Or.inr trivial; );                                                 /- := Type 1 Introduction & Elimination -/
                                                                      apply And.intro ( by exact REWRITE.Get_Start_RwOutgoing out_casesᵥ; );                        /- := Start Node -/
                                                                      apply And.intro ( by rewrite [prop_eq_lvl];                                                   /- := End Node -/
                                                                                           exact Prop_Endᵢₑ₁ᵥ; );
                                                                      apply And.intro ( by rewrite [prop_pstᵥ, List.Eq_Iff_Mem_Unit] at Prop_Colourᵢₑ₁ᵥ;            /- := Colours -/
                                                                                           rewrite [Prop_Colourᵢₑ₁ᵥ];
                                                                                           exact List.Mem.tail ( RULEᵤ.CENTER.NUMBER )
                                                                                                               ( List.Mem.head RULEᵤ.CENTER.PAST ) );
                                                                      /- := Check Outgoing-Indirect Duo: -/
                                                                      cases Prop_Out_Indᵢₑ₁ᵥ with | intro Incᵢₑ₁ᵥ Prop_Out_Indᵢₑ₁ᵥ =>
                                                                      --
                                                                      apply Exists.intro Incᵢₑ₁ᵥ;
                                                                      exact ( by simp only [List.Mem_Or_Mem_Iff_Mem_Append];                   /- := path OUT.END inc [0, OUT.COLOUR] ∈ INDIRECT -/
                                                                                  apply Or.inl;
                                                                                  exact Prop_Out_Indᵢₑ₁ᵥ; );
                       | inr out_casesᵤ => have Out_Caseᵤ := REWRITE.Mem_Of_Mem_RwOutgoing out_casesᵤ;          /- := out ∈ RULEᵤ.OUTGOING -/
                                           cases Out_Caseᵤ with | intro Originalᵤ Out_Memᵤ =>
                                           have Prop_Outgoingᵤ := prop_outgoingᵤ Out_Memᵤ;                      /- := type_outgoing.check out RULEᵤ.CENTER -/
                                           cases Prop_Outgoingᵤ with
                                           | inl Prop_Outgoingₕ₁ᵤ => simp only [type_outgoing₁.check_h₁] at Prop_Outgoingₕ₁ᵤ ⊢;
                                                                     cases Prop_Outgoingₕ₁ᵤ with | intro Prop_HPTₕ₁ᵤ Prop_Outgoingₕ₁ᵤ =>
                                                                     cases Prop_Outgoingₕ₁ᵤ with | intro Prop_Startₕ₁ᵤ Prop_Outgoingₕ₁ᵤ =>
                                                                     cases Prop_Outgoingₕ₁ᵤ with | intro Prop_Endₕ₁ᵤ Prop_Colourₕ₁ᵤ =>
                                                                     --
                                                                     apply Or.inl;
                                                                     apply And.intro ( by rewrite [Bool.or_eq_true_iff];                       /- := Type 1 Hypothesis -/
                                                                                          exact Or.inl Prop_HPTₕ₁ᵤ; );
                                                                     apply And.intro ( by exact REWRITE.Get_Start_RwOutgoing out_casesᵤ; );    /- := Start Node -/
                                                                     apply And.intro ( by exact Prop_Endₕ₁ᵤ; );                                /- := End Node -/
                                                                     exact Prop_Colourₕ₁ᵤ;                                                     /- := Colours -/
                                           | inr Prop_Outgoingᵢₑ₁ᵤ => simp only [type_outgoing₁.check_ie₁] at Prop_Outgoingᵢₑ₁ᵤ ⊢;
                                                                      cases Prop_Outgoingᵢₑ₁ᵤ with | intro Prop_HPTᵢₑ₁ᵤ Prop_Outgoingᵢₑ₁ᵤ =>
                                                                      cases Prop_Outgoingᵢₑ₁ᵤ with | intro Prop_Startᵢₑ₁ᵤ Prop_Outgoingᵢₑ₁ᵤ =>
                                                                      cases Prop_Outgoingᵢₑ₁ᵤ with | intro Prop_Endᵢₑ₁ᵤ Prop_Outgoingᵢₑ₁ᵤ =>
                                                                      cases Prop_Outgoingᵢₑ₁ᵤ with | intro Prop_Colourᵢₑ₁ᵤ Prop_Out_Indᵢₑ₁ᵤ =>
                                                                      --
                                                                      apply Or.inr;
                                                                      apply And.intro ( by exact Or.inr trivial; );                                                 /- := Type 1 Introduction & Elimination -/
                                                                      apply And.intro ( by exact REWRITE.Get_Start_RwOutgoing out_casesᵤ; );                        /- := Start Node -/
                                                                      apply And.intro ( by exact Prop_Endᵢₑ₁ᵤ; );                                                   /- := End Node -/
                                                                      apply And.intro ( by rewrite [List.Eq_Or_Mem_Iff_Mem_Cons] at Prop_Colourᵢₑ₁ᵤ;                /- := Colours -/
                                                                                           cases Prop_Colourᵢₑ₁ᵤ with
                                                                                           | inl Prop_NBR_Colourᵢₑ₁ᵤ => rewrite [Prop_NBR_Colourᵢₑ₁ᵤ];
                                                                                                                        exact List.Mem.head ( RULEᵥ.CENTER.NUMBER :: RULEᵤ.CENTER.PAST );
                                                                                           | inr Prop_PST_Colourᵢₑ₁ᵤ => exact List.Mem.tail ( RULEᵤ.CENTER.NUMBER )
                                                                                                                                            ( List.Mem.tail RULEᵥ.CENTER.NUMBER Prop_PST_Colourᵢₑ₁ᵤ ); );
                                                                      /- := Check Outgoing-Indirect Duo: -/
                                                                      cases Prop_Out_Indᵢₑ₁ᵤ with | intro Incᵢₑ₁ᵤ Prop_Out_Indᵢₑ₁ᵤ =>
                                                                      --
                                                                      apply Exists.intro Incᵢₑ₁ᵤ;
                                                                      exact ( by simp only [List.Mem_Or_Mem_Iff_Mem_Append];                   /- := path OUT.END inc [0, OUT.COLOUR] ∈ INDIRECT -/
                                                                                  apply Or.inr;
                                                                                  exact Prop_Out_Indᵢₑ₁ᵤ; ); );
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  /- Indirect Paths -/------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  simp only [type_indirect] at prop_indirectᵤ prop_indirectᵥ ⊢;
  simp only [List.Mem_Or_Mem_Iff_Mem_Append];
  intro ind ind_cases;
  cases ind_cases with
  | inl ind_casesᵥ => have Prop_Indirectᵥ := prop_indirectᵥ ind_casesᵥ;
                      simp only [type_indirect.check] at Prop_Indirectᵥ ⊢;
                      cases Prop_Indirectᵥ with | intro Prop_Startᵥ Prop_Indirectᵥ =>
                      cases Prop_Indirectᵥ with | intro Prop_Endᵥ Prop_Indirectᵥ =>
                      cases Prop_Indirectᵥ with | intro Prop_Levelᵥ Prop_Indirectᵥ =>
                      cases Prop_Indirectᵥ with | intro Colourᵥ Prop_Indirectᵥ =>
                      cases Prop_Indirectᵥ with | intro Coloursᵥ Prop_Indirectᵥ =>
                      cases Prop_Indirectᵥ with | intro Prop_Check_Coloursᵥ Prop_Indirectᵥ =>
                      cases Prop_Indirectᵥ with | intro Prop_Colourᵥ Prop_Indirectᵥ =>
                      cases Prop_Indirectᵥ with | intro Prop_Coloursᵥ Prop_Indirectᵥ =>
                      cases Prop_Indirectᵥ with | intro Prop_Ind_Incᵥ Prop_Ind_Outᵥ =>
                      --
                      apply And.intro ( by rewrite [prop_eq_lvl];         /- := Start Node -/
                                           exact Prop_Startᵥ; );
                      apply And.intro ( by rewrite [prop_eq_lvl];         /- := End Node -/
                                           exact Prop_Endᵥ; );
                      apply And.intro ( by rewrite [prop_eq_lvl];         /- := Colours -/
                                           exact Prop_Levelᵥ; );
                      apply Exists.intro Colourᵥ;
                      apply Exists.intro Coloursᵥ;
                      apply And.intro ( by exact Prop_Check_Coloursᵥ; );
                      apply And.intro ( by rewrite [prop_pstᵥ, List.Eq_Iff_Mem_Unit] at Prop_Colourᵥ;
                                           rewrite [Prop_Colourᵥ];
                                           exact List.Mem.tail ( RULEᵤ.CENTER.NUMBER )
                                                               ( List.Mem.head RULEᵤ.CENTER.PAST ); );
                      apply And.intro ( by exact Prop_Coloursᵥ; );
                      /- := Check Indirect-Incoming Duo: -/
                      cases Prop_Ind_Incᵥ with | intro Dep_Incᵥ Prop_Ind_Incᵥ =>
                      cases Prop_Ind_Incᵥ with | intro Prop_Ind_Incᵥ Prop_All_Ind_Incᵥ =>
                      --
                      apply And.intro ( by apply Exists.intro Dep_Incᵥ;
                                           apply And.intro ( by simp only [List.Mem_Or_Mem_Iff_Mem_Append];   /- := edge IND.END CENTER 0 dep_inc ∈ INCOMING -/
                                                                apply Or.inl;
                                                                rewrite [←collapse.center];
                                                                exact REWRITE.Mem_RwIncoming_Of_Mem Prop_Ind_Incᵥ; );
                                           intro all_incᵥ all_inc_casesᵥ;                                     /- := all_inc.START = IND.END ↔ all_inc = edge IND.END CENTER 0 dep_inc -/
                                           simp only [List.Mem_Or_Mem_Iff_Mem_Append] at all_inc_casesᵥ;
                                           cases all_inc_casesᵥ with
                                           | inl all_inc_casesᵥᵥ => have Ind_Inc_Casesᵥᵥ := REWRITE.Mem_Of_Mem_RwIncoming all_inc_casesᵥᵥ;                      /- := all_inc ∈ RULEᵥ.INCOMING -/
                                                                    cases Ind_Inc_Casesᵥᵥ with | intro Originalᵥ Ind_Inc_Memᵥᵥ =>
                                                                    have Prop_All_Ind_Incᵥᵥ := Prop_All_Ind_Incᵥ Ind_Inc_Memᵥᵥ;                                 /- := all_inc.START = IND.END ↔ all_inc = edge IND.END CENTER 0 dep_inc -/
                                                                    rewrite [Deduction.edge.injEq] at Prop_All_Ind_Incᵥᵥ ⊢;
                                                                    rewrite [←COLLAPSE.Simp_Inc_End (prop_incomingᵥ Ind_Inc_Memᵥᵥ)] at Prop_All_Ind_Incᵥᵥ;      /- := all_inc.END = RULEᵥ.CENTER -/
                                                                    rewrite [←REWRITE.Get_End_RwIncoming all_inc_casesᵥᵥ];                                      /- := all_inc.END = collapse.center RULEᵤ.CENTER RULEᵥ.CENTER -/
                                                                    simp only [true_and] at Prop_All_Ind_Incᵥᵥ ⊢;
                                                                    exact Prop_All_Ind_Incᵥᵥ;
                                           | inr all_inc_casesᵥᵤ => have Ind_Inc_Casesᵥᵤ := REWRITE.Mem_Of_Mem_RwIncoming all_inc_casesᵥᵤ;                      /- := all_inc ∈ RULEᵤ.INCOMING -/
                                                                    cases Ind_Inc_Casesᵥᵤ with | intro Originalᵤ Ind_Inc_Memᵥᵤ =>
                                                                    rewrite [Deduction.edge.injEq];
                                                                    have Prop_Check_Incomingᵥᵤ := prop_check_incoming Ind_Inc_Memᵥᵤ Prop_Ind_Incᵥ;              /- := all_inc.START ≠ IND.END -/
                                                                    simp only [Prop_Check_Incomingᵥᵤ, false_and]; );
                      /- := Check Indirect-Outgoing Duo: -/
                      cases Prop_Ind_Outᵥ with | intro Outᵥ Prop_Ind_Outᵥ =>
                      cases Prop_Ind_Outᵥ with | intro Dep_Outᵥ Prop_Ind_Outᵥ =>
                      cases Prop_Ind_Outᵥ with | intro Prop_Out_Colᵥ Prop_Ind_Outᵥ =>
                      cases Prop_Ind_Outᵥ with | intro Prop_Ind_Outᵥ Prop_All_Ind_Outᵥ =>
                      --
                      apply Exists.intro Outᵥ;
                      apply Exists.intro Dep_Outᵥ;
                      apply And.intro ( by exact Prop_Out_Colᵥ; );
                      apply And.intro ( by simp only [List.Mem_Or_Mem_Iff_Mem_Append];     /- := edge CENTER out colour₁ dep_out ∈ OUTGOING -/
                                           apply Or.inl;
                                           rewrite [←collapse.center];
                                           exact REWRITE.Mem_RwOutgoing_Of_Mem Prop_Ind_Outᵥ; );
                      intro all_outᵥ all_out_casesᵥ;                                       /- := all_out.COLOUR = colour₁ ↔ all_out = edge CENTER out colour₁ dep_out -/
                      simp only [List.Mem_Or_Mem_Iff_Mem_Append] at all_out_casesᵥ;
                      cases all_out_casesᵥ with
                      | inl all_out_casesᵥᵥ => have Ind_Out_Casesᵥᵥ := REWRITE.Mem_Of_Mem_RwOutgoing all_out_casesᵥᵥ;                      /- := all_out ∈ RULEᵥ.OUTGOING -/
                                               cases Ind_Out_Casesᵥᵥ with | intro Originalᵥ Ind_Out_Memᵥᵥ =>
                                               have Prop_All_Ind_Outᵥᵥ := Prop_All_Ind_Outᵥ Ind_Out_Memᵥᵥ;                                 /- := all_out.COLOUR = Colour ↔ all_out = edge CENTER out Colour dep_out -/
                                               rewrite [Deduction.edge.injEq] at Prop_All_Ind_Outᵥᵥ ⊢;
                                               rewrite [←COLLAPSE.Simp_Out_Start₁ (prop_outgoingᵥ Ind_Out_Memᵥᵥ)] at Prop_All_Ind_Outᵥᵥ;   /- := all_out.START = RULEᵥ.CENTER -/
                                               rewrite [←REWRITE.Get_Start_RwOutgoing all_out_casesᵥᵥ];                                    /- := all_out.START = collapse.center RULEᵤ.CENTER RULEᵥ.CENTER -/
                                               simp only [true_and] at Prop_All_Ind_Outᵥᵥ ⊢;
                                               exact Prop_All_Ind_Outᵥᵥ;
                      | inr all_out_casesᵥᵤ => have Ind_Out_Casesᵥᵤ := REWRITE.Mem_Of_Mem_RwOutgoing all_out_casesᵥᵤ;                      /- := all_out ∈ RULEᵤ.OUTGOING -/
                                               cases Ind_Out_Casesᵥᵤ with | intro Originalᵤ Ind_Out_Memᵥᵤ =>
                                               have Ind_Out_Colourᵥᵤ := COLLAPSE.Simp_Out_Colour₁ (prop_outgoingᵤ Ind_Out_Memᵥᵤ);          /- := all_out.COLOUR = 0 ∨ all_out.COLOUR ∈ RULEᵤ.CENTER.NUMBER :: RULEᵤ.CENTER.PAST -/
                                               simp only [prop_pstᵥ, List.Eq_Iff_Mem_Unit] at Prop_Colourᵥ;                                /- := Colour = RULEᵥ.CENTER.NUMBER -/
                                               rewrite [Deduction.edge.injEq];
                                               have NE_Colourᵥ : all_outᵥ.COLOUR ≠ Colourᵥ := by rewrite [ne_eq, ←imp_false];
                                                                                                 intro EQ_Colour;
                                                                                                 rewrite [EQ_Colour, Prop_Colourᵥ] at Ind_Out_Colourᵥᵤ;
                                                                                                 cases Ind_Out_Colourᵥᵤ with
                                                                                                 | inl EQ_Zero => apply absurd EQ_Zero;
                                                                                                                  exact Nat.ne_of_lt' prop_nbrᵥ;
                                                                                                 | inr GT_Zero => apply absurd GT_Zero;
                                                                                                                  rewrite [List.Eq_Or_Mem_Iff_Mem_Cons, not_or];
                                                                                                                  exact And.intro ( by exact Nat.ne_of_lt prop_lt_nbr; )
                                                                                                                                  ( by exact prop_ne_pst; );
                                               simp only [NE_Colourᵥ, false_and, and_false];
  | inr ind_casesᵤ => have Prop_Indirectᵤ := prop_indirectᵤ ind_casesᵤ;
                      simp only [type_indirect.check] at Prop_Indirectᵤ ⊢;
                      cases Prop_Indirectᵤ with | intro Prop_Startᵤ Prop_Indirectᵤ =>
                      cases Prop_Indirectᵤ with | intro Prop_Endᵤ Prop_Indirectᵤ =>
                      cases Prop_Indirectᵤ with | intro Prop_Levelᵤ Prop_Indirectᵤ =>
                      cases Prop_Indirectᵤ with | intro Colourᵤ Prop_Indirectᵤ =>
                      cases Prop_Indirectᵤ with | intro Coloursᵤ Prop_Indirectᵤ =>
                      cases Prop_Indirectᵤ with | intro Prop_Check_Coloursᵤ Prop_Indirectᵤ =>
                      cases Prop_Indirectᵤ with | intro Prop_Colourᵤ Prop_Indirectᵤ =>
                      cases Prop_Indirectᵤ with | intro Prop_Coloursᵤ Prop_Indirectᵤ =>
                      cases Prop_Indirectᵤ with | intro Prop_Ind_Incᵤ Prop_Ind_Outᵤ =>
                      --
                      apply And.intro ( by exact Prop_Startᵤ; );           /- := Start Node -/
                      apply And.intro ( by exact Prop_Endᵤ; );             /- := End Node -/
                      apply And.intro ( by exact Prop_Levelᵤ; );           /- := Colours -/
                      apply Exists.intro Colourᵤ;
                      apply Exists.intro Coloursᵤ;
                      apply And.intro ( by exact Prop_Check_Coloursᵤ; );
                      apply And.intro ( by rewrite [List.Eq_Or_Mem_Iff_Mem_Cons] at Prop_Colourᵤ;
                                           cases Prop_Colourᵤ with
                                           | inl Prop_NBR_Colourᵤ => rewrite [Prop_NBR_Colourᵤ];
                                                                     exact List.Mem.head ( RULEᵥ.CENTER.NUMBER :: RULEᵤ.CENTER.PAST );
                                           | inr Prop_PST_Colourᵤ => exact List.Mem.tail ( RULEᵤ.CENTER.NUMBER )
                                                                                         ( List.Mem.tail RULEᵥ.CENTER.NUMBER Prop_PST_Colourᵤ ); );
                      apply And.intro ( by exact Prop_Coloursᵤ; );
                      /- := Check Indirect-Incoming Duo: -/
                      cases Prop_Ind_Incᵤ with | intro Dep_Incᵤ Prop_Ind_Incᵤ =>
                      cases Prop_Ind_Incᵤ with | intro Prop_Ind_Incᵤ Prop_All_Ind_Incᵤ =>
                      --
                      apply And.intro ( by apply Exists.intro Dep_Incᵤ;
                                           apply And.intro ( by simp only [List.Mem_Or_Mem_Iff_Mem_Append];   /- := edge IND.END CENTER 0 dep_inc ∈ INCOMING -/
                                                                apply Or.inr;
                                                                rewrite [←collapse.center];
                                                                exact REWRITE.Mem_RwIncoming_Of_Mem Prop_Ind_Incᵤ; );
                                           intro all_incᵤ all_inc_casesᵤ;                                     /- := all_inc.START = IND.END ↔ all_inc = edge IND.END CENTER 0 dep_inc -/
                                           simp only [List.Mem_Or_Mem_Iff_Mem_Append] at all_inc_casesᵤ;
                                           cases all_inc_casesᵤ with
                                           | inl all_inc_casesᵤᵥ => have Ind_Inc_Casesᵤᵥ := REWRITE.Mem_Of_Mem_RwIncoming all_inc_casesᵤᵥ;                      /- := all_inc ∈ RULEᵥ.INCOMING -/
                                                                    cases Ind_Inc_Casesᵤᵥ with | intro Originalᵥ Ind_Inc_Memᵤᵥ =>
                                                                    rewrite [Deduction.edge.injEq];
                                                                    have Prop_Check_Incomingᵤᵥ := prop_check_incoming Prop_Ind_Incᵤ Ind_Inc_Memᵤᵥ;              /- := IND.END ≠ all_inc.START -/
                                                                    rewrite [ne_comm] at Prop_Check_Incomingᵤᵥ;
                                                                    simp only [Prop_Check_Incomingᵤᵥ, false_and];
                                           | inr all_inc_casesᵤᵤ => have Ind_Inc_Casesᵤᵤ := REWRITE.Mem_Of_Mem_RwIncoming all_inc_casesᵤᵤ;                      /- := all_inc ∈ RULEᵤ.INCOMING -/
                                                                    cases Ind_Inc_Casesᵤᵤ with | intro Originalᵤ Ind_Inc_Memᵤᵤ =>
                                                                    have Prop_All_Ind_Incᵤᵤ := Prop_All_Ind_Incᵤ Ind_Inc_Memᵤᵤ;                                 /- := all_inc.START = IND.END ↔ all_inc = edge IND.END CENTER 0 dep_inc -/
                                                                    rewrite [Deduction.edge.injEq] at Prop_All_Ind_Incᵤᵤ ⊢;
                                                                    rewrite [←COLLAPSE.Simp_Inc_End (prop_incomingᵤ Ind_Inc_Memᵤᵤ)] at Prop_All_Ind_Incᵤᵤ;      /- := all_inc.END = RULEᵤ.CENTER -/
                                                                    rewrite [←REWRITE.Get_End_RwIncoming all_inc_casesᵤᵤ];                                      /- := all_inc.END = collapse.center RULEᵤ.CENTER RULEᵥ.CENTER -/
                                                                    simp only [true_and] at Prop_All_Ind_Incᵤᵤ ⊢;
                                                                    exact Prop_All_Ind_Incᵤᵤ; );
                      /- Check Outgoing-Indirect Duo: -/
                      cases Prop_Ind_Outᵤ with | intro Outᵤ Prop_Ind_Outᵤ =>
                      cases Prop_Ind_Outᵤ with | intro Dep_Outᵤ Prop_Ind_Outᵤ =>
                      cases Prop_Ind_Outᵤ with | intro Prop_Out_Colᵤ Prop_Ind_Outᵤ =>
                      cases Prop_Ind_Outᵤ with | intro Prop_Ind_Outᵤ Prop_All_Ind_Outᵤ =>
                      --
                      apply Exists.intro Outᵤ;
                      apply Exists.intro Dep_Outᵤ;
                      apply And.intro ( by exact Prop_Out_Colᵤ; );
                      apply And.intro ( by simp only [List.Mem_Or_Mem_Iff_Mem_Append];     /- := edge CENTER out colour dep_out ∈ OUTGOING -/
                                           apply Or.inr;
                                           rewrite [←collapse.center];
                                           exact REWRITE.Mem_RwOutgoing_Of_Mem Prop_Ind_Outᵤ; );
                      intro all_outᵤ all_out_casesᵤ;                                       /- := all_out.COLOUR = colour ↔ all_out = edge CENTER out colour₁ dep_out -/
                      simp only [List.Mem_Or_Mem_Iff_Mem_Append] at all_out_casesᵤ;
                      cases all_out_casesᵤ with
                      | inl all_out_casesᵤᵥ => have Ind_Out_Casesᵤᵥ := REWRITE.Mem_Of_Mem_RwOutgoing all_out_casesᵤᵥ;                      /- := all_out ∈ RULEᵥ.OUTGOING -/
                                               cases Ind_Out_Casesᵤᵥ with | intro Originalᵥ Ind_Out_Memᵤᵥ =>
                                               have Ind_Out_Colourᵤᵥ := COLLAPSE.Simp_Out_Colour₁ (prop_outgoingᵥ Ind_Out_Memᵤᵥ);          /- := all_out.COLOUR = 0 ∨ all_out.COLOUR ∈ RULEᵥ.CENTER.NUMBER :: RULEᵥ.CENTER.PAST -/
                                               simp only [prop_pstᵥ, List.Eq_Iff_Mem_Unit] at Ind_Out_Colourᵤᵥ;
                                               rewrite [Deduction.edge.injEq];
                                               have NE_Colourᵤ : all_outᵤ.COLOUR ≠ Colourᵤ := by rewrite [ne_eq, ←imp_false];
                                                                                                 intro EQ_Colour;
                                                                                                 apply absurd Prop_Colourᵤ;                /- := Colour ∉ RULEᵤ.CENTER.NUMBER :: RULEᵤ.CENTER.PAST -/
                                                                                                 cases Ind_Out_Colourᵤᵥ with
                                                                                                 | inl EQ_Zero => rewrite [←EQ_Colour, EQ_Zero, prop_pstᵤ];
                                                                                                                  rewrite [List.Eq_Iff_Mem_Unit];
                                                                                                                  exact Nat.ne_of_lt prop_nbrᵤ;
                                                                                                 | inr GT_Zero => rewrite [←EQ_Colour, GT_Zero];
                                                                                                                  rewrite [List.Eq_Or_Mem_Iff_Mem_Cons, not_or];
                                                                                                                  exact And.intro ( by exact Nat.ne_of_lt prop_lt_nbr; )
                                                                                                                                  ( by exact prop_ne_pst; );
                                               simp only [NE_Colourᵤ, false_and, and_false];
                      | inr all_out_casesᵤᵤ => have Ind_Out_Casesᵤᵤ := REWRITE.Mem_Of_Mem_RwOutgoing all_out_casesᵤᵤ;                      /- := all_out ∈ RULEᵤ.OUTGOING -/
                                               cases Ind_Out_Casesᵤᵤ with | intro Originalᵤ Ind_Out_Memᵤᵤ =>
                                               have Prop_All_Ind_Outᵤᵤ := Prop_All_Ind_Outᵤ Ind_Out_Memᵤᵤ;                                 /- := all_out.COLOUR = Colour ↔ all_out = edge CENTER out Colour dep_out -/
                                               rewrite [Deduction.edge.injEq] at Prop_All_Ind_Outᵤᵤ ⊢;
                                               rewrite [←COLLAPSE.Simp_Out_Start₁ (prop_outgoingᵤ Ind_Out_Memᵤᵤ)] at Prop_All_Ind_Outᵤᵤ;   /- := all_out.START = RULEᵤ.CENTER -/
                                               rewrite [←REWRITE.Get_Start_RwOutgoing all_out_casesᵤᵤ];                                    /- := all_out.START = collapse.center RULEᵤ.CENTER RULEᵥ.CENTER -/
                                               simp only [true_and] at Prop_All_Ind_Outᵤᵤ ⊢;
                                               exact Prop_All_Ind_Outᵤᵤ;
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  /- Lemma: Collapse Execution (Type 1 & Type 0 => Type 1) (Nodes) -/
  theorem Col_Of_Collapse_Col_Pre {RULEᵤ RULEᵥ : Neighborhood} :
    ( check_collapse_nodes RULEᵤ RULEᵥ ) →
    ( type1_collapse RULEᵤ ) →
    ( type1_pre_collapse RULEᵥ ) →
    ---------------------------
    ( type1_collapse (collapse RULEᵤ RULEᵥ) ) := by
  intro prop_check_collapse prop_typeᵤ prop_typeᵥ;
  --
  simp only [check_collapse_nodes] at prop_check_collapse;
  cases prop_check_collapse with | intro prop_lt_nbr prop_check_collapse =>
  cases prop_check_collapse with | intro prop_ne_pst prop_check_collapse =>
  cases prop_check_collapse with | intro prop_eq_lvl prop_check_collapse =>
  cases prop_check_collapse with | intro prop_eq_fml prop_check_incoming =>
  --
  simp only [type1_collapse] at prop_typeᵤ;
  cases prop_typeᵤ with | intro prop_nbrᵤ prop_typeᵤ =>
  cases prop_typeᵤ with | intro prop_lvlᵤ prop_typeᵤ =>
  cases prop_typeᵤ with | intro prop_colᵤ prop_typeᵤ =>
  cases prop_typeᵤ with | intro prop_pstᵤ prop_typeᵤ =>
  cases prop_typeᵤ with | intro prop_inc_nilᵤ prop_typeᵤ =>
  cases prop_typeᵤ with | intro prop_out_consᵤ prop_typeᵤ =>
  cases prop_typeᵤ with | intro prop_out_coloursᵤ prop_typeᵤ =>
  cases prop_typeᵤ with | intro prop_dir_nilᵤ prop_typeᵤ =>
  cases prop_typeᵤ with | intro prop_ind_lenᵤ prop_typeᵤ =>
  cases prop_typeᵤ with | intro prop_ind_coloursᵤ prop_typeᵤ =>
  cases prop_typeᵤ with | intro prop_incomingᵤ prop_typeᵤ =>
  cases prop_typeᵤ with | intro prop_outgoingᵤ prop_indirectᵤ =>
  --
  cases prop_pstᵤ with | intro pastᵤ prop_pstᵤ =>
  cases prop_pstᵤ with | intro pastsᵤ prop_pstᵤ =>
  cases prop_pstᵤ with | intro prop_check_pastᵤ prop_pstᵤ =>
  --
  cases prop_out_consᵤ with | intro outᵤ prop_out_consᵤ =>
  cases prop_out_consᵤ with | intro outsᵤ prop_out_consᵤ =>
  --
  simp only [type1_pre_collapse] at prop_typeᵥ;
  cases prop_typeᵥ with | intro prop_nbrᵥ prop_typeᵥ =>
  cases prop_typeᵥ with | intro prop_lvlᵥ prop_typeᵥ =>
  cases prop_typeᵥ with | intro prop_colᵥ prop_typeᵥ =>
  cases prop_typeᵥ with | intro prop_pstᵥ prop_typeᵥ =>
  cases prop_typeᵥ with | intro prop_inc_nilᵥ prop_typeᵥ =>
  cases prop_typeᵥ with | intro prop_inc_lenᵥ prop_typeᵥ =>
  cases prop_typeᵥ with | intro prop_out_unitᵥ prop_typeᵥ =>
  cases prop_typeᵥ with | intro prop_out_coloursᵥ prop_typeᵥ =>
  cases prop_typeᵥ with | intro prop_dir_nilᵥ prop_typeᵥ =>
  cases prop_typeᵥ with | intro prop_ind_startsᵥ prop_typeᵥ =>
  cases prop_typeᵥ with | intro prop_ind_lenᵥ prop_typeᵥ =>
  cases prop_typeᵥ with | intro prop_ind_coloursᵥ prop_typeᵥ =>
  cases prop_typeᵥ with | intro prop_incomingᵥ prop_typeᵥ =>
  cases prop_typeᵥ with | intro prop_outgoingᵥ prop_indirectᵥ =>
  --
  cases prop_out_unitᵥ with | intro outᵥ prop_out_unitᵥ =>
  --
  simp only [collapse];
  simp only [collapse.center];
  simp only [type1_collapse];
  /- Check Center-/
  apply And.intro ( by exact prop_nbrᵤ; );                                        /- := RULE.CENTER.NUMBER > 0 -/
  apply And.intro ( by exact prop_lvlᵤ; );                                        /- := RULE.CENTER.LEVEL > 0 -/
  apply And.intro ( by trivial; );                                                /- := RULE.CENTER.COLLAPSED = true -/
  apply And.intro ( by apply Exists.intro RULEᵥ.CENTER.NUMBER;                    /- := check_numbers (past :: pasts) ∧ RULE.CENTER.PAST = (past::pasts) -/
                       apply Exists.intro RULEᵤ.CENTER.PAST;
                       apply And.intro ( by rewrite [prop_pstᵤ];
                                            exact COLLAPSE.Check_Numbers_Cons prop_nbrᵥ prop_check_pastᵤ; );
                       trivial; );
  /- Check Deduction Edges -/
  apply And.intro ( by intro prop_inc_nil;                                        /- := ( RULE.INCOMING = [] ) → ( RULE.CENTER.HYPOTHESIS = true ) -/
                       simp only [List.append_eq_nil] at prop_inc_nil;
                       simp only [←List.length_eq_zero] at prop_inc_nil prop_inc_nilᵥ;
                       simp only [REWRITE.Eq_Length_RwIncoming] at prop_inc_nil;
                       simp only [prop_inc_nilᵥ] at prop_inc_nil;
                       simp only [Bool.or_eq_true];
                       exact Or.inr (And.left prop_inc_nil); );
  apply And.intro ( by simp only [prop_out_unitᵥ];                                                                    /- := RULE.OUTGOING = (out::outs) -/
                       apply Exists.intro ( edge ( collapse.center RULEᵤ.CENTER RULEᵥ.CENTER )                        /- RULEᵥ.OUTGOING -/
                                                 ( outᵥ.END )
                                                 ( outᵥ.COLOUR )
                                                 ( outᵥ.DEPENDENCY ) );
                       apply Exists.intro ( collapse.rewrite_outgoing ( collapse.center RULEᵤ.CENTER RULEᵥ.CENTER )   /- RULEᵤ.OUTGOING -/
                                                                      ( RULEᵤ.OUTGOING ) );
                       simp only [collapse.rewrite_outgoing];
                       simp only [collapse.center];
                       trivial; );
  apply And.intro ( by intro out₁ out₂ out_mem₁ out_mem₂ gt_zero₁₂;                          /- := OUT₁.COLOUR = OUT₂.COLOUR ↔ OUT₁ = OUT₂ -/
                       rewrite [prop_out_unitᵥ] at out_mem₁ out_mem₂;
                       simp only [collapse.rewrite_outgoing] at out_mem₁ out_mem₂;
                       simp only [List.Mem_Or_Mem_Iff_Mem_Append] at out_mem₁ out_mem₂;
                       simp only [List.Eq_Iff_Mem_Unit] at out_mem₁ out_mem₂;
                       simp only [Deduction.edge.injEq'];
                       --
                       simp only [type_outgoing₁] at prop_outgoingᵤ prop_outgoingᵥ;
                       rewrite [prop_out_unitᵥ] at prop_outgoingᵥ;
                       have Out_Colourᵥ := COLLAPSE.Simp_Out_Colour₁ (prop_outgoingᵥ (List.Mem.head []));
                       simp only [prop_pstᵥ, List.Eq_Iff_Mem_Unit] at Out_Colourᵥ;
                       --
                       cases out_mem₁ with
                       | inl out_mem₁ᵥ => cases out_mem₂ with
                                          | inl out_mem₂ᵥ => rewrite [out_mem₁ᵥ, out_mem₂ᵥ]; simp only [true_and];
                                          | inr out_mem₂ᵤ => rewrite [out_mem₁ᵥ] at gt_zero₁₂ ⊢;                              /- := out₁ = outᵥ -/
                                                             rewrite [REWRITE.Get_Start_RwOutgoing out_mem₂ᵤ];                /- := out₂.START = collapse.center RULEᵤ.CENTER RULEᵥ.CENTER -/
                                                             --
                                                             have Out_Cases₂ᵤ := REWRITE.Mem_Of_Mem_RwOutgoing out_mem₂ᵤ;                 /- := out₂ ∈ RULEᵥ.OUTGOING -/
                                                             cases Out_Cases₂ᵤ with | intro Originalᵤ Out_Mem₂ᵤ =>
                                                             have Out_Colour₂ᵤ := COLLAPSE.Simp_Out_Colour₁ (prop_outgoingᵤ Out_Mem₂ᵤ);   /- := out₂.COLOUR = 0 ∨ out₂.COLOUR ∈ RULEᵥ.CENTER.NUMBER :: RULEᵥ.CENTER.PAST -/
                                                             --
                                                             simp only [true_and] at gt_zero₁₂ Out_Colour₂ᵤ ⊢;
                                                             have NE_Colour : outᵥ.COLOUR ≠ out₂.COLOUR := by rewrite [ne_eq, ←imp_false];
                                                                                                              intro EQ_Colour;
                                                                                                              cases Out_Colourᵥ with
                                                                                                              | inl EQ_Zeroᵥ => apply absurd gt_zero₁₂; rewrite [←EQ_Colour, EQ_Zeroᵥ]; trivial;
                                                                                                              | inr GT_Zeroᵥ => cases Out_Colour₂ᵤ with
                                                                                                                                | inl EQ_Zero₂ᵤ => apply absurd gt_zero₁₂; rewrite [EQ_Colour, EQ_Zero₂ᵤ]; trivial;
                                                                                                                                | inr GT_Zero₂ᵤ => simp only [List.Eq_Or_Mem_Iff_Mem_Cons] at GT_Zero₂ᵤ;
                                                                                                                                                   rewrite [←EQ_Colour, GT_Zeroᵥ] at GT_Zero₂ᵤ;
                                                                                                                                                   apply absurd GT_Zero₂ᵤ;
                                                                                                                                                   simp only [not_or];
                                                                                                                                                   exact And.intro ( by exact Nat.ne_of_lt prop_lt_nbr; )
                                                                                                                                                                   ( by exact prop_ne_pst; );
                                                             simp only [NE_Colour, false_and, and_false];
                       | inr out_mem₁ᵤ => cases out_mem₂ with
                                          | inl out_mem₂ᵥ => rewrite [REWRITE.Get_Start_RwOutgoing out_mem₁ᵤ];                /- := out₁.START = collapse.center RULEᵤ.CENTER RULEᵥ.CENTER -/
                                                             rewrite [out_mem₂ᵥ] at gt_zero₁₂ ⊢;                              /- := out₂ = outᵥ -/
                                                             --
                                                             have Out_Cases₁ᵤ := REWRITE.Mem_Of_Mem_RwOutgoing out_mem₁ᵤ;                 /- := out₁ ∈ RULEᵥ.OUTGOING -/
                                                             cases Out_Cases₁ᵤ with | intro Originalᵤ Out_Mem₁ᵤ =>
                                                             have Out_Colour₁ᵤ := COLLAPSE.Simp_Out_Colour₁ (prop_outgoingᵤ Out_Mem₁ᵤ);   /- := out₁.COLOUR = 0 ∨ out₁.COLOUR ∈ RULEᵥ.CENTER.NUMBER :: RULEᵥ.CENTER.PAST -/
                                                             --
                                                             simp only [true_and] at gt_zero₁₂ Out_Colour₁ᵤ ⊢;
                                                             have NE_Colour : out₁.COLOUR ≠ outᵥ.COLOUR := by rewrite [ne_eq, ←imp_false];
                                                                                                              intro EQ_Colour;
                                                                                                              cases Out_Colourᵥ with
                                                                                                              | inl EQ_Zeroᵥ => apply absurd gt_zero₁₂; rewrite [EQ_Colour, EQ_Zeroᵥ]; trivial;
                                                                                                              | inr GT_Zeroᵥ => cases Out_Colour₁ᵤ with
                                                                                                                                | inl EQ_Zero₁ᵤ => apply absurd gt_zero₁₂; rewrite [←EQ_Colour, EQ_Zero₁ᵤ]; trivial;
                                                                                                                                | inr GT_Zero₁ᵤ => simp only [List.Eq_Or_Mem_Iff_Mem_Cons] at GT_Zero₁ᵤ;
                                                                                                                                                   rewrite [EQ_Colour, GT_Zeroᵥ] at GT_Zero₁ᵤ;
                                                                                                                                                   apply absurd GT_Zero₁ᵤ;
                                                                                                                                                   simp only [not_or];
                                                                                                                                                   exact And.intro ( by exact Nat.ne_of_lt prop_lt_nbr; )
                                                                                                                                                                   ( by exact prop_ne_pst; );
                                                             simp only [NE_Colour, false_and, and_false];
                                          | inr out_mem₂ᵤ => rewrite [REWRITE.Get_Start_RwOutgoing out_mem₁ᵤ];              /- := out₁.START = collapse.center RULEᵤ.CENTER RULEᵥ.CENTER -/
                                                             rewrite [REWRITE.Get_Start_RwOutgoing out_mem₂ᵤ];              /- := out₂.START = collapse.center RULEᵤ.CENTER RULEᵥ.CENTER -/
                                                             simp only [true_and] at gt_zero₁₂ ⊢;
                                                             --
                                                             have Out_Cases₁ᵤ := REWRITE.Mem_Of_Mem_RwOutgoing out_mem₁ᵤ;               /- := out₁ ∈ RULEᵥ.OUTGOING -/
                                                             cases Out_Cases₁ᵤ with | intro Original₁ᵤ Out_Mem₁ᵤ =>
                                                             have Out_Start₁ᵤ := COLLAPSE.Simp_Out_Start₁ (prop_outgoingᵤ Out_Mem₁ᵤ);   /- := out₁.START = RULEᵤ.CENTER -/
                                                             have Out_Cases₂ᵤ := REWRITE.Mem_Of_Mem_RwOutgoing out_mem₂ᵤ;               /- := out₂ ∈ RULEᵥ.OUTGOING -/
                                                             cases Out_Cases₂ᵤ with | intro Original₂ᵤ Out_Mem₂ᵤ =>
                                                             have Out_Start₂ᵤ := COLLAPSE.Simp_Out_Start₁ (prop_outgoingᵤ Out_Mem₂ᵤ);   /- := out₂.START = RULEᵤ.CENTER -/
                                                             --
                                                             have Iff_Out_Colourᵤ := prop_out_coloursᵤ Out_Mem₁ᵤ Out_Mem₂ᵤ gt_zero₁₂;
                                                             simp only [Deduction.edge.injEq] at Out_Start₁ᵤ Out_Start₂ᵤ Iff_Out_Colourᵤ;
                                                             simp only [Out_Start₁ᵤ, Out_Start₂ᵤ, true_and] at Iff_Out_Colourᵤ;
                                                             exact Iff_Out_Colourᵤ; );
  apply And.intro ( by rewrite [prop_dir_nilᵤ, prop_dir_nilᵥ];        /- := RULE.DIRECT = [] -/
                       simp only [collapse.rewrite_direct];
                       trivial; );
  apply And.intro ( by simp only [List.length_append];                /- := List.length (RULE.INDIRECT) = List.length (RULE.INCOMING) -/
                       simp only [REWRITE.Eq_Length_RwIncoming];
                       simp only [prop_ind_lenᵤ, prop_ind_lenᵥ]; );
  apply And.intro ( by intro ind ind_cases;                           /- := ind.COLOURS = [0, colour] -/
                       simp only [List.Mem_Or_Mem_Iff_Mem_Append] at ind_cases;
                       cases ind_cases with
                       | inl ind_casesᵥ => apply Exists.intro RULEᵥ.CENTER.NUMBER;
                                           exact prop_ind_coloursᵥ ind_casesᵥ;
                       | inr ind_casesᵤ => exact prop_ind_coloursᵤ ind_casesᵤ; );
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  /- Incoming Edges -/------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  apply And.intro ( by simp only [type_incoming] at prop_incomingᵤ prop_incomingᵥ ⊢;
                       simp only [List.Mem_Or_Mem_Iff_Mem_Append];
                       intro inc inc_cases;
                       cases inc_cases with
                       | inl inc_casesᵥ => have Inc_Caseᵥ := REWRITE.Mem_Of_Mem_RwIncoming inc_casesᵥ;            /- := inc ∈ RULEᵥ.INCOMING -/
                                           cases Inc_Caseᵥ with | intro Originalᵥ Inc_Memᵥ =>
                                           have Prop_Incomingᵥ := prop_incomingᵥ Inc_Memᵥ;                        /- := type_incoming.check inc RULEᵥ.CENTER -/
                                           simp only [type_incoming.check] at Prop_Incomingᵥ ⊢;
                                           cases Prop_Incomingᵥ with | intro Prop_Startᵥ Prop_Incomingᵥ =>
                                           cases Prop_Incomingᵥ with | intro Prop_Endᵥ Prop_Incomingᵥ =>
                                           cases Prop_Incomingᵥ with | intro Prop_Colourᵥ Prop_Inc_Indᵥ =>
                                           --
                                           apply And.intro ( by rewrite [prop_eq_lvl];                            /- := Start Node -/
                                                                exact Prop_Startᵥ; );
                                           apply And.intro ( by exact REWRITE.Get_End_RwIncoming inc_casesᵥ; );   /- := End Node -/
                                           apply And.intro ( by exact Prop_Colourᵥ; );                            /- := Colours -/
                                           /- := Check Incoming-Indirect Duo: -/
                                           cases Prop_Inc_Indᵥ with | intro Colourᵥ Prop_Inc_Indᵥ =>
                                           cases Prop_Inc_Indᵥ with | intro Coloursᵥ Prop_Inc_Indᵥ =>
                                           cases Prop_Inc_Indᵥ with | intro Ancᵥ Prop_Inc_Indᵥ =>
                                           --
                                           apply Exists.intro Colourᵥ;
                                           apply Exists.intro Coloursᵥ;
                                           apply Exists.intro Ancᵥ;
                                           exact ( by simp only [List.Mem_Or_Mem_Iff_Mem_Append];                 /- := path anc INC.START (0::colour::colours) ∈ INDIRECT -/
                                                      apply Or.inl;
                                                      exact Prop_Inc_Indᵥ; );
                       | inr inc_casesᵤ => have Inc_Caseᵤ := REWRITE.Mem_Of_Mem_RwIncoming inc_casesᵤ;            /- := inc ∈ RULEᵤ.INCOMING -/
                                           cases Inc_Caseᵤ with | intro Originalᵤ Inc_Memᵤ =>
                                           have Prop_Incomingᵤ := prop_incomingᵤ Inc_Memᵤ;                        /- := type_incoming.check inc RULEᵤ.CENTER -/
                                           simp only [type_incoming.check] at Prop_Incomingᵤ ⊢;
                                           cases Prop_Incomingᵤ with | intro Prop_Startᵤ Prop_Incomingᵤ =>
                                           cases Prop_Incomingᵤ with | intro Prop_Endᵤ Prop_Incomingᵤ =>
                                           cases Prop_Incomingᵤ with | intro Prop_Colourᵤ Prop_Inc_Indᵤ =>
                                           --
                                           apply And.intro ( by exact Prop_Startᵤ; );                             /- := Start Node -/
                                           apply And.intro ( by exact REWRITE.Get_End_RwIncoming inc_casesᵤ; );   /- := End Node -/
                                           apply And.intro ( by exact Prop_Colourᵤ; );                            /- := Colours -/
                                           /- := Check Incoming-Indirect Duo: -/
                                           cases Prop_Inc_Indᵤ with | intro Colourᵤ Prop_Inc_Indᵤ =>
                                           cases Prop_Inc_Indᵤ with | intro Coloursᵤ Prop_Inc_Indᵤ =>
                                           cases Prop_Inc_Indᵤ with | intro Ancᵤ Prop_Inc_Indᵤ =>
                                           --
                                           apply Exists.intro Colourᵤ;
                                           apply Exists.intro Coloursᵤ;
                                           apply Exists.intro Ancᵤ;
                                           exact ( by simp only [List.Mem_Or_Mem_Iff_Mem_Append];                 /- := path anc INC.START (0::colour::colours) ∈ INDIRECT -/
                                                      apply Or.inr;
                                                      exact Prop_Inc_Indᵤ; ); );
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  /- Outgoing Edges -/------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  apply And.intro ( by simp only [type_outgoing₁] at prop_outgoingᵤ prop_outgoingᵥ ⊢;
                       simp only [List.Mem_Or_Mem_Iff_Mem_Append];
                       intro out out_cases;
                       cases out_cases with
                       | inl out_casesᵥ => have Out_Caseᵥ := REWRITE.Mem_Of_Mem_RwOutgoing out_casesᵥ;          /- := out ∈ RULEᵥ.OUTGOING -/
                                           cases Out_Caseᵥ with | intro Originalᵥ Out_Memᵥ =>
                                           have Prop_Outgoingᵥ := prop_outgoingᵥ Out_Memᵥ;                      /- := type_outgoing.check out RULEᵥ.CENTER -/
                                           cases Prop_Outgoingᵥ with
                                           | inl Prop_Outgoingₕ₁ᵥ => simp only [type_outgoing₁.check_h₁] at Prop_Outgoingₕ₁ᵥ ⊢;
                                                                     cases Prop_Outgoingₕ₁ᵥ with | intro Prop_HPTₕ₁ᵥ Prop_Outgoingₕ₁ᵥ =>
                                                                     cases Prop_Outgoingₕ₁ᵥ with | intro Prop_Startₕ₁ᵥ Prop_Outgoingₕ₁ᵥ =>
                                                                     cases Prop_Outgoingₕ₁ᵥ with | intro Prop_Endₕ₁ᵥ Prop_Colourₕ₁ᵥ =>
                                                                     --
                                                                     apply Or.inl;
                                                                     apply And.intro ( by rewrite [Bool.or_eq_true_iff];                       /- := Type 1 Hypothesis -/
                                                                                          exact Or.inr Prop_HPTₕ₁ᵥ; );
                                                                     apply And.intro ( by exact REWRITE.Get_Start_RwOutgoing out_casesᵥ; );    /- := Start Node -/
                                                                     apply And.intro ( by rewrite [prop_eq_lvl];                               /- := End Node -/
                                                                                          exact Prop_Endₕ₁ᵥ; );
                                                                     exact Prop_Colourₕ₁ᵥ;                                                     /- := Colours -/
                                           | inr Prop_Outgoingᵢₑ₁ᵥ => simp only [type_outgoing₁.check_ie₁] at Prop_Outgoingᵢₑ₁ᵥ ⊢;
                                                                      cases Prop_Outgoingᵢₑ₁ᵥ with | intro Prop_HPTᵢₑ₁ᵥ Prop_Outgoingᵢₑ₁ᵥ =>
                                                                      cases Prop_Outgoingᵢₑ₁ᵥ with | intro Prop_Startᵢₑ₁ᵥ Prop_Outgoingᵢₑ₁ᵥ =>
                                                                      cases Prop_Outgoingᵢₑ₁ᵥ with | intro Prop_Endᵢₑ₁ᵥ Prop_Outgoingᵢₑ₁ᵥ =>
                                                                      cases Prop_Outgoingᵢₑ₁ᵥ with | intro Prop_Colourᵢₑ₁ᵥ Prop_Out_Indᵢₑ₁ᵥ =>
                                                                      --
                                                                      apply Or.inr;
                                                                      apply And.intro ( by exact Or.inr trivial; );                                                 /- := Type 1 Introduction & Elimination -/
                                                                      apply And.intro ( by exact REWRITE.Get_Start_RwOutgoing out_casesᵥ; );                        /- := Start Node -/
                                                                      apply And.intro ( by rewrite [prop_eq_lvl];                                                   /- := End Node -/
                                                                                           exact Prop_Endᵢₑ₁ᵥ; );
                                                                      apply And.intro ( by rewrite [prop_pstᵥ, List.Eq_Iff_Mem_Unit] at Prop_Colourᵢₑ₁ᵥ;            /- := Colours -/
                                                                                           rewrite [Prop_Colourᵢₑ₁ᵥ];
                                                                                           exact List.Mem.tail ( RULEᵤ.CENTER.NUMBER )
                                                                                                               ( List.Mem.head RULEᵤ.CENTER.PAST ) );
                                                                      /- := Check Outgoing-Indirect Duo: -/
                                                                      cases Prop_Out_Indᵢₑ₁ᵥ with | intro Incᵢₑ₁ᵥ Prop_Out_Indᵢₑ₁ᵥ =>
                                                                      --
                                                                      apply Exists.intro Incᵢₑ₁ᵥ;
                                                                      exact ( by simp only [List.Mem_Or_Mem_Iff_Mem_Append];                   /- := path OUT.END inc [0, OUT.COLOUR] ∈ INDIRECT -/
                                                                                  apply Or.inl;
                                                                                  exact Prop_Out_Indᵢₑ₁ᵥ; );
                       | inr out_casesᵤ => have Out_Caseᵤ := REWRITE.Mem_Of_Mem_RwOutgoing out_casesᵤ;          /- := out ∈ RULEᵤ.OUTGOING -/
                                           cases Out_Caseᵤ with | intro Originalᵤ Out_Memᵤ =>
                                           have Prop_Outgoingᵤ := prop_outgoingᵤ Out_Memᵤ;                      /- := type_outgoing.check out RULEᵤ.CENTER -/
                                           cases Prop_Outgoingᵤ with
                                           | inl Prop_Outgoingₕ₁ᵤ => simp only [type_outgoing₁.check_h₁] at Prop_Outgoingₕ₁ᵤ ⊢;
                                                                     cases Prop_Outgoingₕ₁ᵤ with | intro Prop_HPTₕ₁ᵤ Prop_Outgoingₕ₁ᵤ =>
                                                                     cases Prop_Outgoingₕ₁ᵤ with | intro Prop_Startₕ₁ᵤ Prop_Outgoingₕ₁ᵤ =>
                                                                     cases Prop_Outgoingₕ₁ᵤ with | intro Prop_Endₕ₁ᵤ Prop_Colourₕ₁ᵤ =>
                                                                     --
                                                                     apply Or.inl;
                                                                     apply And.intro ( by rewrite [Bool.or_eq_true_iff];                       /- := Type 1 Hypothesis -/
                                                                                          exact Or.inl Prop_HPTₕ₁ᵤ; );
                                                                     apply And.intro ( by exact REWRITE.Get_Start_RwOutgoing out_casesᵤ; );    /- := Start Node -/
                                                                     apply And.intro ( by exact Prop_Endₕ₁ᵤ; );                                /- := End Node -/
                                                                     exact Prop_Colourₕ₁ᵤ;                                                     /- := Colours -/
                                           | inr Prop_Outgoingᵢₑ₁ᵤ => simp only [type_outgoing₁.check_ie₁] at Prop_Outgoingᵢₑ₁ᵤ ⊢;
                                                                      cases Prop_Outgoingᵢₑ₁ᵤ with | intro Prop_HPTᵢₑ₁ᵤ Prop_Outgoingᵢₑ₁ᵤ =>
                                                                      cases Prop_Outgoingᵢₑ₁ᵤ with | intro Prop_Startᵢₑ₁ᵤ Prop_Outgoingᵢₑ₁ᵤ =>
                                                                      cases Prop_Outgoingᵢₑ₁ᵤ with | intro Prop_Endᵢₑ₁ᵤ Prop_Outgoingᵢₑ₁ᵤ =>
                                                                      cases Prop_Outgoingᵢₑ₁ᵤ with | intro Prop_Colourᵢₑ₁ᵤ Prop_Out_Indᵢₑ₁ᵤ =>
                                                                      --
                                                                      apply Or.inr;
                                                                      apply And.intro ( by exact Or.inr trivial; );                                                 /- := Type 1 Introduction & Elimination -/
                                                                      apply And.intro ( by exact REWRITE.Get_Start_RwOutgoing out_casesᵤ; );                        /- := Start Node -/
                                                                      apply And.intro ( by exact Prop_Endᵢₑ₁ᵤ; );                                                   /- := End Node -/
                                                                      apply And.intro ( by rewrite [List.Eq_Or_Mem_Iff_Mem_Cons] at Prop_Colourᵢₑ₁ᵤ;                /- := Colours -/
                                                                                           cases Prop_Colourᵢₑ₁ᵤ with
                                                                                           | inl Prop_NBR_Colourᵢₑ₁ᵤ => rewrite [Prop_NBR_Colourᵢₑ₁ᵤ];
                                                                                                                        exact List.Mem.head ( RULEᵥ.CENTER.NUMBER :: RULEᵤ.CENTER.PAST );
                                                                                           | inr Prop_PST_Colourᵢₑ₁ᵤ => exact List.Mem.tail ( RULEᵤ.CENTER.NUMBER )
                                                                                                                                            ( List.Mem.tail RULEᵥ.CENTER.NUMBER Prop_PST_Colourᵢₑ₁ᵤ ); );
                                                                      /- := Check Outgoing-Indirect Duo: -/
                                                                      cases Prop_Out_Indᵢₑ₁ᵤ with | intro Incᵢₑ₁ᵤ Prop_Out_Indᵢₑ₁ᵤ =>
                                                                      --
                                                                      apply Exists.intro Incᵢₑ₁ᵤ;
                                                                      exact ( by simp only [List.Mem_Or_Mem_Iff_Mem_Append];                   /- := path OUT.END inc [0, OUT.COLOUR] ∈ INDIRECT -/
                                                                                  apply Or.inr;
                                                                                  exact Prop_Out_Indᵢₑ₁ᵤ; ); );
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  /- Indirect Paths -/------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  simp only [type_indirect] at prop_indirectᵤ prop_indirectᵥ ⊢;
  simp only [List.Mem_Or_Mem_Iff_Mem_Append];
  intro ind ind_cases;
  cases ind_cases with
  | inl ind_casesᵥ => have Prop_Indirectᵥ := prop_indirectᵥ ind_casesᵥ;
                      simp only [type_indirect.check] at Prop_Indirectᵥ ⊢;
                      cases Prop_Indirectᵥ with | intro Prop_Startᵥ Prop_Indirectᵥ =>
                      cases Prop_Indirectᵥ with | intro Prop_Endᵥ Prop_Indirectᵥ =>
                      cases Prop_Indirectᵥ with | intro Prop_Levelᵥ Prop_Indirectᵥ =>
                      cases Prop_Indirectᵥ with | intro Colourᵥ Prop_Indirectᵥ =>
                      cases Prop_Indirectᵥ with | intro Coloursᵥ Prop_Indirectᵥ =>
                      cases Prop_Indirectᵥ with | intro Prop_Check_Coloursᵥ Prop_Indirectᵥ =>
                      cases Prop_Indirectᵥ with | intro Prop_Colourᵥ Prop_Indirectᵥ =>
                      cases Prop_Indirectᵥ with | intro Prop_Coloursᵥ Prop_Indirectᵥ =>
                      cases Prop_Indirectᵥ with | intro Prop_Ind_Incᵥ Prop_Ind_Outᵥ =>
                      --
                      apply And.intro ( by rewrite [prop_eq_lvl];         /- := Start Node -/
                                           exact Prop_Startᵥ; );
                      apply And.intro ( by rewrite [prop_eq_lvl];         /- := End Node -/
                                           exact Prop_Endᵥ; );
                      apply And.intro ( by rewrite [prop_eq_lvl];         /- := Colours -/
                                           exact Prop_Levelᵥ; );
                      apply Exists.intro Colourᵥ;
                      apply Exists.intro Coloursᵥ;
                      apply And.intro ( by exact Prop_Check_Coloursᵥ; );
                      apply And.intro ( by rewrite [prop_pstᵥ, List.Eq_Iff_Mem_Unit] at Prop_Colourᵥ;
                                           rewrite [Prop_Colourᵥ];
                                           exact List.Mem.tail ( RULEᵤ.CENTER.NUMBER )
                                                               ( List.Mem.head RULEᵤ.CENTER.PAST ); );
                      apply And.intro ( by exact Prop_Coloursᵥ; );
                      /- := Check Indirect-Incoming Duo: -/
                      cases Prop_Ind_Incᵥ with | intro Dep_Incᵥ Prop_Ind_Incᵥ =>
                      cases Prop_Ind_Incᵥ with | intro Prop_Ind_Incᵥ Prop_All_Ind_Incᵥ =>
                      --
                      apply And.intro ( by apply Exists.intro Dep_Incᵥ;
                                           apply And.intro ( by simp only [List.Mem_Or_Mem_Iff_Mem_Append];   /- := edge IND.END CENTER 0 dep_inc ∈ INCOMING -/
                                                                apply Or.inl;
                                                                rewrite [←collapse.center];
                                                                exact REWRITE.Mem_RwIncoming_Of_Mem Prop_Ind_Incᵥ; );
                                           intro all_incᵥ all_inc_casesᵥ;                                     /- := all_inc.START = IND.END ↔ all_inc = edge IND.END CENTER 0 dep_inc -/
                                           simp only [List.Mem_Or_Mem_Iff_Mem_Append] at all_inc_casesᵥ;
                                           cases all_inc_casesᵥ with
                                           | inl all_inc_casesᵥᵥ => have Ind_Inc_Casesᵥᵥ := REWRITE.Mem_Of_Mem_RwIncoming all_inc_casesᵥᵥ;                      /- := all_inc ∈ RULEᵥ.INCOMING -/
                                                                    cases Ind_Inc_Casesᵥᵥ with | intro Originalᵥ Ind_Inc_Memᵥᵥ =>
                                                                    have Prop_All_Ind_Incᵥᵥ := Prop_All_Ind_Incᵥ Ind_Inc_Memᵥᵥ;                                 /- := all_inc.START = IND.END ↔ all_inc = edge IND.END CENTER 0 dep_inc -/
                                                                    rewrite [Deduction.edge.injEq] at Prop_All_Ind_Incᵥᵥ ⊢;
                                                                    rewrite [←COLLAPSE.Simp_Inc_End (prop_incomingᵥ Ind_Inc_Memᵥᵥ)] at Prop_All_Ind_Incᵥᵥ;      /- := all_inc.END = RULEᵥ.CENTER -/
                                                                    rewrite [←REWRITE.Get_End_RwIncoming all_inc_casesᵥᵥ];                                      /- := all_inc.END = collapse.center RULEᵤ.CENTER RULEᵥ.CENTER -/
                                                                    simp only [true_and] at Prop_All_Ind_Incᵥᵥ ⊢;
                                                                    exact Prop_All_Ind_Incᵥᵥ;
                                           | inr all_inc_casesᵥᵤ => have Ind_Inc_Casesᵥᵤ := REWRITE.Mem_Of_Mem_RwIncoming all_inc_casesᵥᵤ;                      /- := all_inc ∈ RULEᵤ.INCOMING -/
                                                                    cases Ind_Inc_Casesᵥᵤ with | intro Originalᵤ Ind_Inc_Memᵥᵤ =>
                                                                    rewrite [Deduction.edge.injEq];
                                                                    have Prop_Check_Incomingᵥᵤ := prop_check_incoming Ind_Inc_Memᵥᵤ Prop_Ind_Incᵥ;              /- := all_inc.START ≠ IND.END -/
                                                                    simp only [Prop_Check_Incomingᵥᵤ, false_and]; );
                      /- := Check Indirect-Outgoing Duo: -/
                      cases Prop_Ind_Outᵥ with | intro Outᵥ Prop_Ind_Outᵥ =>
                      cases Prop_Ind_Outᵥ with | intro Dep_Outᵥ Prop_Ind_Outᵥ =>
                      cases Prop_Ind_Outᵥ with | intro Prop_Out_Colᵥ Prop_Ind_Outᵥ =>
                      cases Prop_Ind_Outᵥ with | intro Prop_Ind_Outᵥ Prop_All_Ind_Outᵥ =>
                      --
                      apply Exists.intro Outᵥ;
                      apply Exists.intro Dep_Outᵥ;
                      apply And.intro ( by exact Prop_Out_Colᵥ; );
                      apply And.intro ( by simp only [List.Mem_Or_Mem_Iff_Mem_Append];     /- := edge CENTER out colour₁ dep_out ∈ OUTGOING -/
                                           apply Or.inl;
                                           rewrite [←collapse.center];
                                           exact REWRITE.Mem_RwOutgoing_Of_Mem Prop_Ind_Outᵥ; );
                      intro all_outᵥ all_out_casesᵥ;                                       /- := all_out.COLOUR = colour₁ ↔ all_out = edge CENTER out colour₁ dep_out -/
                      simp only [List.Mem_Or_Mem_Iff_Mem_Append] at all_out_casesᵥ;
                      cases all_out_casesᵥ with
                      | inl all_out_casesᵥᵥ => have Ind_Out_Casesᵥᵥ := REWRITE.Mem_Of_Mem_RwOutgoing all_out_casesᵥᵥ;                      /- := all_out ∈ RULEᵥ.OUTGOING -/
                                               cases Ind_Out_Casesᵥᵥ with | intro Originalᵥ Ind_Out_Memᵥᵥ =>
                                               have Prop_All_Ind_Outᵥᵥ := Prop_All_Ind_Outᵥ Ind_Out_Memᵥᵥ;                                 /- := all_out.COLOUR = Colour ↔ all_out = edge CENTER out Colour dep_out -/
                                               rewrite [Deduction.edge.injEq] at Prop_All_Ind_Outᵥᵥ ⊢;
                                               rewrite [←COLLAPSE.Simp_Out_Start₁ (prop_outgoingᵥ Ind_Out_Memᵥᵥ)] at Prop_All_Ind_Outᵥᵥ;   /- := all_out.START = RULEᵥ.CENTER -/
                                               rewrite [←REWRITE.Get_Start_RwOutgoing all_out_casesᵥᵥ];                                    /- := all_out.START = collapse.center RULEᵤ.CENTER RULEᵥ.CENTER -/
                                               simp only [true_and] at Prop_All_Ind_Outᵥᵥ ⊢;
                                               exact Prop_All_Ind_Outᵥᵥ;
                      | inr all_out_casesᵥᵤ => have Ind_Out_Casesᵥᵤ := REWRITE.Mem_Of_Mem_RwOutgoing all_out_casesᵥᵤ;                      /- := all_out ∈ RULEᵤ.OUTGOING -/
                                               cases Ind_Out_Casesᵥᵤ with | intro Originalᵤ Ind_Out_Memᵥᵤ =>
                                               have Ind_Out_Colourᵥᵤ := COLLAPSE.Simp_Out_Colour₁ (prop_outgoingᵤ Ind_Out_Memᵥᵤ);          /- := all_out.COLOUR = 0 ∨ all_out.COLOUR ∈ RULEᵤ.CENTER.NUMBER :: RULEᵤ.CENTER.PAST -/
                                               simp only [prop_pstᵥ, List.Eq_Iff_Mem_Unit] at Prop_Colourᵥ;                                /- := Colour = RULEᵥ.CENTER.NUMBER -/
                                               rewrite [Deduction.edge.injEq];
                                               have NE_Colourᵥ : all_outᵥ.COLOUR ≠ Colourᵥ := by rewrite [ne_eq, ←imp_false];
                                                                                                 intro EQ_Colour;
                                                                                                 rewrite [EQ_Colour, Prop_Colourᵥ] at Ind_Out_Colourᵥᵤ;
                                                                                                 cases Ind_Out_Colourᵥᵤ with
                                                                                                 | inl EQ_Zero => apply absurd EQ_Zero;
                                                                                                                  exact Nat.ne_of_lt' prop_nbrᵥ;
                                                                                                 | inr GT_Zero => apply absurd GT_Zero;
                                                                                                                  rewrite [List.Eq_Or_Mem_Iff_Mem_Cons, not_or];
                                                                                                                  exact And.intro ( by exact Nat.ne_of_lt prop_lt_nbr; )
                                                                                                                                  ( by exact prop_ne_pst; );
                                               simp only [NE_Colourᵥ, false_and, and_false];
  | inr ind_casesᵤ => have Prop_Indirectᵤ := prop_indirectᵤ ind_casesᵤ;
                      simp only [type_indirect.check] at Prop_Indirectᵤ ⊢;
                      cases Prop_Indirectᵤ with | intro Prop_Startᵤ Prop_Indirectᵤ =>
                      cases Prop_Indirectᵤ with | intro Prop_Endᵤ Prop_Indirectᵤ =>
                      cases Prop_Indirectᵤ with | intro Prop_Levelᵤ Prop_Indirectᵤ =>
                      cases Prop_Indirectᵤ with | intro Colourᵤ Prop_Indirectᵤ =>
                      cases Prop_Indirectᵤ with | intro Coloursᵤ Prop_Indirectᵤ =>
                      cases Prop_Indirectᵤ with | intro Prop_Check_Coloursᵤ Prop_Indirectᵤ =>
                      cases Prop_Indirectᵤ with | intro Prop_Colourᵤ Prop_Indirectᵤ =>
                      cases Prop_Indirectᵤ with | intro Prop_Coloursᵤ Prop_Indirectᵤ =>
                      cases Prop_Indirectᵤ with | intro Prop_Ind_Incᵤ Prop_Ind_Outᵤ =>
                      --
                      apply And.intro ( by exact Prop_Startᵤ; );           /- := Start Node -/
                      apply And.intro ( by exact Prop_Endᵤ; );             /- := End Node -/
                      apply And.intro ( by exact Prop_Levelᵤ; );           /- := Colours -/
                      apply Exists.intro Colourᵤ;
                      apply Exists.intro Coloursᵤ;
                      apply And.intro ( by exact Prop_Check_Coloursᵤ; );
                      apply And.intro ( by rewrite [List.Eq_Or_Mem_Iff_Mem_Cons] at Prop_Colourᵤ;
                                           cases Prop_Colourᵤ with
                                           | inl Prop_NBR_Colourᵤ => rewrite [Prop_NBR_Colourᵤ];
                                                                     exact List.Mem.head ( RULEᵥ.CENTER.NUMBER :: RULEᵤ.CENTER.PAST );
                                           | inr Prop_PST_Colourᵤ => exact List.Mem.tail ( RULEᵤ.CENTER.NUMBER )
                                                                                         ( List.Mem.tail RULEᵥ.CENTER.NUMBER Prop_PST_Colourᵤ ); );
                      apply And.intro ( by exact Prop_Coloursᵤ; );
                      /- := Check Indirect-Incoming Duo: -/
                      cases Prop_Ind_Incᵤ with | intro Dep_Incᵤ Prop_Ind_Incᵤ =>
                      cases Prop_Ind_Incᵤ with | intro Prop_Ind_Incᵤ Prop_All_Ind_Incᵤ =>
                      --
                      apply And.intro ( by apply Exists.intro Dep_Incᵤ;
                                           apply And.intro ( by simp only [List.Mem_Or_Mem_Iff_Mem_Append];   /- := edge IND.END CENTER 0 dep_inc ∈ INCOMING -/
                                                                apply Or.inr;
                                                                rewrite [←collapse.center];
                                                                exact REWRITE.Mem_RwIncoming_Of_Mem Prop_Ind_Incᵤ; );
                                           intro all_incᵤ all_inc_casesᵤ;                                     /- := all_inc.START = IND.END ↔ all_inc = edge IND.END CENTER 0 dep_inc -/
                                           simp only [List.Mem_Or_Mem_Iff_Mem_Append] at all_inc_casesᵤ;
                                           cases all_inc_casesᵤ with
                                           | inl all_inc_casesᵤᵥ => have Ind_Inc_Casesᵤᵥ := REWRITE.Mem_Of_Mem_RwIncoming all_inc_casesᵤᵥ;                      /- := all_inc ∈ RULEᵥ.INCOMING -/
                                                                    cases Ind_Inc_Casesᵤᵥ with | intro Originalᵥ Ind_Inc_Memᵤᵥ =>
                                                                    rewrite [Deduction.edge.injEq];
                                                                    have Prop_Check_Incomingᵤᵥ := prop_check_incoming Prop_Ind_Incᵤ Ind_Inc_Memᵤᵥ;              /- := IND.END ≠ all_inc.START -/
                                                                    rewrite [ne_comm] at Prop_Check_Incomingᵤᵥ;
                                                                    simp only [Prop_Check_Incomingᵤᵥ, false_and];
                                           | inr all_inc_casesᵤᵤ => have Ind_Inc_Casesᵤᵤ := REWRITE.Mem_Of_Mem_RwIncoming all_inc_casesᵤᵤ;                      /- := all_inc ∈ RULEᵤ.INCOMING -/
                                                                    cases Ind_Inc_Casesᵤᵤ with | intro Originalᵤ Ind_Inc_Memᵤᵤ =>
                                                                    have Prop_All_Ind_Incᵤᵤ := Prop_All_Ind_Incᵤ Ind_Inc_Memᵤᵤ;                                 /- := all_inc.START = IND.END ↔ all_inc = edge IND.END CENTER 0 dep_inc -/
                                                                    rewrite [Deduction.edge.injEq] at Prop_All_Ind_Incᵤᵤ ⊢;
                                                                    rewrite [←COLLAPSE.Simp_Inc_End (prop_incomingᵤ Ind_Inc_Memᵤᵤ)] at Prop_All_Ind_Incᵤᵤ;      /- := all_inc.END = RULEᵤ.CENTER -/
                                                                    rewrite [←REWRITE.Get_End_RwIncoming all_inc_casesᵤᵤ];                                      /- := all_inc.END = collapse.center RULEᵤ.CENTER RULEᵥ.CENTER -/
                                                                    simp only [true_and] at Prop_All_Ind_Incᵤᵤ ⊢;
                                                                    exact Prop_All_Ind_Incᵤᵤ; );
                      /- Check Outgoing-Indirect Duo: -/
                      cases Prop_Ind_Outᵤ with | intro Outᵤ Prop_Ind_Outᵤ =>
                      cases Prop_Ind_Outᵤ with | intro Dep_Outᵤ Prop_Ind_Outᵤ =>
                      cases Prop_Ind_Outᵤ with | intro Prop_Out_Colᵤ Prop_Ind_Outᵤ =>
                      cases Prop_Ind_Outᵤ with | intro Prop_Ind_Outᵤ Prop_All_Ind_Outᵤ =>
                      --
                      apply Exists.intro Outᵤ;
                      apply Exists.intro Dep_Outᵤ;
                      apply And.intro ( by exact Prop_Out_Colᵤ; );
                      apply And.intro ( by simp only [List.Mem_Or_Mem_Iff_Mem_Append];     /- := edge CENTER out colour dep_out ∈ OUTGOING -/
                                           apply Or.inr;
                                           rewrite [←collapse.center];
                                           exact REWRITE.Mem_RwOutgoing_Of_Mem Prop_Ind_Outᵤ; );
                      intro all_outᵤ all_out_casesᵤ;                                       /- := all_out.COLOUR = colour ↔ all_out = edge CENTER out colour₁ dep_out -/
                      simp only [List.Mem_Or_Mem_Iff_Mem_Append] at all_out_casesᵤ;
                      cases all_out_casesᵤ with
                      | inl all_out_casesᵤᵥ => have Ind_Out_Casesᵤᵥ := REWRITE.Mem_Of_Mem_RwOutgoing all_out_casesᵤᵥ;                      /- := all_out ∈ RULEᵥ.OUTGOING -/
                                               cases Ind_Out_Casesᵤᵥ with | intro Originalᵥ Ind_Out_Memᵤᵥ =>
                                               have Ind_Out_Colourᵤᵥ := COLLAPSE.Simp_Out_Colour₁ (prop_outgoingᵥ Ind_Out_Memᵤᵥ);          /- := all_out.COLOUR = 0 ∨ all_out.COLOUR ∈ RULEᵥ.CENTER.NUMBER :: RULEᵥ.CENTER.PAST -/
                                               simp only [prop_pstᵥ, List.Eq_Iff_Mem_Unit] at Ind_Out_Colourᵤᵥ;
                                               rewrite [Deduction.edge.injEq];
                                               have NE_Colourᵤ : all_outᵤ.COLOUR ≠ Colourᵤ := by rewrite [ne_eq, ←imp_false];
                                                                                                 intro EQ_Colour;
                                                                                                 apply absurd Prop_Colourᵤ;              /- := Colour ∉ RULEᵤ.CENTER.NUMBER :: RULEᵤ.CENTER.PAST -/
                                                                                                 cases Ind_Out_Colourᵤᵥ with
                                                                                                 | inl EQ_Zero => rewrite [←EQ_Colour, EQ_Zero, prop_pstᵤ];
                                                                                                                  rewrite [List.Eq_Or_Mem_Iff_Mem_Cons, not_or];
                                                                                                                  exact And.intro ( by exact Nat.ne_of_lt prop_nbrᵤ; )
                                                                                                                                  ( by rewrite [←imp_false];
                                                                                                                                       intro Past_Zero;
                                                                                                                                       simp only [check_numbers] at prop_check_pastᵤ;
                                                                                                                                       cases prop_check_pastᵤ with | intro _ prop_check_pastᵤ =>
                                                                                                                                       apply absurd (prop_check_pastᵤ Past_Zero);
                                                                                                                                       trivial; );
                                                                                                 | inr GT_Zero => rewrite [←EQ_Colour, GT_Zero];
                                                                                                                  rewrite [List.Eq_Or_Mem_Iff_Mem_Cons, not_or];
                                                                                                                  exact And.intro ( by exact Nat.ne_of_lt prop_lt_nbr; )
                                                                                                                                  ( by exact prop_ne_pst; );
                                               simp only [NE_Colourᵤ, false_and, and_false];
                      | inr all_out_casesᵤᵤ => have Ind_Out_Casesᵤᵤ := REWRITE.Mem_Of_Mem_RwOutgoing all_out_casesᵤᵤ;                      /- := all_out ∈ RULEᵤ.OUTGOING -/
                                               cases Ind_Out_Casesᵤᵤ with | intro Originalᵤ Ind_Out_Memᵤᵤ =>
                                               have Prop_All_Ind_Outᵤᵤ := Prop_All_Ind_Outᵤ Ind_Out_Memᵤᵤ;                                 /- := all_out.COLOUR = Colour ↔ all_out = edge CENTER out Colour dep_out -/
                                               rewrite [Deduction.edge.injEq] at Prop_All_Ind_Outᵤᵤ ⊢;
                                               rewrite [←COLLAPSE.Simp_Out_Start₁ (prop_outgoingᵤ Ind_Out_Memᵤᵤ)] at Prop_All_Ind_Outᵤᵤ;   /- := all_out.START = RULEᵤ.CENTER -/
                                               rewrite [←REWRITE.Get_Start_RwOutgoing all_out_casesᵤᵤ];                                    /- := all_out.START = collapse.center RULEᵤ.CENTER RULEᵥ.CENTER -/
                                               simp only [true_and] at Prop_All_Ind_Outᵤᵤ ⊢;
                                               exact Prop_All_Ind_Outᵤᵤ;
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
end COVERAGE.T1_Of_T1.NODES


namespace COVERAGE.T3_Of_T3.NODES
  --333 set_option trace.Meta.Tactic.simp true
  /- Lemma: Collapse Execution (Type 2 & Type 2 => Type 3) (Nodes) -/
  theorem Col_Of_Collapse_Pre_Pre {RULEᵤ RULEᵥ : Neighborhood} :
    ( check_collapse_nodes RULEᵤ RULEᵥ ) →
    ( type3_pre_collapse RULEᵤ ) →
    ( type3_pre_collapse RULEᵥ ) →
    ---------------------------
    ( type3_collapse (collapse RULEᵤ RULEᵥ) ) := by
  intro prop_check_collapse prop_typeᵤ prop_typeᵥ;
  --
  simp only [check_collapse_nodes] at prop_check_collapse;
  cases prop_check_collapse with | intro prop_lt_nbr prop_check_collapse =>
  cases prop_check_collapse with | intro prop_ne_pst prop_check_collapse =>
  cases prop_check_collapse with | intro prop_eq_lvl prop_check_collapse =>
  cases prop_check_collapse with | intro prop_eq_fml prop_check_incoming =>
  --
  simp only [type3_pre_collapse] at prop_typeᵤ;
  cases prop_typeᵤ with | intro prop_nbrᵤ prop_typeᵤ =>
  cases prop_typeᵤ with | intro prop_lvlᵤ prop_typeᵤ =>
  cases prop_typeᵤ with | intro prop_colᵤ prop_typeᵤ =>
  cases prop_typeᵤ with | intro prop_pstᵤ prop_typeᵤ =>
  cases prop_typeᵤ with | intro prop_inc_nilᵤ prop_typeᵤ =>
  cases prop_typeᵤ with | intro prop_inc_lenᵤ prop_typeᵤ =>
  cases prop_typeᵤ with | intro prop_out_unitᵤ prop_typeᵤ =>
  cases prop_typeᵤ with | intro prop_out_coloursᵤ prop_typeᵤ =>
  cases prop_typeᵤ with | intro prop_dir_nilᵤ prop_typeᵤ =>
  cases prop_typeᵤ with | intro prop_dir_consᵤ prop_typeᵤ =>
  cases prop_typeᵤ with | intro prop_dir_unitᵤ prop_typeᵤ =>
  cases prop_typeᵤ with | intro prop_ind_startsᵤ prop_typeᵤ =>
  cases prop_typeᵤ with | intro prop_ind_lenᵤ prop_typeᵤ =>
  cases prop_typeᵤ with | intro prop_incomingᵤ prop_typeᵤ =>
  cases prop_typeᵤ with | intro prop_outgoingᵤ prop_typeᵤ =>
  cases prop_typeᵤ with | intro prop_directᵤ prop_indirectᵤ =>
  --
  cases prop_out_unitᵤ with | intro outᵤ prop_out_unitᵤ =>
  --
  simp only [type3_pre_collapse] at prop_typeᵥ;
  cases prop_typeᵥ with | intro prop_nbrᵥ prop_typeᵥ =>
  cases prop_typeᵥ with | intro prop_lvlᵥ prop_typeᵥ =>
  cases prop_typeᵥ with | intro prop_colᵥ prop_typeᵥ =>
  cases prop_typeᵥ with | intro prop_pstᵥ prop_typeᵥ =>
  cases prop_typeᵥ with | intro prop_inc_nilᵥ prop_typeᵥ =>
  cases prop_typeᵥ with | intro prop_inc_lenᵥ prop_typeᵥ =>
  cases prop_typeᵥ with | intro prop_out_unitᵥ prop_typeᵥ =>
  cases prop_typeᵥ with | intro prop_out_coloursᵥ prop_typeᵥ =>
  cases prop_typeᵥ with | intro prop_dir_nilᵥ prop_typeᵥ =>
  cases prop_typeᵥ with | intro prop_dir_consᵥ prop_typeᵥ =>
  cases prop_typeᵥ with | intro prop_dir_unitᵥ prop_typeᵥ =>
  cases prop_typeᵥ with | intro prop_ind_startsᵥ prop_typeᵥ =>
  cases prop_typeᵥ with | intro prop_ind_lenᵥ prop_typeᵥ =>
  cases prop_typeᵥ with | intro prop_incomingᵥ prop_typeᵥ =>
  cases prop_typeᵥ with | intro prop_outgoingᵥ prop_typeᵥ =>
  cases prop_typeᵥ with | intro prop_directᵥ prop_indirectᵥ =>
  --
  cases prop_out_unitᵥ with | intro outᵥ prop_out_unitᵥ =>
  --
  simp only [collapse];
  simp only [collapse.center];
  simp only [type3_collapse];
  /- Check Center-/
  apply And.intro ( by exact prop_nbrᵤ; );                                        /- := RULE.CENTER.NUMBER > 0 -/
  apply And.intro ( by exact prop_lvlᵤ; );                                        /- := RULE.CENTER.LEVEL > 0 -/
  apply And.intro ( by trivial; );                                                /- := RULE.CENTER.COLLAPSED = true -/
  apply And.intro ( by apply Exists.intro RULEᵥ.CENTER.NUMBER;                    /- := check_numbers (past :: pasts) ∧ RULE.CENTER.PAST = (past::pasts) -/
                       apply Exists.intro RULEᵤ.CENTER.PAST;
                       apply And.intro ( by simp only [prop_pstᵤ];
                                            exact COLLAPSE.Check_Numbers_Unit prop_nbrᵥ; );
                       trivial; );
  /- Check Deduction Edges -/
  apply And.intro ( by intro prop_inc_nil;                                        /- := ( RULE.INCOMING = [] ) → ( RULE.CENTER.HYPOTHESIS = true ) -/
                       simp only [List.append_eq_nil] at prop_inc_nil;
                       simp only [←List.length_eq_zero] at prop_inc_nil prop_inc_nilᵥ;
                       simp only [REWRITE.Eq_Length_RwIncoming] at prop_inc_nil;
                       simp only [prop_inc_nilᵥ] at prop_inc_nil;
                       simp only [Bool.or_eq_true];
                       exact Or.inr (And.left prop_inc_nil); );
  apply And.intro ( by simp only [prop_out_unitᵥ];                                                                    /- := RULE.OUTGOING = (out::outs) -/
                       apply Exists.intro ( edge ( collapse.center RULEᵤ.CENTER RULEᵥ.CENTER )                        /- RULEᵥ.OUTGOING -/
                                                 ( outᵥ.END )
                                                 ( outᵥ.COLOUR )
                                                 ( outᵥ.DEPENDENCY ) );
                       apply Exists.intro ( collapse.rewrite_outgoing ( collapse.center RULEᵤ.CENTER RULEᵥ.CENTER )   /- RULEᵤ.OUTGOING -/
                                                                      ( RULEᵤ.OUTGOING ) );
                       simp only [collapse.rewrite_outgoing];
                       simp only [collapse.center];
                       trivial; );
  apply And.intro ( by intro out₁ out₂ out_mem₁ out_mem₂ gt_zero₁₂;                          /- := OUT₁.COLOUR = OUT₂.COLOUR ↔ OUT₁ = OUT₂ -/
                       rewrite [prop_out_unitᵥ] at out_mem₁ out_mem₂;
                       simp only [collapse.rewrite_outgoing] at out_mem₁ out_mem₂;
                       simp only [List.Mem_Or_Mem_Iff_Mem_Append] at out_mem₁ out_mem₂;
                       simp only [List.Eq_Iff_Mem_Unit] at out_mem₁ out_mem₂;
                       simp only [Deduction.edge.injEq'];
                       --
                       simp only [type_outgoing₃] at prop_outgoingᵤ prop_outgoingᵥ;
                       rewrite [prop_out_unitᵥ] at prop_outgoingᵥ;
                       have Out_Colourᵥ := COLLAPSE.Simp_Out_Colour₃ (prop_outgoingᵥ (List.Mem.head []));
                       simp only [prop_pstᵥ, List.Eq_Iff_Mem_Unit] at Out_Colourᵥ;
                       --
                       cases out_mem₁ with
                       | inl out_mem₁ᵥ => cases out_mem₂ with
                                          | inl out_mem₂ᵥ => rewrite [out_mem₁ᵥ, out_mem₂ᵥ]; simp only [true_and];
                                          | inr out_mem₂ᵤ => rewrite [out_mem₁ᵥ] at gt_zero₁₂ ⊢;                              /- := out₁ = outᵥ -/
                                                             rewrite [REWRITE.Get_Start_RwOutgoing out_mem₂ᵤ];                /- := out₂.START = collapse.center RULEᵤ.CENTER RULEᵥ.CENTER -/
                                                             --
                                                             have Out_Cases₂ᵤ := REWRITE.Mem_Of_Mem_RwOutgoing out_mem₂ᵤ;                 /- := out₂ ∈ RULEᵥ.OUTGOING -/
                                                             cases Out_Cases₂ᵤ with | intro Originalᵤ Out_Mem₂ᵤ =>
                                                             have Out_Colour₂ᵤ := COLLAPSE.Simp_Out_Colour₃ (prop_outgoingᵤ Out_Mem₂ᵤ);   /- := out₂.COLOUR = 0 ∨ out₂.COLOUR ∈ RULEᵥ.CENTER.NUMBER :: RULEᵥ.CENTER.PAST -/
                                                             --
                                                             simp only [true_and] at gt_zero₁₂ Out_Colour₂ᵤ ⊢;
                                                             have NE_Colour : outᵥ.COLOUR ≠ out₂.COLOUR := by rewrite [ne_eq, ←imp_false];
                                                                                                              intro EQ_Colour;
                                                                                                              cases Out_Colourᵥ with
                                                                                                              | inl EQ_Zeroᵥ => apply absurd gt_zero₁₂; rewrite [←EQ_Colour, EQ_Zeroᵥ]; trivial;
                                                                                                              | inr GT_Zeroᵥ => cases Out_Colour₂ᵤ with
                                                                                                                                | inl EQ_Zero₂ᵤ => apply absurd gt_zero₁₂; rewrite [EQ_Colour, EQ_Zero₂ᵤ]; trivial;
                                                                                                                                | inr GT_Zero₂ᵤ => simp only [List.Eq_Or_Mem_Iff_Mem_Cons] at GT_Zero₂ᵤ;
                                                                                                                                                   rewrite [←EQ_Colour, GT_Zeroᵥ] at GT_Zero₂ᵤ;
                                                                                                                                                   apply absurd GT_Zero₂ᵤ;
                                                                                                                                                   simp only [not_or];
                                                                                                                                                   exact And.intro ( by exact Nat.ne_of_lt prop_lt_nbr; )
                                                                                                                                                                   ( by exact prop_ne_pst; );
                                                             simp only [NE_Colour, false_and, and_false];
                       | inr out_mem₁ᵤ => cases out_mem₂ with
                                          | inl out_mem₂ᵥ => rewrite [REWRITE.Get_Start_RwOutgoing out_mem₁ᵤ];                /- := out₁.START = collapse.center RULEᵤ.CENTER RULEᵥ.CENTER -/
                                                             rewrite [out_mem₂ᵥ] at gt_zero₁₂ ⊢;                              /- := out₂ = outᵥ -/
                                                             --
                                                             have Out_Cases₁ᵤ := REWRITE.Mem_Of_Mem_RwOutgoing out_mem₁ᵤ;                 /- := out₁ ∈ RULEᵥ.OUTGOING -/
                                                             cases Out_Cases₁ᵤ with | intro Originalᵤ Out_Mem₁ᵤ =>
                                                             have Out_Colour₁ᵤ := COLLAPSE.Simp_Out_Colour₃ (prop_outgoingᵤ Out_Mem₁ᵤ);   /- := out₁.COLOUR = 0 ∨ out₁.COLOUR ∈ RULEᵥ.CENTER.NUMBER :: RULEᵥ.CENTER.PAST -/
                                                             --
                                                             simp only [true_and] at gt_zero₁₂ Out_Colour₁ᵤ ⊢;
                                                             have NE_Colour : out₁.COLOUR ≠ outᵥ.COLOUR := by rewrite [ne_eq, ←imp_false];
                                                                                                              intro EQ_Colour;
                                                                                                              cases Out_Colourᵥ with
                                                                                                              | inl EQ_Zeroᵥ => apply absurd gt_zero₁₂; rewrite [EQ_Colour, EQ_Zeroᵥ]; trivial;
                                                                                                              | inr GT_Zeroᵥ => cases Out_Colour₁ᵤ with
                                                                                                                                | inl EQ_Zero₁ᵤ => apply absurd gt_zero₁₂; rewrite [←EQ_Colour, EQ_Zero₁ᵤ]; trivial;
                                                                                                                                | inr GT_Zero₁ᵤ => simp only [List.Eq_Or_Mem_Iff_Mem_Cons] at GT_Zero₁ᵤ;
                                                                                                                                                   rewrite [EQ_Colour, GT_Zeroᵥ] at GT_Zero₁ᵤ;
                                                                                                                                                   apply absurd GT_Zero₁ᵤ;
                                                                                                                                                   simp only [not_or];
                                                                                                                                                   exact And.intro ( by exact Nat.ne_of_lt prop_lt_nbr; )
                                                                                                                                                                   ( by exact prop_ne_pst; );
                                                             simp only [NE_Colour, false_and, and_false];
                                          | inr out_mem₂ᵤ => rewrite [REWRITE.Get_Start_RwOutgoing out_mem₁ᵤ];              /- := out₁.START = collapse.center RULEᵤ.CENTER RULEᵥ.CENTER -/
                                                             rewrite [REWRITE.Get_Start_RwOutgoing out_mem₂ᵤ];              /- := out₂.START = collapse.center RULEᵤ.CENTER RULEᵥ.CENTER -/
                                                             simp only [true_and] at gt_zero₁₂ ⊢;
                                                             --
                                                             have Out_Cases₁ᵤ := REWRITE.Mem_Of_Mem_RwOutgoing out_mem₁ᵤ;               /- := out₁ ∈ RULEᵥ.OUTGOING -/
                                                             cases Out_Cases₁ᵤ with | intro Original₁ᵤ Out_Mem₁ᵤ =>
                                                             have Out_Start₁ᵤ := COLLAPSE.Simp_Out_Start₃ (prop_outgoingᵤ Out_Mem₁ᵤ);   /- := out₁.START = RULEᵤ.CENTER -/
                                                             have Out_Cases₂ᵤ := REWRITE.Mem_Of_Mem_RwOutgoing out_mem₂ᵤ;               /- := out₂ ∈ RULEᵥ.OUTGOING -/
                                                             cases Out_Cases₂ᵤ with | intro Original₂ᵤ Out_Mem₂ᵤ =>
                                                             have Out_Start₂ᵤ := COLLAPSE.Simp_Out_Start₃ (prop_outgoingᵤ Out_Mem₂ᵤ);   /- := out₂.START = RULEᵤ.CENTER -/
                                                             --
                                                             have Iff_Out_Colourᵤ := prop_out_coloursᵤ Out_Mem₁ᵤ Out_Mem₂ᵤ gt_zero₁₂;
                                                             simp only [Deduction.edge.injEq] at Out_Start₁ᵤ Out_Start₂ᵤ Iff_Out_Colourᵤ;
                                                             simp only [Out_Start₁ᵤ, Out_Start₂ᵤ, true_and] at Iff_Out_Colourᵤ;
                                                             exact Iff_Out_Colourᵤ; );
  apply And.intro ( by intro case_hpt;                                /- := ( RULE.CENTER.HYPOTHESIS = false ) → ( RULE.DIRECT = [] ) -/
                       rewrite [Bool.or_eq_false_iff] at case_hpt;
                       cases case_hpt with | intro case_hptᵤ case_hptᵥ =>
                       simp only [prop_dir_nilᵤ case_hptᵤ, prop_dir_nilᵥ case_hptᵥ];
                       simp only [collapse.rewrite_direct];
                       trivial; );
  apply And.intro ( by intro case_dir_cons;                           /- := ( RULE.DIRECT ≠ [] ) → ( RULE.CENTER.HYPOTHESIS = true ) -/
                       simp only [Bool.or_eq_true];
                       cases List.NeNil_Or_NeNil_Of_NeNil_Append case_dir_cons with
                       | inl case_dir_consᵥ => exact Or.inr (prop_dir_consᵥ (REWRITE.NeNil_RwDirect case_dir_consᵥ));
                       | inr case_dir_consᵤ => exact Or.inl (prop_dir_consᵤ (REWRITE.NeNil_RwDirect case_dir_consᵤ)); );
  apply And.intro ( by simp only [List.length_append];                /- := List.length (RULE.INDIRECT) = List.length (RULE.INCOMING) -/
                       simp only [REWRITE.Eq_Length_RwIncoming];
                       simp only [prop_ind_lenᵤ, prop_ind_lenᵥ]; );
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  /- Incoming Edges -/------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  apply And.intro ( by simp only [type_incoming] at prop_incomingᵤ prop_incomingᵥ ⊢;
                       simp only [List.Mem_Or_Mem_Iff_Mem_Append];
                       intro inc inc_cases;
                       cases inc_cases with
                       | inl inc_casesᵥ => have Inc_Caseᵥ := REWRITE.Mem_Of_Mem_RwIncoming inc_casesᵥ;            /- := inc ∈ RULEᵥ.INCOMING -/
                                           cases Inc_Caseᵥ with | intro Originalᵥ Inc_Memᵥ =>
                                           have Prop_Incomingᵥ := prop_incomingᵥ Inc_Memᵥ;                        /- := type_incoming.check inc RULEᵥ.CENTER -/
                                           simp only [type_incoming.check] at Prop_Incomingᵥ ⊢;
                                           cases Prop_Incomingᵥ with | intro Prop_Startᵥ Prop_Incomingᵥ =>
                                           cases Prop_Incomingᵥ with | intro Prop_Endᵥ Prop_Incomingᵥ =>
                                           cases Prop_Incomingᵥ with | intro Prop_Colourᵥ Prop_Inc_Indᵥ =>
                                           --
                                           apply And.intro ( by rewrite [prop_eq_lvl];                            /- := Start Node -/
                                                                exact Prop_Startᵥ; );
                                           apply And.intro ( by exact REWRITE.Get_End_RwIncoming inc_casesᵥ; );   /- := End Node -/
                                           apply And.intro ( by exact Prop_Colourᵥ; );                            /- := Colours -/
                                           /- := Check Incoming-Indirect Duo: -/
                                           cases Prop_Inc_Indᵥ with | intro Colourᵥ Prop_Inc_Indᵥ =>
                                           cases Prop_Inc_Indᵥ with | intro Coloursᵥ Prop_Inc_Indᵥ =>
                                           cases Prop_Inc_Indᵥ with | intro Ancᵥ Prop_Inc_Indᵥ =>
                                           --
                                           apply Exists.intro Colourᵥ;
                                           apply Exists.intro Coloursᵥ;
                                           apply Exists.intro Ancᵥ;
                                           exact ( by simp only [List.Mem_Or_Mem_Iff_Mem_Append];                 /- := path anc INC.START (0::colour::colours) ∈ INDIRECT -/
                                                      apply Or.inl;
                                                      exact Prop_Inc_Indᵥ; );
                       | inr inc_casesᵤ => have Inc_Caseᵤ := REWRITE.Mem_Of_Mem_RwIncoming inc_casesᵤ;            /- := inc ∈ RULEᵤ.INCOMING -/
                                           cases Inc_Caseᵤ with | intro Originalᵤ Inc_Memᵤ =>
                                           have Prop_Incomingᵤ := prop_incomingᵤ Inc_Memᵤ;                        /- := type_incoming.check inc RULEᵤ.CENTER -/
                                           simp only [type_incoming.check] at Prop_Incomingᵤ ⊢;
                                           cases Prop_Incomingᵤ with | intro Prop_Startᵤ Prop_Incomingᵤ =>
                                           cases Prop_Incomingᵤ with | intro Prop_Endᵤ Prop_Incomingᵤ =>
                                           cases Prop_Incomingᵤ with | intro Prop_Colourᵤ Prop_Inc_Indᵤ =>
                                           --
                                           apply And.intro ( by exact Prop_Startᵤ; );                             /- := Start Node -/
                                           apply And.intro ( by exact REWRITE.Get_End_RwIncoming inc_casesᵤ; );   /- := End Node -/
                                           apply And.intro ( by exact Prop_Colourᵤ; );                            /- := Colours -/
                                           /- := Check Incoming-Indirect Duo: -/
                                           cases Prop_Inc_Indᵤ with | intro Colourᵤ Prop_Inc_Indᵤ =>
                                           cases Prop_Inc_Indᵤ with | intro Coloursᵤ Prop_Inc_Indᵤ =>
                                           cases Prop_Inc_Indᵤ with | intro Ancᵤ Prop_Inc_Indᵤ =>
                                           --
                                           apply Exists.intro Colourᵤ;
                                           apply Exists.intro Coloursᵤ;
                                           apply Exists.intro Ancᵤ;
                                           exact ( by simp only [List.Mem_Or_Mem_Iff_Mem_Append];                 /- := path anc INC.START (0::colour::colours) ∈ INDIRECT -/
                                                      apply Or.inr;
                                                      exact Prop_Inc_Indᵤ; ); );
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  /- Outgoing Edges -/------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  apply And.intro ( by simp only [type_outgoing₃] at prop_outgoingᵤ prop_outgoingᵥ ⊢;
                       simp only [List.Mem_Or_Mem_Iff_Mem_Append];
                       intro out out_cases;
                       cases out_cases with
                       | inl out_casesᵥ => have Out_Caseᵥ := REWRITE.Mem_Of_Mem_RwOutgoing out_casesᵥ;          /- := out ∈ RULEᵥ.OUTGOING -/
                                           cases Out_Caseᵥ with | intro Originalᵥ Out_Memᵥ =>
                                           have Prop_Outgoingᵥ := prop_outgoingᵥ Out_Memᵥ;                      /- := type_outgoing.check out RULEᵥ.CENTER -/
                                           cases Prop_Outgoingᵥ with
                                           | inl Prop_Outgoing₁ᵥ => cases Prop_Outgoing₁ᵥ with
                                                                    | inl Prop_Outgoingₕ₁ᵥ => simp only [type_outgoing₁.check_h₁] at Prop_Outgoingₕ₁ᵥ ⊢;
                                                                                              cases Prop_Outgoingₕ₁ᵥ with | intro Prop_HPTₕ₁ᵥ Prop_Outgoingₕ₁ᵥ =>
                                                                                              cases Prop_Outgoingₕ₁ᵥ with | intro Prop_Startₕ₁ᵥ Prop_Outgoingₕ₁ᵥ =>
                                                                                              cases Prop_Outgoingₕ₁ᵥ with | intro Prop_Endₕ₁ᵥ Prop_Colourₕ₁ᵥ =>
                                                                                              --
                                                                                              apply Or.inl; apply Or.inl;
                                                                                              apply And.intro ( by rewrite [Bool.or_eq_true_iff];                       /- := Type 1 Hypothesis -/
                                                                                                                   exact Or.inr Prop_HPTₕ₁ᵥ; );
                                                                                              apply And.intro ( by exact REWRITE.Get_Start_RwOutgoing out_casesᵥ; );    /- := Start Node -/
                                                                                              apply And.intro ( by rewrite [prop_eq_lvl];                               /- := End Node -/
                                                                                                                   exact Prop_Endₕ₁ᵥ; );
                                                                                              exact Prop_Colourₕ₁ᵥ;                                                     /- := Colours -/
                                                                    | inr Prop_Outgoingᵢₑ₁ᵥ => simp only [type_outgoing₁.check_ie₁] at Prop_Outgoingᵢₑ₁ᵥ ⊢;
                                                                                               cases Prop_Outgoingᵢₑ₁ᵥ with | intro Prop_HPTᵢₑ₁ᵥ Prop_Outgoingᵢₑ₁ᵥ =>
                                                                                               cases Prop_Outgoingᵢₑ₁ᵥ with | intro Prop_Startᵢₑ₁ᵥ Prop_Outgoingᵢₑ₁ᵥ =>
                                                                                               cases Prop_Outgoingᵢₑ₁ᵥ with | intro Prop_Endᵢₑ₁ᵥ Prop_Outgoingᵢₑ₁ᵥ =>
                                                                                               cases Prop_Outgoingᵢₑ₁ᵥ with | intro Prop_Colourᵢₑ₁ᵥ Prop_Out_Indᵢₑ₁ᵥ =>
                                                                                               --
                                                                                               apply Or.inl; apply Or.inr;
                                                                                               apply And.intro ( by exact Or.inr trivial; );                                                 /- := Type 1 Introduction & Elimination -/
                                                                                               apply And.intro ( by exact REWRITE.Get_Start_RwOutgoing out_casesᵥ; );                        /- := Start Node -/
                                                                                               apply And.intro ( by rewrite [prop_eq_lvl];                                                   /- := End Node -/
                                                                                                                    exact Prop_Endᵢₑ₁ᵥ; );
                                                                                               apply And.intro ( by rewrite [prop_pstᵥ, List.Eq_Iff_Mem_Unit] at Prop_Colourᵢₑ₁ᵥ;            /- := Colours -/
                                                                                                                    rewrite [Prop_Colourᵢₑ₁ᵥ];
                                                                                                                    exact List.Mem.tail ( RULEᵤ.CENTER.NUMBER )
                                                                                                                                        ( List.Mem.head RULEᵤ.CENTER.PAST ) );
                                                                                               /- := Check Outgoing-Indirect Duo: -/
                                                                                               cases Prop_Out_Indᵢₑ₁ᵥ with | intro Incᵢₑ₁ᵥ Prop_Out_Indᵢₑ₁ᵥ =>
                                                                                               --
                                                                                               apply Exists.intro Incᵢₑ₁ᵥ;
                                                                                               exact ( by simp only [List.Mem_Or_Mem_Iff_Mem_Append];                   /- := path OUT.END inc [0, OUT.COLOUR] ∈ INDIRECT -/
                                                                                                           apply Or.inl;
                                                                                                           exact Prop_Out_Indᵢₑ₁ᵥ; );
                                           | inr Prop_Outgoing₃ᵥ => cases Prop_Outgoing₃ᵥ with
                                                                    | inl Prop_Outgoingₕ₃ᵥ => simp only [type_outgoing₃.check_h₃] at Prop_Outgoingₕ₃ᵥ ⊢;
                                                                                              cases Prop_Outgoingₕ₃ᵥ with | intro Prop_HPTₕ₃ᵥ Prop_Outgoingₕ₃ᵥ =>
                                                                                              cases Prop_Outgoingₕ₃ᵥ with | intro Prop_Startₕ₃ᵥ Prop_Outgoingₕ₃ᵥ =>
                                                                                              cases Prop_Outgoingₕ₃ᵥ with | intro Prop_Endₕ₃ᵥ Prop_Outgoingₕ₃ᵥ =>
                                                                                              cases Prop_Outgoingₕ₃ᵥ with | intro Prop_Colourₕ₃ᵥ Prop_Out_Dirₕ₃ᵥ =>
                                                                                              --
                                                                                              apply Or.inr; apply Or.inl;
                                                                                              apply And.intro ( by rewrite [Bool.or_eq_true_iff];                                            /- := Type 3 Hypothesis -/
                                                                                                                   exact Or.inr Prop_HPTₕ₃ᵥ; );
                                                                                              apply And.intro ( by exact REWRITE.Get_Start_RwOutgoing out_casesᵥ; );                         /- := Start Node -/
                                                                                              apply And.intro ( by rewrite [prop_eq_lvl];                                                    /- := End Node -/
                                                                                                                   exact Prop_Endₕ₃ᵥ; );
                                                                                              apply And.intro ( by rewrite [prop_pstᵥ, List.Eq_Iff_Mem_Unit] at Prop_Colourₕ₃ᵥ;              /- := Colours -/
                                                                                                                   rewrite [Prop_Colourₕ₃ᵥ];
                                                                                                                   exact List.Mem.tail ( RULEᵤ.CENTER.NUMBER )
                                                                                                                                       ( List.Mem.head RULEᵤ.CENTER.PAST ) );
                                                                                              /- := Check Outgoing-Direct Duo: -/
                                                                                              cases Prop_Out_Dirₕ₃ᵥ with | intro Coloursₕ₃ᵥ Prop_Out_Dirₕ₃ᵥ =>
                                                                                              cases Prop_Out_Dirₕ₃ᵥ with | intro Ancₕ₃ᵥ Prop_Out_Dirₕ₃ᵥ =>
                                                                                              --
                                                                                              apply Exists.intro Coloursₕ₃ᵥ;
                                                                                              apply Exists.intro Ancₕ₃ᵥ;
                                                                                              exact ( by simp only [List.Mem_Or_Mem_Iff_Mem_Append];                    /- := path anc CENTER (OUT.COLOUR::colours) ∈ DIRECT -/
                                                                                                         apply Or.inl;
                                                                                                         exact REWRITE.Mem_RwDirect_Of_Mem Prop_Out_Dirₕ₃ᵥ; );
                                                                    | inr Prop_Outgoingᵢₑ₃ᵥ => simp only [type_outgoing₃.check_ie₃] at Prop_Outgoingᵢₑ₃ᵥ ⊢;
                                                                                               cases Prop_Outgoingᵢₑ₃ᵥ with | intro Prop_HPTᵢₑ₃ᵥ Prop_Outgoingᵢₑ₃ᵥ =>
                                                                                               cases Prop_Outgoingᵢₑ₃ᵥ with | intro Prop_Startᵢₑ₃ᵥ Prop_Outgoingᵢₑ₃ᵥ =>
                                                                                               cases Prop_Outgoingᵢₑ₃ᵥ with | intro Prop_Endᵢₑ₃ᵥ Prop_Outgoingᵢₑ₃ᵥ =>
                                                                                               cases Prop_Outgoingᵢₑ₃ᵥ with | intro Prop_Colourᵢₑ₃ᵥ Prop_Out_Indᵢₑ₃ᵥ =>
                                                                                               --
                                                                                               apply Or.inr; apply Or.inr;
                                                                                               apply And.intro ( by exact Or.inr trivial; );                                                 /- := Type 3 Introduction & Elimination -/
                                                                                               apply And.intro ( by exact REWRITE.Get_Start_RwOutgoing out_casesᵥ; );                        /- := Start Node -/
                                                                                               apply And.intro ( by rewrite [prop_eq_lvl];                                                   /- := End Node -/
                                                                                                                    exact Prop_Endᵢₑ₃ᵥ; );
                                                                                               apply And.intro ( by rewrite [prop_pstᵥ, List.Eq_Iff_Mem_Unit] at Prop_Colourᵢₑ₃ᵥ;            /- := Colours -/
                                                                                                                    rewrite [Prop_Colourᵢₑ₃ᵥ];
                                                                                                                    exact List.Mem.tail ( RULEᵤ.CENTER.NUMBER )
                                                                                                                                        ( List.Mem.head RULEᵤ.CENTER.PAST ) );
                                                                                               /- := Check Outgoing-Indirect Duo: -/
                                                                                               cases Prop_Out_Indᵢₑ₃ᵥ with | intro Coloursᵢₑ₃ᵥ Prop_Out_Indᵢₑ₃ᵥ =>
                                                                                               cases Prop_Out_Indᵢₑ₃ᵥ with | intro Incᵢₑ₃ᵥ Prop_Out_Indᵢₑ₃ᵥ =>
                                                                                               cases Prop_Out_Indᵢₑ₃ᵥ with | intro Ancᵢₑ₃ᵥ Prop_Out_Indᵢₑ₃ᵥ =>
                                                                                               --
                                                                                               apply Exists.intro Coloursᵢₑ₃ᵥ;
                                                                                               apply Exists.intro Incᵢₑ₃ᵥ;
                                                                                               apply Exists.intro Ancᵢₑ₃ᵥ;
                                                                                               exact ( by simp only [List.Mem_Or_Mem_Iff_Mem_Append];                   /- := path anc inc (0::OUT.COLOUR::colours) ∈ INDIRECT -/
                                                                                                          apply Or.inl;
                                                                                                          exact Prop_Out_Indᵢₑ₃ᵥ; );
                       | inr out_casesᵤ => have Out_Caseᵤ := REWRITE.Mem_Of_Mem_RwOutgoing out_casesᵤ;          /- := out ∈ RULEᵤ.OUTGOING -/
                                           cases Out_Caseᵤ with | intro Originalᵤ Out_Memᵤ =>
                                           have Prop_Outgoingᵤ := prop_outgoingᵤ Out_Memᵤ;                      /- := type_outgoing.check out RULEᵤ.CENTER -/
                                           cases Prop_Outgoingᵤ with
                                           | inl Prop_Outgoing₁ᵤ => cases Prop_Outgoing₁ᵤ with
                                                                    | inl Prop_Outgoingₕ₁ᵤ => simp only [type_outgoing₁.check_h₁] at Prop_Outgoingₕ₁ᵤ ⊢;
                                                                                              cases Prop_Outgoingₕ₁ᵤ with | intro Prop_HPTₕ₁ᵤ Prop_Outgoingₕ₁ᵤ =>
                                                                                              cases Prop_Outgoingₕ₁ᵤ with | intro Prop_Startₕ₁ᵤ Prop_Outgoingₕ₁ᵤ =>
                                                                                              cases Prop_Outgoingₕ₁ᵤ with | intro Prop_Endₕ₁ᵤ Prop_Colourₕ₁ᵤ =>
                                                                                              --
                                                                                              apply Or.inl; apply Or.inl;
                                                                                              apply And.intro ( by rewrite [Bool.or_eq_true_iff];                       /- := Type 1 Hypothesis -/
                                                                                                                   exact Or.inl Prop_HPTₕ₁ᵤ; );
                                                                                              apply And.intro ( by exact REWRITE.Get_Start_RwOutgoing out_casesᵤ; );    /- := Start Node -/
                                                                                              apply And.intro ( by exact Prop_Endₕ₁ᵤ; );                                /- := End Node -/
                                                                                              exact Prop_Colourₕ₁ᵤ;                                                     /- := Colours -/
                                                                    | inr Prop_Outgoingᵢₑ₁ᵤ => simp only [type_outgoing₁.check_ie₁] at Prop_Outgoingᵢₑ₁ᵤ ⊢;
                                                                                               cases Prop_Outgoingᵢₑ₁ᵤ with | intro Prop_HPTᵢₑ₁ᵤ Prop_Outgoingᵢₑ₁ᵤ =>
                                                                                               cases Prop_Outgoingᵢₑ₁ᵤ with | intro Prop_Startᵢₑ₁ᵤ Prop_Outgoingᵢₑ₁ᵤ =>
                                                                                               cases Prop_Outgoingᵢₑ₁ᵤ with | intro Prop_Endᵢₑ₁ᵤ Prop_Outgoingᵢₑ₁ᵤ =>
                                                                                               cases Prop_Outgoingᵢₑ₁ᵤ with | intro Prop_Colourᵢₑ₁ᵤ Prop_Out_Indᵢₑ₁ᵤ =>
                                                                                               --
                                                                                               apply Or.inl; apply Or.inr;
                                                                                               apply And.intro ( by exact Or.inr trivial; );                                                 /- := Type 1 Introduction & Elimination -/
                                                                                               apply And.intro ( by exact REWRITE.Get_Start_RwOutgoing out_casesᵤ; );                        /- := Start Node -/
                                                                                               apply And.intro ( by exact Prop_Endᵢₑ₁ᵤ; );                                                   /- := End Node -/
                                                                                               apply And.intro ( by rewrite [List.Eq_Or_Mem_Iff_Mem_Cons] at Prop_Colourᵢₑ₁ᵤ;                /- := Colours -/
                                                                                                                    cases Prop_Colourᵢₑ₁ᵤ with
                                                                                                                    | inl Prop_NBR_Colourᵢₑ₁ᵤ => rewrite [Prop_NBR_Colourᵢₑ₁ᵤ];
                                                                                                                                                 exact List.Mem.head ( RULEᵥ.CENTER.NUMBER :: RULEᵤ.CENTER.PAST );
                                                                                                                    | inr Prop_PST_Colourᵢₑ₁ᵤ => exact List.Mem.tail ( RULEᵤ.CENTER.NUMBER )
                                                                                                                                                                     ( List.Mem.tail RULEᵥ.CENTER.NUMBER Prop_PST_Colourᵢₑ₁ᵤ ); );
                                                                                               /- := Check Outgoing-Indirect Duo: -/
                                                                                               cases Prop_Out_Indᵢₑ₁ᵤ with | intro Incᵢₑ₁ᵤ Prop_Out_Indᵢₑ₁ᵤ =>
                                                                                               --
                                                                                               apply Exists.intro Incᵢₑ₁ᵤ;
                                                                                               exact ( by simp only [List.Mem_Or_Mem_Iff_Mem_Append];                   /- := path OUT.END inc [0, OUT.COLOUR] ∈ INDIRECT -/
                                                                                                           apply Or.inr;
                                                                                                           exact Prop_Out_Indᵢₑ₁ᵤ; );
                                           | inr Prop_Outgoing₃ᵤ => cases Prop_Outgoing₃ᵤ with
                                                                    | inl Prop_Outgoingₕ₃ᵤ => simp only [type_outgoing₃.check_h₃] at Prop_Outgoingₕ₃ᵤ ⊢;
                                                                                              cases Prop_Outgoingₕ₃ᵤ with | intro Prop_HPTₕ₃ᵤ Prop_Outgoingₕ₃ᵤ =>
                                                                                              cases Prop_Outgoingₕ₃ᵤ with | intro Prop_Startₕ₃ᵤ Prop_Outgoingₕ₃ᵤ =>
                                                                                              cases Prop_Outgoingₕ₃ᵤ with | intro Prop_Endₕ₃ᵤ Prop_Outgoingₕ₃ᵤ =>
                                                                                              cases Prop_Outgoingₕ₃ᵤ with | intro Prop_Colourₕ₃ᵤ Prop_Out_Dirₕ₃ᵤ =>
                                                                                              --
                                                                                              apply Or.inr; apply Or.inl;
                                                                                              apply And.intro ( by rewrite [Bool.or_eq_true_iff];                       /- := Type 1 Hypothesis -/
                                                                                                                   exact Or.inl Prop_HPTₕ₃ᵤ; );
                                                                                              apply And.intro ( by exact REWRITE.Get_Start_RwOutgoing out_casesᵤ; );    /- := Start Node -/
                                                                                              apply And.intro ( by exact Prop_Endₕ₃ᵤ; );                                /- := End Node -/
                                                                                              apply And.intro ( by rewrite [List.Eq_Or_Mem_Iff_Mem_Cons] at Prop_Colourₕ₃ᵤ;                  /- := Colours -/
                                                                                                                   cases Prop_Colourₕ₃ᵤ with
                                                                                                                   | inl Prop_NBR_Colourᵢₑ₃ᵤ => rewrite [Prop_NBR_Colourᵢₑ₃ᵤ];
                                                                                                                                                exact List.Mem.head ( RULEᵥ.CENTER.NUMBER :: RULEᵤ.CENTER.PAST );
                                                                                                                   | inr Prop_PST_Colourᵢₑ₃ᵤ => exact List.Mem.tail ( RULEᵤ.CENTER.NUMBER )
                                                                                                                                                                    ( List.Mem.tail RULEᵥ.CENTER.NUMBER Prop_PST_Colourᵢₑ₃ᵤ ); );
                                                                                              /- := Check Outgoing-Direct Duo: -/
                                                                                              cases Prop_Out_Dirₕ₃ᵤ with | intro Coloursₕ₃ᵤ Prop_Out_Dirₕ₃ᵤ =>
                                                                                              cases Prop_Out_Dirₕ₃ᵤ with | intro Ancₕ₃ᵤ Prop_Out_Dirₕ₃ᵤ =>
                                                                                              --
                                                                                              apply Exists.intro Coloursₕ₃ᵤ;
                                                                                              apply Exists.intro Ancₕ₃ᵤ;
                                                                                              exact ( by simp only [List.Mem_Or_Mem_Iff_Mem_Append];                    /- := path anc CENTER (OUT.COLOUR::colours) ∈ DIRECT -/
                                                                                                         apply Or.inr;
                                                                                                         exact REWRITE.Mem_RwDirect_Of_Mem Prop_Out_Dirₕ₃ᵤ; );
                                                                    | inr Prop_Outgoingᵢₑ₃ᵤ => simp only [type_outgoing₃.check_ie₃] at Prop_Outgoingᵢₑ₃ᵤ ⊢;
                                                                                               cases Prop_Outgoingᵢₑ₃ᵤ with | intro Prop_HPTᵢₑ₃ᵤ Prop_Outgoingᵢₑ₃ᵤ =>
                                                                                               cases Prop_Outgoingᵢₑ₃ᵤ with | intro Prop_Startᵢₑ₃ᵤ Prop_Outgoingᵢₑ₃ᵤ =>
                                                                                               cases Prop_Outgoingᵢₑ₃ᵤ with | intro Prop_Endᵢₑ₃ᵤ Prop_Outgoingᵢₑ₃ᵤ =>
                                                                                               cases Prop_Outgoingᵢₑ₃ᵤ with | intro Prop_Colourᵢₑ₃ᵤ Prop_Out_Indᵢₑ₃ᵤ =>
                                                                                               --
                                                                                               apply Or.inr; apply Or.inr;
                                                                                               apply And.intro ( by exact Or.inr trivial; );                            /- := Type 1 Introduction & Elimination -/
                                                                                               apply And.intro ( by exact REWRITE.Get_Start_RwOutgoing out_casesᵤ; );   /- := Start Node -/
                                                                                               apply And.intro ( by exact Prop_Endᵢₑ₃ᵤ; );                              /- := End Node -/
                                                                                               apply And.intro ( by rewrite [List.Eq_Or_Mem_Iff_Mem_Cons] at Prop_Colourᵢₑ₃ᵤ;                /- := Colours -/
                                                                                                                    cases Prop_Colourᵢₑ₃ᵤ with
                                                                                                                    | inl Prop_NBR_Colourᵢₑ₃ᵤ => rewrite [Prop_NBR_Colourᵢₑ₃ᵤ];
                                                                                                                                                 exact List.Mem.head ( RULEᵥ.CENTER.NUMBER :: RULEᵤ.CENTER.PAST );
                                                                                                                    | inr Prop_PST_Colourᵢₑ₃ᵤ => exact List.Mem.tail ( RULEᵤ.CENTER.NUMBER )
                                                                                                                                                                     ( List.Mem.tail RULEᵥ.CENTER.NUMBER Prop_PST_Colourᵢₑ₃ᵤ ); );
                                                                                               /- := Check Outgoing-Indirect Duo: -/
                                                                                               cases Prop_Out_Indᵢₑ₃ᵤ with | intro Coloursᵢₑ₃ᵤ Prop_Out_Indᵢₑ₃ᵤ =>
                                                                                               cases Prop_Out_Indᵢₑ₃ᵤ with | intro Incᵢₑ₃ᵤ Prop_Out_Indᵢₑ₃ᵤ =>
                                                                                               cases Prop_Out_Indᵢₑ₃ᵤ with | intro Ancᵢₑ₃ᵤ Prop_Out_Indᵢₑ₃ᵤ =>
                                                                                               --
                                                                                               apply Exists.intro Coloursᵢₑ₃ᵤ;
                                                                                               apply Exists.intro Incᵢₑ₃ᵤ;
                                                                                               apply Exists.intro Ancᵢₑ₃ᵤ;
                                                                                               exact ( by simp only [List.Mem_Or_Mem_Iff_Mem_Append];                   /- := path anc inc (0::OUT.COLOUR::colours) ∈ INDIRECT -/
                                                                                                          apply Or.inr;
                                                                                                          exact Prop_Out_Indᵢₑ₃ᵤ; ); );
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  /- Direct Paths -/--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  apply And.intro ( by simp only [type_direct] at prop_directᵤ prop_directᵥ ⊢;
                       simp only [List.Mem_Or_Mem_Iff_Mem_Append];
                       intro dir dir_cases;
                       cases dir_cases with
                       | inl dir_casesᵥ => have Dir_Casesᵥ := REWRITE.Mem_Of_Mem_RwDirect dir_casesᵥ;
                                           cases Dir_Casesᵥ with | intro Originalᵥ Dir_Memᵥ =>
                                           have Prop_Directᵥ := prop_directᵥ Dir_Memᵥ;
                                           simp only [type_direct.check] at Prop_Directᵥ ⊢;
                                           cases Prop_Directᵥ with | intro Prop_Startᵥ Prop_Directᵥ =>
                                           cases Prop_Directᵥ with | intro Prop_Endᵥ Prop_Directᵥ =>
                                           cases Prop_Directᵥ with | intro Prop_Levelᵥ Prop_Directᵥ =>
                                           cases Prop_Directᵥ with | intro Colour₁ᵥ Prop_Directᵥ =>
                                           cases Prop_Directᵥ with | intro Colour₂ᵥ Prop_Directᵥ =>
                                           cases Prop_Directᵥ with | intro Coloursᵥ Prop_Directᵥ =>
                                           cases Prop_Directᵥ with | intro Prop_Check_Coloursᵥ Prop_Directᵥ =>
                                           cases Prop_Directᵥ with | intro Prop_Colour₁ᵥ Prop_Directᵥ =>
                                           cases Prop_Directᵥ with | intro Prop_Coloursᵥ Prop_Dir_Outᵥ =>
                                           --
                                           apply And.intro ( by rewrite [prop_eq_lvl];                          /- := Start Node -/
                                                                exact Prop_Startᵥ; );
                                           apply And.intro ( by exact REWRITE.Get_End_RwDirect dir_casesᵥ; );   /- := End Node -/
                                           apply And.intro ( by rewrite [prop_eq_lvl];                          /- := Colours -/
                                                                exact Prop_Levelᵥ; );
                                           apply Exists.intro Colour₁ᵥ;
                                           apply Exists.intro Colour₂ᵥ;
                                           apply Exists.intro Coloursᵥ;
                                           apply And.intro ( by exact Prop_Check_Coloursᵥ; );
                                           apply And.intro ( by rewrite [prop_pstᵥ, List.Eq_Iff_Mem_Unit] at Prop_Colour₁ᵥ;
                                                                rewrite [Prop_Colour₁ᵥ];
                                                                exact List.Mem.tail ( RULEᵤ.CENTER.NUMBER )
                                                                                    ( List.Mem.head RULEᵤ.CENTER.PAST ); );
                                           apply And.intro ( by exact Prop_Coloursᵥ; );
                                           /- := Check Direct-Outgoing Duo: -/
                                           cases Prop_Dir_Outᵥ with | intro Outᵥ Prop_Dir_Outᵥ =>
                                           cases Prop_Dir_Outᵥ with | intro Dep_Outᵥ Prop_Dir_Outᵥ =>
                                           cases Prop_Dir_Outᵥ with | intro Prop_Out_Colᵥ Prop_Dir_Outᵥ =>
                                           cases Prop_Dir_Outᵥ with | intro Prop_Colour₂ᵥ Prop_Dir_Outᵥ =>
                                           cases Prop_Dir_Outᵥ with | intro Prop_Dir_Outᵥ Prop_All_Dir_Outᵥ =>
                                           --
                                           apply Exists.intro Outᵥ;
                                           apply Exists.intro Dep_Outᵥ;
                                           apply And.intro ( by exact Prop_Out_Colᵥ; );
                                           apply And.intro ( by exact Prop_Colour₂ᵥ; );
                                           apply And.intro ( by simp only [List.Mem_Or_Mem_Iff_Mem_Append];     /- := edge CENTER out colour₁ dep_out ∈ OUTGOING -/
                                                                apply Or.inl;
                                                                rewrite [←collapse.center];
                                                                exact REWRITE.Mem_RwOutgoing_Of_Mem Prop_Dir_Outᵥ; );
                                           intro all_outᵥ all_out_casesᵥ;                                       /- := all_out.COLOUR = colour₁ ↔ all_out = edge CENTER out colour₁ dep_out -/
                                           simp only [List.Mem_Or_Mem_Iff_Mem_Append] at all_out_casesᵥ;
                                           cases all_out_casesᵥ with
                                           | inl all_out_casesᵥᵥ => have Dir_Out_Casesᵥᵥ := REWRITE.Mem_Of_Mem_RwOutgoing all_out_casesᵥᵥ;                      /- := all_out ∈ RULEᵥ.OUTGOING -/
                                                                    cases Dir_Out_Casesᵥᵥ with | intro Originalᵥ Dir_Out_Memᵥᵥ =>
                                                                    have Prop_All_Dir_Outᵥᵥ := Prop_All_Dir_Outᵥ Dir_Out_Memᵥᵥ;                                 /- := all_out.COLOUR = Colour₁ ↔ all_out = edge CENTER out Colour₁ dep_out -/
                                                                    rewrite [Deduction.edge.injEq] at Prop_All_Dir_Outᵥᵥ ⊢;
                                                                    rewrite [←COLLAPSE.Simp_Out_Start₃ (prop_outgoingᵥ Dir_Out_Memᵥᵥ)] at Prop_All_Dir_Outᵥᵥ;   /- := all_out.START = RULEᵥ.CENTER -/
                                                                    rewrite [←REWRITE.Get_Start_RwOutgoing all_out_casesᵥᵥ];                                    /- := all_out.START = collapse.center RULEᵤ.CENTER RULEᵥ.CENTER -/
                                                                    simp only [true_and] at Prop_All_Dir_Outᵥᵥ ⊢;
                                                                    exact Prop_All_Dir_Outᵥᵥ;
                                           | inr all_out_casesᵥᵤ => have Dir_Out_Casesᵥᵤ := REWRITE.Mem_Of_Mem_RwOutgoing all_out_casesᵥᵤ;                      /- := all_out ∈ RULEᵤ.OUTGOING -/
                                                                    cases Dir_Out_Casesᵥᵤ with | intro Originalᵤ Dir_Out_Memᵥᵤ =>
                                                                    have Dir_Out_Colourᵥᵤ := COLLAPSE.Simp_Out_Colour₃ (prop_outgoingᵤ Dir_Out_Memᵥᵤ);          /- := all_out.COLOUR = 0 ∨ all_out.COLOUR ∈ RULEᵤ.CENTER.NUMBER :: RULEᵤ.CENTER.PAST -/
                                                                    simp only [prop_pstᵥ, List.Eq_Iff_Mem_Unit] at Prop_Colour₁ᵥ;                               /- := Colour₁ = RULEᵥ.CENTER.NUMBER -/
                                                                    rewrite [Deduction.edge.injEq];
                                                                    have NE_Colourᵥ : all_outᵥ.COLOUR ≠ Colour₁ᵥ := by rewrite [ne_eq, ←imp_false];
                                                                                                                       intro EQ_Colour;
                                                                                                                       rewrite [EQ_Colour, Prop_Colour₁ᵥ] at Dir_Out_Colourᵥᵤ;
                                                                                                                       cases Dir_Out_Colourᵥᵤ with
                                                                                                                       | inl EQ_Zero => apply absurd EQ_Zero;
                                                                                                                                        exact Nat.ne_of_lt' prop_nbrᵥ;
                                                                                                                       | inr GT_Zero => apply absurd GT_Zero;
                                                                                                                                        rewrite [List.Eq_Or_Mem_Iff_Mem_Cons, not_or];
                                                                                                                                        exact And.intro ( by exact Nat.ne_of_lt prop_lt_nbr; )
                                                                                                                                                        ( by exact prop_ne_pst; );
                                                                    simp only [NE_Colourᵥ, false_and, and_false];
                       | inr dir_casesᵤ => have Dir_Casesᵤ := REWRITE.Mem_Of_Mem_RwDirect dir_casesᵤ;
                                           cases Dir_Casesᵤ with | intro Originalᵤ Dir_Memᵤ =>
                                           have Prop_Directᵤ := prop_directᵤ Dir_Memᵤ;
                                           simp only [type_direct.check] at Prop_Directᵤ ⊢;
                                           cases Prop_Directᵤ with | intro Prop_Startᵤ Prop_Directᵤ =>
                                           cases Prop_Directᵤ with | intro Prop_Endᵤ Prop_Directᵤ =>
                                           cases Prop_Directᵤ with | intro Prop_Levelᵤ Prop_Directᵤ =>
                                           cases Prop_Directᵤ with | intro Colour₁ᵤ Prop_Directᵤ =>
                                           cases Prop_Directᵤ with | intro Colour₂ᵤ Prop_Directᵤ =>
                                           cases Prop_Directᵤ with | intro Coloursᵤ Prop_Directᵤ =>
                                           cases Prop_Directᵤ with | intro Prop_Check_Coloursᵤ Prop_Directᵤ =>
                                           cases Prop_Directᵤ with | intro Prop_Colour₁ᵤ Prop_Directᵤ =>
                                           cases Prop_Directᵤ with | intro Prop_Coloursᵤ Prop_Dir_Outᵤ =>
                                           --
                                           apply And.intro ( by exact Prop_Startᵤ; );                           /- := Start Node -/
                                           apply And.intro ( by exact REWRITE.Get_End_RwDirect dir_casesᵤ; );   /- := End Node -/
                                           apply And.intro ( by exact Prop_Levelᵤ; );                           /- := Colours -/
                                           apply Exists.intro Colour₁ᵤ;
                                           apply Exists.intro Colour₂ᵤ;
                                           apply Exists.intro Coloursᵤ;
                                           apply And.intro ( by exact Prop_Check_Coloursᵤ; );
                                           apply And.intro ( by rewrite [List.Eq_Or_Mem_Iff_Mem_Cons] at Prop_Colour₁ᵤ;
                                                                cases Prop_Colour₁ᵤ with
                                                                | inl Prop_NBR_Colour₁ᵤ => rewrite [Prop_NBR_Colour₁ᵤ];
                                                                                           exact List.Mem.head ( RULEᵥ.CENTER.NUMBER :: RULEᵤ.CENTER.PAST );
                                                                | inr Prop_PST_Colour₁ᵤ => exact List.Mem.tail ( RULEᵤ.CENTER.NUMBER )
                                                                                                              ( List.Mem.tail RULEᵥ.CENTER.NUMBER Prop_PST_Colour₁ᵤ ); );
                                           apply And.intro ( by exact Prop_Coloursᵤ; );
                                           /- := Check Direct-Outgoing Duo: -/
                                           cases Prop_Dir_Outᵤ with | intro Outᵤ Prop_Dir_Outᵤ =>
                                           cases Prop_Dir_Outᵤ with | intro Dep_Outᵤ Prop_Dir_Outᵤ =>
                                           cases Prop_Dir_Outᵤ with | intro Prop_Out_Colᵤ Prop_Dir_Outᵤ =>
                                           cases Prop_Dir_Outᵤ with | intro Prop_Colour₂ᵤ Prop_Dir_Outᵤ =>
                                           cases Prop_Dir_Outᵤ with | intro Prop_Dir_Outᵤ Prop_All_Dir_Outᵤ =>
                                           --
                                           apply Exists.intro Outᵤ;
                                           apply Exists.intro Dep_Outᵤ;
                                           apply And.intro ( by exact Prop_Out_Colᵤ; );
                                           apply And.intro ( by exact Prop_Colour₂ᵤ; );
                                           apply And.intro ( by simp only [List.Mem_Or_Mem_Iff_Mem_Append];     /- := edge CENTER out colour₁ dep_out ∈ OUTGOING -/
                                                                apply Or.inr;
                                                                rewrite [←collapse.center];
                                                                exact REWRITE.Mem_RwOutgoing_Of_Mem Prop_Dir_Outᵤ; );
                                           intro all_outᵤ all_out_casesᵤ;                                       /- := all_out.COLOUR = colour₁ ↔ all_out = edge CENTER out colour₁ dep_out -/
                                           simp only [List.Mem_Or_Mem_Iff_Mem_Append] at all_out_casesᵤ;
                                           cases all_out_casesᵤ with
                                           | inl all_out_casesᵤᵥ => have Dir_Out_Casesᵤᵥ := REWRITE.Mem_Of_Mem_RwOutgoing all_out_casesᵤᵥ;                      /- := all_out ∈ RULEᵥ.OUTGOING -/
                                                                    cases Dir_Out_Casesᵤᵥ with | intro Originalᵥ Dir_Out_Memᵤᵥ =>
                                                                    have Dir_Out_Colourᵤᵥ := COLLAPSE.Simp_Out_Colour₃ (prop_outgoingᵥ Dir_Out_Memᵤᵥ);          /- := all_out.COLOUR = 0 ∨ all_out.COLOUR ∈ RULEᵥ.CENTER.NUMBER :: RULEᵥ.CENTER.PAST -/
                                                                    simp only [prop_pstᵥ, List.Eq_Iff_Mem_Unit] at Dir_Out_Colourᵤᵥ;
                                                                    rewrite [Deduction.edge.injEq];
                                                                    have NE_Colourᵤ : all_outᵤ.COLOUR ≠ Colour₁ᵤ := by rewrite [ne_eq, ←imp_false];
                                                                                                                       intro EQ_Colour;
                                                                                                                       apply absurd Prop_Colour₁ᵤ;              /- := Colour₁ ∉ RULEᵤ.CENTER.NUMBER :: RULEᵤ.CENTER.PAST -/
                                                                                                                       cases Dir_Out_Colourᵤᵥ with
                                                                                                                       | inl EQ_Zero => rewrite [←EQ_Colour, EQ_Zero, prop_pstᵤ];
                                                                                                                                        rewrite [List.Eq_Iff_Mem_Unit];
                                                                                                                                        exact Nat.ne_of_lt prop_nbrᵤ;
                                                                                                                       | inr GT_Zero => rewrite [←EQ_Colour, GT_Zero];
                                                                                                                                        rewrite [List.Eq_Or_Mem_Iff_Mem_Cons, not_or];
                                                                                                                                        exact And.intro ( by exact Nat.ne_of_lt prop_lt_nbr; )
                                                                                                                                                        ( by exact prop_ne_pst; );
                                                                    simp only [NE_Colourᵤ, false_and, and_false];
                                           | inr all_out_casesᵤᵤ => have Dir_Out_Casesᵤᵤ := REWRITE.Mem_Of_Mem_RwOutgoing all_out_casesᵤᵤ;                      /- := all_out ∈ RULEᵤ.OUTGOING -/
                                                                    cases Dir_Out_Casesᵤᵤ with | intro Originalᵤ Dir_Out_Memᵤᵤ =>
                                                                    have Prop_All_Dir_Outᵤᵤ := Prop_All_Dir_Outᵤ Dir_Out_Memᵤᵤ;                                 /- := all_out.COLOUR = Colour₁ ↔ all_out = edge CENTER out Colour₁ dep_out -/
                                                                    rewrite [Deduction.edge.injEq] at Prop_All_Dir_Outᵤᵤ ⊢;
                                                                    rewrite [←COLLAPSE.Simp_Out_Start₃ (prop_outgoingᵤ Dir_Out_Memᵤᵤ)] at Prop_All_Dir_Outᵤᵤ;   /- := all_out.START = RULEᵤ.CENTER -/
                                                                    rewrite [←REWRITE.Get_Start_RwOutgoing all_out_casesᵤᵤ];                                    /- := all_out.START = collapse.center RULEᵤ.CENTER RULEᵥ.CENTER -/
                                                                    simp only [true_and] at Prop_All_Dir_Outᵤᵤ ⊢;
                                                                    exact Prop_All_Dir_Outᵤᵤ; );
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  /- Indirect Paths -/------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  simp only [type_indirect] at prop_indirectᵤ prop_indirectᵥ ⊢;
  simp only [List.Mem_Or_Mem_Iff_Mem_Append];
  intro ind ind_cases;
  cases ind_cases with
  | inl ind_casesᵥ => have Prop_Indirectᵥ := prop_indirectᵥ ind_casesᵥ;
                      simp only [type_indirect.check] at Prop_Indirectᵥ ⊢;
                      cases Prop_Indirectᵥ with | intro Prop_Startᵥ Prop_Indirectᵥ =>
                      cases Prop_Indirectᵥ with | intro Prop_Endᵥ Prop_Indirectᵥ =>
                      cases Prop_Indirectᵥ with | intro Prop_Levelᵥ Prop_Indirectᵥ =>
                      cases Prop_Indirectᵥ with | intro Colourᵥ Prop_Indirectᵥ =>
                      cases Prop_Indirectᵥ with | intro Coloursᵥ Prop_Indirectᵥ =>
                      cases Prop_Indirectᵥ with | intro Prop_Check_Coloursᵥ Prop_Indirectᵥ =>
                      cases Prop_Indirectᵥ with | intro Prop_Colourᵥ Prop_Indirectᵥ =>
                      cases Prop_Indirectᵥ with | intro Prop_Coloursᵥ Prop_Indirectᵥ =>
                      cases Prop_Indirectᵥ with | intro Prop_Ind_Incᵥ Prop_Ind_Outᵥ =>
                      --
                      apply And.intro ( by rewrite [prop_eq_lvl];         /- := Start Node -/
                                           exact Prop_Startᵥ; );
                      apply And.intro ( by rewrite [prop_eq_lvl];         /- := End Node -/
                                           exact Prop_Endᵥ; );
                      apply And.intro ( by rewrite [prop_eq_lvl];         /- := Colours -/
                                           exact Prop_Levelᵥ; );
                      apply Exists.intro Colourᵥ;
                      apply Exists.intro Coloursᵥ;
                      apply And.intro ( by exact Prop_Check_Coloursᵥ; );
                      apply And.intro ( by rewrite [prop_pstᵥ, List.Eq_Iff_Mem_Unit] at Prop_Colourᵥ;
                                           rewrite [Prop_Colourᵥ];
                                           exact List.Mem.tail ( RULEᵤ.CENTER.NUMBER )
                                                               ( List.Mem.head RULEᵤ.CENTER.PAST ); );
                      apply And.intro ( by exact Prop_Coloursᵥ; );
                      /- := Check Indirect-Incoming Duo: -/
                      cases Prop_Ind_Incᵥ with | intro Dep_Incᵥ Prop_Ind_Incᵥ =>
                      cases Prop_Ind_Incᵥ with | intro Prop_Ind_Incᵥ Prop_All_Ind_Incᵥ =>
                      --
                      apply And.intro ( by apply Exists.intro Dep_Incᵥ;
                                           apply And.intro ( by simp only [List.Mem_Or_Mem_Iff_Mem_Append];   /- := edge IND.END CENTER 0 dep_inc ∈ INCOMING -/
                                                                apply Or.inl;
                                                                rewrite [←collapse.center];
                                                                exact REWRITE.Mem_RwIncoming_Of_Mem Prop_Ind_Incᵥ; );
                                           intro all_incᵥ all_inc_casesᵥ;                                     /- := all_inc.START = IND.END ↔ all_inc = edge IND.END CENTER 0 dep_inc -/
                                           simp only [List.Mem_Or_Mem_Iff_Mem_Append] at all_inc_casesᵥ;
                                           cases all_inc_casesᵥ with
                                           | inl all_inc_casesᵥᵥ => have Ind_Inc_Casesᵥᵥ := REWRITE.Mem_Of_Mem_RwIncoming all_inc_casesᵥᵥ;                      /- := all_inc ∈ RULEᵥ.INCOMING -/
                                                                    cases Ind_Inc_Casesᵥᵥ with | intro Originalᵥ Ind_Inc_Memᵥᵥ =>
                                                                    have Prop_All_Ind_Incᵥᵥ := Prop_All_Ind_Incᵥ Ind_Inc_Memᵥᵥ;                                 /- := all_inc.START = IND.END ↔ all_inc = edge IND.END CENTER 0 dep_inc -/
                                                                    rewrite [Deduction.edge.injEq] at Prop_All_Ind_Incᵥᵥ ⊢;
                                                                    rewrite [←COLLAPSE.Simp_Inc_End (prop_incomingᵥ Ind_Inc_Memᵥᵥ)] at Prop_All_Ind_Incᵥᵥ;      /- := all_inc.END = RULEᵥ.CENTER -/
                                                                    rewrite [←REWRITE.Get_End_RwIncoming all_inc_casesᵥᵥ];                                      /- := all_inc.END = collapse.center RULEᵤ.CENTER RULEᵥ.CENTER -/
                                                                    simp only [true_and] at Prop_All_Ind_Incᵥᵥ ⊢;
                                                                    exact Prop_All_Ind_Incᵥᵥ;
                                           | inr all_inc_casesᵥᵤ => have Ind_Inc_Casesᵥᵤ := REWRITE.Mem_Of_Mem_RwIncoming all_inc_casesᵥᵤ;                      /- := all_inc ∈ RULEᵤ.INCOMING -/
                                                                    cases Ind_Inc_Casesᵥᵤ with | intro Originalᵤ Ind_Inc_Memᵥᵤ =>
                                                                    rewrite [Deduction.edge.injEq];
                                                                    have Prop_Check_Incomingᵥᵤ := prop_check_incoming Ind_Inc_Memᵥᵤ Prop_Ind_Incᵥ;              /- := all_inc.START ≠ IND.END -/
                                                                    simp only [Prop_Check_Incomingᵥᵤ, false_and]; );
                      /- := Check Indirect-Outgoing Duo: -/
                      cases Prop_Ind_Outᵥ with | intro Outᵥ Prop_Ind_Outᵥ =>
                      cases Prop_Ind_Outᵥ with | intro Dep_Outᵥ Prop_Ind_Outᵥ =>
                      cases Prop_Ind_Outᵥ with | intro Prop_Out_Colᵥ Prop_Ind_Outᵥ =>
                      cases Prop_Ind_Outᵥ with | intro Prop_Ind_Outᵥ Prop_All_Ind_Outᵥ =>
                      --
                      apply Exists.intro Outᵥ;
                      apply Exists.intro Dep_Outᵥ;
                      apply And.intro ( by exact Prop_Out_Colᵥ; );
                      apply And.intro ( by simp only [List.Mem_Or_Mem_Iff_Mem_Append];     /- := edge CENTER out colour₁ dep_out ∈ OUTGOING -/
                                           apply Or.inl;
                                           rewrite [←collapse.center];
                                           exact REWRITE.Mem_RwOutgoing_Of_Mem Prop_Ind_Outᵥ; );
                      intro all_outᵥ all_out_casesᵥ;                                       /- := all_out.COLOUR = colour₁ ↔ all_out = edge CENTER out colour₁ dep_out -/
                      simp only [List.Mem_Or_Mem_Iff_Mem_Append] at all_out_casesᵥ;
                      cases all_out_casesᵥ with
                      | inl all_out_casesᵥᵥ => have Ind_Out_Casesᵥᵥ := REWRITE.Mem_Of_Mem_RwOutgoing all_out_casesᵥᵥ;                      /- := all_out ∈ RULEᵥ.OUTGOING -/
                                               cases Ind_Out_Casesᵥᵥ with | intro Originalᵥ Ind_Out_Memᵥᵥ =>
                                               have Prop_All_Ind_Outᵥᵥ := Prop_All_Ind_Outᵥ Ind_Out_Memᵥᵥ;                                 /- := all_out.COLOUR = Colour ↔ all_out = edge CENTER out Colour dep_out -/
                                               rewrite [Deduction.edge.injEq] at Prop_All_Ind_Outᵥᵥ ⊢;
                                               rewrite [←COLLAPSE.Simp_Out_Start₃ (prop_outgoingᵥ Ind_Out_Memᵥᵥ)] at Prop_All_Ind_Outᵥᵥ;   /- := all_out.START = RULEᵥ.CENTER -/
                                               rewrite [←REWRITE.Get_Start_RwOutgoing all_out_casesᵥᵥ];                                    /- := all_out.START = collapse.center RULEᵤ.CENTER RULEᵥ.CENTER -/
                                               simp only [true_and] at Prop_All_Ind_Outᵥᵥ ⊢;
                                               exact Prop_All_Ind_Outᵥᵥ;
                      | inr all_out_casesᵥᵤ => have Ind_Out_Casesᵥᵤ := REWRITE.Mem_Of_Mem_RwOutgoing all_out_casesᵥᵤ;                      /- := all_out ∈ RULEᵤ.OUTGOING -/
                                               cases Ind_Out_Casesᵥᵤ with | intro Originalᵤ Ind_Out_Memᵥᵤ =>
                                               have Ind_Out_Colourᵥᵤ := COLLAPSE.Simp_Out_Colour₃ (prop_outgoingᵤ Ind_Out_Memᵥᵤ);          /- := all_out.COLOUR = 0 ∨ all_out.COLOUR ∈ RULEᵤ.CENTER.NUMBER :: RULEᵤ.CENTER.PAST -/
                                               simp only [prop_pstᵥ, List.Eq_Iff_Mem_Unit] at Prop_Colourᵥ;                                /- := Colour = RULEᵥ.CENTER.NUMBER -/
                                               rewrite [Deduction.edge.injEq];
                                               have NE_Colourᵥ : all_outᵥ.COLOUR ≠ Colourᵥ := by rewrite [ne_eq, ←imp_false];
                                                                                                 intro EQ_Colour;
                                                                                                 rewrite [EQ_Colour, Prop_Colourᵥ] at Ind_Out_Colourᵥᵤ;
                                                                                                 cases Ind_Out_Colourᵥᵤ with
                                                                                                 | inl EQ_Zero => apply absurd EQ_Zero;
                                                                                                                  exact Nat.ne_of_lt' prop_nbrᵥ;
                                                                                                 | inr GT_Zero => apply absurd GT_Zero;
                                                                                                                  rewrite [List.Eq_Or_Mem_Iff_Mem_Cons, not_or];
                                                                                                                  exact And.intro ( by exact Nat.ne_of_lt prop_lt_nbr; )
                                                                                                                                  ( by exact prop_ne_pst; );
                                               simp only [NE_Colourᵥ, false_and, and_false];
  | inr ind_casesᵤ => have Prop_Indirectᵤ := prop_indirectᵤ ind_casesᵤ;
                      simp only [type_indirect.check] at Prop_Indirectᵤ ⊢;
                      cases Prop_Indirectᵤ with | intro Prop_Startᵤ Prop_Indirectᵤ =>
                      cases Prop_Indirectᵤ with | intro Prop_Endᵤ Prop_Indirectᵤ =>
                      cases Prop_Indirectᵤ with | intro Prop_Levelᵤ Prop_Indirectᵤ =>
                      cases Prop_Indirectᵤ with | intro Colourᵤ Prop_Indirectᵤ =>
                      cases Prop_Indirectᵤ with | intro Coloursᵤ Prop_Indirectᵤ =>
                      cases Prop_Indirectᵤ with | intro Prop_Check_Coloursᵤ Prop_Indirectᵤ =>
                      cases Prop_Indirectᵤ with | intro Prop_Colourᵤ Prop_Indirectᵤ =>
                      cases Prop_Indirectᵤ with | intro Prop_Coloursᵤ Prop_Indirectᵤ =>
                      cases Prop_Indirectᵤ with | intro Prop_Ind_Incᵤ Prop_Ind_Outᵤ =>
                      --
                      apply And.intro ( by exact Prop_Startᵤ; );           /- := Start Node -/
                      apply And.intro ( by exact Prop_Endᵤ; );             /- := End Node -/
                      apply And.intro ( by exact Prop_Levelᵤ; );           /- := Colours -/
                      apply Exists.intro Colourᵤ;
                      apply Exists.intro Coloursᵤ;
                      apply And.intro ( by exact Prop_Check_Coloursᵤ; );
                      apply And.intro ( by rewrite [List.Eq_Or_Mem_Iff_Mem_Cons] at Prop_Colourᵤ;
                                           cases Prop_Colourᵤ with
                                           | inl Prop_NBR_Colourᵤ => rewrite [Prop_NBR_Colourᵤ];
                                                                     exact List.Mem.head ( RULEᵥ.CENTER.NUMBER :: RULEᵤ.CENTER.PAST );
                                           | inr Prop_PST_Colourᵤ => exact List.Mem.tail ( RULEᵤ.CENTER.NUMBER )
                                                                                         ( List.Mem.tail RULEᵥ.CENTER.NUMBER Prop_PST_Colourᵤ ); );
                      apply And.intro ( by exact Prop_Coloursᵤ; );
                      /- := Check Indirect-Incoming Duo: -/
                      cases Prop_Ind_Incᵤ with | intro Dep_Incᵤ Prop_Ind_Incᵤ =>
                      cases Prop_Ind_Incᵤ with | intro Prop_Ind_Incᵤ Prop_All_Ind_Incᵤ =>
                      --
                      apply And.intro ( by apply Exists.intro Dep_Incᵤ;
                                           apply And.intro ( by simp only [List.Mem_Or_Mem_Iff_Mem_Append];   /- := edge IND.END CENTER 0 dep_inc ∈ INCOMING -/
                                                                apply Or.inr;
                                                                rewrite [←collapse.center];
                                                                exact REWRITE.Mem_RwIncoming_Of_Mem Prop_Ind_Incᵤ; );
                                           intro all_incᵤ all_inc_casesᵤ;                                     /- := all_inc.START = IND.END ↔ all_inc = edge IND.END CENTER 0 dep_inc -/
                                           simp only [List.Mem_Or_Mem_Iff_Mem_Append] at all_inc_casesᵤ;
                                           cases all_inc_casesᵤ with
                                           | inl all_inc_casesᵤᵥ => have Ind_Inc_Casesᵤᵥ := REWRITE.Mem_Of_Mem_RwIncoming all_inc_casesᵤᵥ;                      /- := all_inc ∈ RULEᵥ.INCOMING -/
                                                                    cases Ind_Inc_Casesᵤᵥ with | intro Originalᵥ Ind_Inc_Memᵤᵥ =>
                                                                    rewrite [Deduction.edge.injEq];
                                                                    have Prop_Check_Incomingᵤᵥ := prop_check_incoming Prop_Ind_Incᵤ Ind_Inc_Memᵤᵥ;              /- := IND.END ≠ all_inc.START -/
                                                                    rewrite [ne_comm] at Prop_Check_Incomingᵤᵥ;
                                                                    simp only [Prop_Check_Incomingᵤᵥ, false_and];
                                           | inr all_inc_casesᵤᵤ => have Ind_Inc_Casesᵤᵤ := REWRITE.Mem_Of_Mem_RwIncoming all_inc_casesᵤᵤ;                      /- := all_inc ∈ RULEᵤ.INCOMING -/
                                                                    cases Ind_Inc_Casesᵤᵤ with | intro Originalᵤ Ind_Inc_Memᵤᵤ =>
                                                                    have Prop_All_Ind_Incᵤᵤ := Prop_All_Ind_Incᵤ Ind_Inc_Memᵤᵤ;                                 /- := all_inc.START = IND.END ↔ all_inc = edge IND.END CENTER 0 dep_inc -/
                                                                    rewrite [Deduction.edge.injEq] at Prop_All_Ind_Incᵤᵤ ⊢;
                                                                    rewrite [←COLLAPSE.Simp_Inc_End (prop_incomingᵤ Ind_Inc_Memᵤᵤ)] at Prop_All_Ind_Incᵤᵤ;      /- := all_inc.END = RULEᵤ.CENTER -/
                                                                    rewrite [←REWRITE.Get_End_RwIncoming all_inc_casesᵤᵤ];                                      /- := all_inc.END = collapse.center RULEᵤ.CENTER RULEᵥ.CENTER -/
                                                                    simp only [true_and] at Prop_All_Ind_Incᵤᵤ ⊢;
                                                                    exact Prop_All_Ind_Incᵤᵤ; );
                      /- Check Outgoing-Indirect Duo: -/
                      cases Prop_Ind_Outᵤ with | intro Outᵤ Prop_Ind_Outᵤ =>
                      cases Prop_Ind_Outᵤ with | intro Dep_Outᵤ Prop_Ind_Outᵤ =>
                      cases Prop_Ind_Outᵤ with | intro Prop_Out_Colᵤ Prop_Ind_Outᵤ =>
                      cases Prop_Ind_Outᵤ with | intro Prop_Ind_Outᵤ Prop_All_Ind_Outᵤ =>
                      --
                      apply Exists.intro Outᵤ;
                      apply Exists.intro Dep_Outᵤ;
                      apply And.intro ( by exact Prop_Out_Colᵤ; );
                      apply And.intro ( by simp only [List.Mem_Or_Mem_Iff_Mem_Append];     /- := edge CENTER out colour dep_out ∈ OUTGOING -/
                                           apply Or.inr;
                                           rewrite [←collapse.center];
                                           exact REWRITE.Mem_RwOutgoing_Of_Mem Prop_Ind_Outᵤ; );
                      intro all_outᵤ all_out_casesᵤ;                                       /- := all_out.COLOUR = colour ↔ all_out = edge CENTER out colour₁ dep_out -/
                      simp only [List.Mem_Or_Mem_Iff_Mem_Append] at all_out_casesᵤ;
                      cases all_out_casesᵤ with
                      | inl all_out_casesᵤᵥ => have Ind_Out_Casesᵤᵥ := REWRITE.Mem_Of_Mem_RwOutgoing all_out_casesᵤᵥ;                      /- := all_out ∈ RULEᵥ.OUTGOING -/
                                               cases Ind_Out_Casesᵤᵥ with | intro Originalᵥ Ind_Out_Memᵤᵥ =>
                                               have Ind_Out_Colourᵤᵥ := COLLAPSE.Simp_Out_Colour₃ (prop_outgoingᵥ Ind_Out_Memᵤᵥ);          /- := all_out.COLOUR = 0 ∨ all_out.COLOUR ∈ RULEᵥ.CENTER.NUMBER :: RULEᵥ.CENTER.PAST -/
                                               simp only [prop_pstᵥ, List.Eq_Iff_Mem_Unit] at Ind_Out_Colourᵤᵥ;
                                               rewrite [Deduction.edge.injEq];
                                               have NE_Colourᵤ : all_outᵤ.COLOUR ≠ Colourᵤ := by rewrite [ne_eq, ←imp_false];
                                                                                                 intro EQ_Colour;
                                                                                                 apply absurd Prop_Colourᵤ;                /- := Colour ∉ RULEᵤ.CENTER.NUMBER :: RULEᵤ.CENTER.PAST -/
                                                                                                 cases Ind_Out_Colourᵤᵥ with
                                                                                                 | inl EQ_Zero => rewrite [←EQ_Colour, EQ_Zero, prop_pstᵤ];
                                                                                                                  rewrite [List.Eq_Iff_Mem_Unit];
                                                                                                                  exact Nat.ne_of_lt prop_nbrᵤ;
                                                                                                 | inr GT_Zero => rewrite [←EQ_Colour, GT_Zero];
                                                                                                                  rewrite [List.Eq_Or_Mem_Iff_Mem_Cons, not_or];
                                                                                                                  exact And.intro ( by exact Nat.ne_of_lt prop_lt_nbr; )
                                                                                                                                  ( by exact prop_ne_pst; );
                                               simp only [NE_Colourᵤ, false_and, and_false];
                      | inr all_out_casesᵤᵤ => have Ind_Out_Casesᵤᵤ := REWRITE.Mem_Of_Mem_RwOutgoing all_out_casesᵤᵤ;                      /- := all_out ∈ RULEᵤ.OUTGOING -/
                                               cases Ind_Out_Casesᵤᵤ with | intro Originalᵤ Ind_Out_Memᵤᵤ =>
                                               have Prop_All_Ind_Outᵤᵤ := Prop_All_Ind_Outᵤ Ind_Out_Memᵤᵤ;                                 /- := all_out.COLOUR = Colour ↔ all_out = edge CENTER out Colour dep_out -/
                                               rewrite [Deduction.edge.injEq] at Prop_All_Ind_Outᵤᵤ ⊢;
                                               rewrite [←COLLAPSE.Simp_Out_Start₃ (prop_outgoingᵤ Ind_Out_Memᵤᵤ)] at Prop_All_Ind_Outᵤᵤ;   /- := all_out.START = RULEᵤ.CENTER -/
                                               rewrite [←REWRITE.Get_Start_RwOutgoing all_out_casesᵤᵤ];                                    /- := all_out.START = collapse.center RULEᵤ.CENTER RULEᵥ.CENTER -/
                                               simp only [true_and] at Prop_All_Ind_Outᵤᵤ ⊢;
                                               exact Prop_All_Ind_Outᵤᵤ;
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  /- Lemma: Collapse Execution (Type 3 & Type 2 => Type 3) (Nodes) -/
  theorem Col_Of_Collapse_Col_Pre {RULEᵤ RULEᵥ : Neighborhood} :
    ( check_collapse_nodes RULEᵤ RULEᵥ ) →
    ( type3_collapse RULEᵤ ) →
    ( type3_pre_collapse RULEᵥ ) →
    ---------------------------
    ( type3_collapse (collapse RULEᵤ RULEᵥ) ) := by
  intro prop_check_collapse prop_typeᵤ prop_typeᵥ;
  --
  simp only [check_collapse_nodes] at prop_check_collapse;
  cases prop_check_collapse with | intro prop_lt_nbr prop_check_collapse =>
  cases prop_check_collapse with | intro prop_ne_pst prop_check_collapse =>
  cases prop_check_collapse with | intro prop_eq_lvl prop_check_collapse =>
  cases prop_check_collapse with | intro prop_eq_fml prop_check_incoming =>
  --
  simp only [type3_collapse] at prop_typeᵤ;
  cases prop_typeᵤ with | intro prop_nbrᵤ prop_typeᵤ =>
  cases prop_typeᵤ with | intro prop_lvlᵤ prop_typeᵤ =>
  cases prop_typeᵤ with | intro prop_colᵤ prop_typeᵤ =>
  cases prop_typeᵤ with | intro prop_pstᵤ prop_typeᵤ =>
  cases prop_typeᵤ with | intro prop_inc_nilᵤ prop_typeᵤ =>
  cases prop_typeᵤ with | intro prop_out_consᵤ prop_typeᵤ =>
  cases prop_typeᵤ with | intro prop_out_coloursᵤ prop_typeᵤ =>
  cases prop_typeᵤ with | intro prop_dir_nilᵤ prop_typeᵤ =>
  cases prop_typeᵤ with | intro prop_dir_consᵤ prop_typeᵤ =>
  cases prop_typeᵤ with | intro prop_ind_lenᵤ prop_typeᵤ =>
  cases prop_typeᵤ with | intro prop_incomingᵤ prop_typeᵤ =>
  cases prop_typeᵤ with | intro prop_outgoingᵤ prop_typeᵤ =>
  cases prop_typeᵤ with | intro prop_directᵤ prop_indirectᵤ =>
  --
  cases prop_pstᵤ with | intro pastᵤ prop_pstᵤ =>
  cases prop_pstᵤ with | intro pastsᵤ prop_pstᵤ =>
  cases prop_pstᵤ with | intro prop_check_pastᵤ prop_pstᵤ =>
  --
  cases prop_out_consᵤ with | intro outᵤ prop_out_consᵤ =>
  cases prop_out_consᵤ with | intro outsᵤ prop_out_consᵤ =>
  --
  simp only [type3_pre_collapse] at prop_typeᵥ;
  cases prop_typeᵥ with | intro prop_nbrᵥ prop_typeᵥ =>
  cases prop_typeᵥ with | intro prop_lvlᵥ prop_typeᵥ =>
  cases prop_typeᵥ with | intro prop_colᵥ prop_typeᵥ =>
  cases prop_typeᵥ with | intro prop_pstᵥ prop_typeᵥ =>
  cases prop_typeᵥ with | intro prop_inc_nilᵥ prop_typeᵥ =>
  cases prop_typeᵥ with | intro prop_inc_lenᵥ prop_typeᵥ =>
  cases prop_typeᵥ with | intro prop_out_unitᵥ prop_typeᵥ =>
  cases prop_typeᵥ with | intro prop_out_coloursᵥ prop_typeᵥ =>
  cases prop_typeᵥ with | intro prop_dir_nilᵥ prop_typeᵥ =>
  cases prop_typeᵥ with | intro prop_dir_consᵥ prop_typeᵥ =>
  cases prop_typeᵥ with | intro prop_dir_unitᵥ prop_typeᵥ =>
  cases prop_typeᵥ with | intro prop_ind_startsᵥ prop_typeᵥ =>
  cases prop_typeᵥ with | intro prop_ind_lenᵥ prop_typeᵥ =>
  cases prop_typeᵥ with | intro prop_incomingᵥ prop_typeᵥ =>
  cases prop_typeᵥ with | intro prop_outgoingᵥ prop_typeᵥ =>
  cases prop_typeᵥ with | intro prop_directᵥ prop_indirectᵥ =>
  --
  cases prop_out_unitᵥ with | intro outᵥ prop_out_unitᵥ =>
  --
  simp only [collapse];
  simp only [collapse.center];
  simp only [type3_collapse];
  /- Check Center-/
  apply And.intro ( by exact prop_nbrᵤ; );                                        /- := RULE.CENTER.NUMBER > 0 -/
  apply And.intro ( by exact prop_lvlᵤ; );                                        /- := RULE.CENTER.LEVEL > 0 -/
  apply And.intro ( by trivial; );                                                /- := RULE.CENTER.COLLAPSED = true -/
  apply And.intro ( by apply Exists.intro RULEᵥ.CENTER.NUMBER;                    /- := check_numbers (past :: pasts) ∧ RULE.CENTER.PAST = (past::pasts) -/
                       apply Exists.intro RULEᵤ.CENTER.PAST;
                       apply And.intro ( by rewrite [prop_pstᵤ];
                                            exact COLLAPSE.Check_Numbers_Cons prop_nbrᵥ prop_check_pastᵤ; );
                       trivial; );
  /- Check Deduction Edges -/
  apply And.intro ( by intro prop_inc_nil;                                        /- := ( RULE.INCOMING = [] ) → ( RULE.CENTER.HYPOTHESIS = true ) -/
                       simp only [List.append_eq_nil] at prop_inc_nil;
                       simp only [←List.length_eq_zero] at prop_inc_nil prop_inc_nilᵥ;
                       simp only [REWRITE.Eq_Length_RwIncoming] at prop_inc_nil;
                       simp only [prop_inc_nilᵥ] at prop_inc_nil;
                       simp only [Bool.or_eq_true];
                       exact Or.inr (And.left prop_inc_nil); );
  apply And.intro ( by simp only [prop_out_unitᵥ];                                                                    /- := RULE.OUTGOING = (out::outs) -/
                       apply Exists.intro ( edge ( collapse.center RULEᵤ.CENTER RULEᵥ.CENTER )                        /- RULEᵥ.OUTGOING -/
                                                 ( outᵥ.END )
                                                 ( outᵥ.COLOUR )
                                                 ( outᵥ.DEPENDENCY ) );
                       apply Exists.intro ( collapse.rewrite_outgoing ( collapse.center RULEᵤ.CENTER RULEᵥ.CENTER )   /- RULEᵤ.OUTGOING -/
                                                                      ( RULEᵤ.OUTGOING ) );
                       simp only [collapse.rewrite_outgoing];
                       simp only [collapse.center];
                       trivial; );
  apply And.intro ( by intro out₁ out₂ out_mem₁ out_mem₂ gt_zero₁₂;                          /- := OUT₁.COLOUR = OUT₂.COLOUR ↔ OUT₁ = OUT₂ -/
                       rewrite [prop_out_unitᵥ] at out_mem₁ out_mem₂;
                       simp only [collapse.rewrite_outgoing] at out_mem₁ out_mem₂;
                       simp only [List.Mem_Or_Mem_Iff_Mem_Append] at out_mem₁ out_mem₂;
                       simp only [List.Eq_Iff_Mem_Unit] at out_mem₁ out_mem₂;
                       simp only [Deduction.edge.injEq'];
                       --
                       simp only [type_outgoing₃] at prop_outgoingᵤ prop_outgoingᵥ;
                       rewrite [prop_out_unitᵥ] at prop_outgoingᵥ;
                       have Out_Colourᵥ := COLLAPSE.Simp_Out_Colour₃ (prop_outgoingᵥ (List.Mem.head []));
                       simp only [prop_pstᵥ, List.Eq_Iff_Mem_Unit] at Out_Colourᵥ;
                       --
                       cases out_mem₁ with
                       | inl out_mem₁ᵥ => cases out_mem₂ with
                                          | inl out_mem₂ᵥ => rewrite [out_mem₁ᵥ, out_mem₂ᵥ]; simp only [true_and];
                                          | inr out_mem₂ᵤ => rewrite [out_mem₁ᵥ] at gt_zero₁₂ ⊢;                              /- := out₁ = outᵥ -/
                                                             rewrite [REWRITE.Get_Start_RwOutgoing out_mem₂ᵤ];                /- := out₂.START = collapse.center RULEᵤ.CENTER RULEᵥ.CENTER -/
                                                             --
                                                             have Out_Cases₂ᵤ := REWRITE.Mem_Of_Mem_RwOutgoing out_mem₂ᵤ;                 /- := out₂ ∈ RULEᵥ.OUTGOING -/
                                                             cases Out_Cases₂ᵤ with | intro Originalᵤ Out_Mem₂ᵤ =>
                                                             have Out_Colour₂ᵤ := COLLAPSE.Simp_Out_Colour₃ (prop_outgoingᵤ Out_Mem₂ᵤ);   /- := out₂.COLOUR = 0 ∨ out₂.COLOUR ∈ RULEᵥ.CENTER.NUMBER :: RULEᵥ.CENTER.PAST -/
                                                             --
                                                             simp only [true_and] at gt_zero₁₂ Out_Colour₂ᵤ ⊢;
                                                             have NE_Colour : outᵥ.COLOUR ≠ out₂.COLOUR := by rewrite [ne_eq, ←imp_false];
                                                                                                              intro EQ_Colour;
                                                                                                              cases Out_Colourᵥ with
                                                                                                              | inl EQ_Zeroᵥ => apply absurd gt_zero₁₂; rewrite [←EQ_Colour, EQ_Zeroᵥ]; trivial;
                                                                                                              | inr GT_Zeroᵥ => cases Out_Colour₂ᵤ with
                                                                                                                                | inl EQ_Zero₂ᵤ => apply absurd gt_zero₁₂; rewrite [EQ_Colour, EQ_Zero₂ᵤ]; trivial;
                                                                                                                                | inr GT_Zero₂ᵤ => simp only [List.Eq_Or_Mem_Iff_Mem_Cons] at GT_Zero₂ᵤ;
                                                                                                                                                   rewrite [←EQ_Colour, GT_Zeroᵥ] at GT_Zero₂ᵤ;
                                                                                                                                                   apply absurd GT_Zero₂ᵤ;
                                                                                                                                                   simp only [not_or];
                                                                                                                                                   exact And.intro ( by exact Nat.ne_of_lt prop_lt_nbr; )
                                                                                                                                                                   ( by exact prop_ne_pst; );
                                                             simp only [NE_Colour, false_and, and_false];
                       | inr out_mem₁ᵤ => cases out_mem₂ with
                                          | inl out_mem₂ᵥ => rewrite [REWRITE.Get_Start_RwOutgoing out_mem₁ᵤ];                /- := out₁.START = collapse.center RULEᵤ.CENTER RULEᵥ.CENTER -/
                                                             rewrite [out_mem₂ᵥ] at gt_zero₁₂ ⊢;                              /- := out₂ = outᵥ -/
                                                             --
                                                             have Out_Cases₁ᵤ := REWRITE.Mem_Of_Mem_RwOutgoing out_mem₁ᵤ;                 /- := out₁ ∈ RULEᵥ.OUTGOING -/
                                                             cases Out_Cases₁ᵤ with | intro Originalᵤ Out_Mem₁ᵤ =>
                                                             have Out_Colour₁ᵤ := COLLAPSE.Simp_Out_Colour₃ (prop_outgoingᵤ Out_Mem₁ᵤ);   /- := out₁.COLOUR = 0 ∨ out₁.COLOUR ∈ RULEᵥ.CENTER.NUMBER :: RULEᵥ.CENTER.PAST -/
                                                             --
                                                             simp only [true_and] at gt_zero₁₂ Out_Colour₁ᵤ ⊢;
                                                             have NE_Colour : out₁.COLOUR ≠ outᵥ.COLOUR := by rewrite [ne_eq, ←imp_false];
                                                                                                              intro EQ_Colour;
                                                                                                              cases Out_Colourᵥ with
                                                                                                              | inl EQ_Zeroᵥ => apply absurd gt_zero₁₂; rewrite [EQ_Colour, EQ_Zeroᵥ]; trivial;
                                                                                                              | inr GT_Zeroᵥ => cases Out_Colour₁ᵤ with
                                                                                                                                | inl EQ_Zero₁ᵤ => apply absurd gt_zero₁₂; rewrite [←EQ_Colour, EQ_Zero₁ᵤ]; trivial;
                                                                                                                                | inr GT_Zero₁ᵤ => simp only [List.Eq_Or_Mem_Iff_Mem_Cons] at GT_Zero₁ᵤ;
                                                                                                                                                   rewrite [EQ_Colour, GT_Zeroᵥ] at GT_Zero₁ᵤ;
                                                                                                                                                   apply absurd GT_Zero₁ᵤ;
                                                                                                                                                   simp only [not_or];
                                                                                                                                                   exact And.intro ( by exact Nat.ne_of_lt prop_lt_nbr; )
                                                                                                                                                                   ( by exact prop_ne_pst; );
                                                             simp only [NE_Colour, false_and, and_false];
                                          | inr out_mem₂ᵤ => rewrite [REWRITE.Get_Start_RwOutgoing out_mem₁ᵤ];              /- := out₁.START = collapse.center RULEᵤ.CENTER RULEᵥ.CENTER -/
                                                             rewrite [REWRITE.Get_Start_RwOutgoing out_mem₂ᵤ];              /- := out₂.START = collapse.center RULEᵤ.CENTER RULEᵥ.CENTER -/
                                                             simp only [true_and] at gt_zero₁₂ ⊢;
                                                             --
                                                             have Out_Cases₁ᵤ := REWRITE.Mem_Of_Mem_RwOutgoing out_mem₁ᵤ;               /- := out₁ ∈ RULEᵥ.OUTGOING -/
                                                             cases Out_Cases₁ᵤ with | intro Original₁ᵤ Out_Mem₁ᵤ =>
                                                             have Out_Start₁ᵤ := COLLAPSE.Simp_Out_Start₃ (prop_outgoingᵤ Out_Mem₁ᵤ);   /- := out₁.START = RULEᵤ.CENTER -/
                                                             have Out_Cases₂ᵤ := REWRITE.Mem_Of_Mem_RwOutgoing out_mem₂ᵤ;               /- := out₂ ∈ RULEᵥ.OUTGOING -/
                                                             cases Out_Cases₂ᵤ with | intro Original₂ᵤ Out_Mem₂ᵤ =>
                                                             have Out_Start₂ᵤ := COLLAPSE.Simp_Out_Start₃ (prop_outgoingᵤ Out_Mem₂ᵤ);   /- := out₂.START = RULEᵤ.CENTER -/
                                                             --
                                                             have Iff_Out_Colourᵤ := prop_out_coloursᵤ Out_Mem₁ᵤ Out_Mem₂ᵤ gt_zero₁₂;
                                                             simp only [Deduction.edge.injEq] at Out_Start₁ᵤ Out_Start₂ᵤ Iff_Out_Colourᵤ;
                                                             simp only [Out_Start₁ᵤ, Out_Start₂ᵤ, true_and] at Iff_Out_Colourᵤ;
                                                             exact Iff_Out_Colourᵤ; );
  apply And.intro ( by intro case_hpt;                                /- := ( RULE.CENTER.HYPOTHESIS = false ) → ( RULE.DIRECT = [] ) -/
                       rewrite [Bool.or_eq_false_iff] at case_hpt;
                       cases case_hpt with | intro case_hptᵤ case_hptᵥ =>
                       simp only [prop_dir_nilᵤ case_hptᵤ, prop_dir_nilᵥ case_hptᵥ];
                       simp only [collapse.rewrite_direct];
                       trivial; );
  apply And.intro ( by intro case_dir_cons;                           /- := ( RULE.DIRECT ≠ [] ) → ( RULE.CENTER.HYPOTHESIS = true ) -/
                       simp only [Bool.or_eq_true];
                       cases List.NeNil_Or_NeNil_Of_NeNil_Append case_dir_cons with
                       | inl case_dir_consᵥ => exact Or.inr (prop_dir_consᵥ (REWRITE.NeNil_RwDirect case_dir_consᵥ));
                       | inr case_dir_consᵤ => exact Or.inl (prop_dir_consᵤ (REWRITE.NeNil_RwDirect case_dir_consᵤ)); );
  apply And.intro ( by simp only [List.length_append];                /- := List.length (RULE.INDIRECT) = List.length (RULE.INCOMING) -/
                       simp only [REWRITE.Eq_Length_RwIncoming];
                       simp only [prop_ind_lenᵤ, prop_ind_lenᵥ]; );
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  /- Incoming Edges -/------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  apply And.intro ( by simp only [type_incoming] at prop_incomingᵤ prop_incomingᵥ ⊢;
                       simp only [List.Mem_Or_Mem_Iff_Mem_Append];
                       intro inc inc_cases;
                       cases inc_cases with
                       | inl inc_casesᵥ => have Inc_Caseᵥ := REWRITE.Mem_Of_Mem_RwIncoming inc_casesᵥ;            /- := inc ∈ RULEᵥ.INCOMING -/
                                           cases Inc_Caseᵥ with | intro Originalᵥ Inc_Memᵥ =>
                                           have Prop_Incomingᵥ := prop_incomingᵥ Inc_Memᵥ;                        /- := type_incoming.check inc RULEᵥ.CENTER -/
                                           simp only [type_incoming.check] at Prop_Incomingᵥ ⊢;
                                           cases Prop_Incomingᵥ with | intro Prop_Startᵥ Prop_Incomingᵥ =>
                                           cases Prop_Incomingᵥ with | intro Prop_Endᵥ Prop_Incomingᵥ =>
                                           cases Prop_Incomingᵥ with | intro Prop_Colourᵥ Prop_Inc_Indᵥ =>
                                           --
                                           apply And.intro ( by rewrite [prop_eq_lvl];                            /- := Start Node -/
                                                                exact Prop_Startᵥ; );
                                           apply And.intro ( by exact REWRITE.Get_End_RwIncoming inc_casesᵥ; );   /- := End Node -/
                                           apply And.intro ( by exact Prop_Colourᵥ; );                            /- := Colours -/
                                           /- := Check Incoming-Indirect Duo: -/
                                           cases Prop_Inc_Indᵥ with | intro Colourᵥ Prop_Inc_Indᵥ =>
                                           cases Prop_Inc_Indᵥ with | intro Coloursᵥ Prop_Inc_Indᵥ =>
                                           cases Prop_Inc_Indᵥ with | intro Ancᵥ Prop_Inc_Indᵥ =>
                                           --
                                           apply Exists.intro Colourᵥ;
                                           apply Exists.intro Coloursᵥ;
                                           apply Exists.intro Ancᵥ;
                                           exact ( by simp only [List.Mem_Or_Mem_Iff_Mem_Append];                 /- := path anc INC.START (0::colour::colours) ∈ INDIRECT -/
                                                      apply Or.inl;
                                                      exact Prop_Inc_Indᵥ; );
                       | inr inc_casesᵤ => have Inc_Caseᵤ := REWRITE.Mem_Of_Mem_RwIncoming inc_casesᵤ;            /- := inc ∈ RULEᵤ.INCOMING -/
                                           cases Inc_Caseᵤ with | intro Originalᵤ Inc_Memᵤ =>
                                           have Prop_Incomingᵤ := prop_incomingᵤ Inc_Memᵤ;                        /- := type_incoming.check inc RULEᵤ.CENTER -/
                                           simp only [type_incoming.check] at Prop_Incomingᵤ ⊢;
                                           cases Prop_Incomingᵤ with | intro Prop_Startᵤ Prop_Incomingᵤ =>
                                           cases Prop_Incomingᵤ with | intro Prop_Endᵤ Prop_Incomingᵤ =>
                                           cases Prop_Incomingᵤ with | intro Prop_Colourᵤ Prop_Inc_Indᵤ =>
                                           --
                                           apply And.intro ( by exact Prop_Startᵤ; );                             /- := Start Node -/
                                           apply And.intro ( by exact REWRITE.Get_End_RwIncoming inc_casesᵤ; );   /- := End Node -/
                                           apply And.intro ( by exact Prop_Colourᵤ; );                            /- := Colours -/
                                           /- := Check Incoming-Indirect Duo: -/
                                           cases Prop_Inc_Indᵤ with | intro Colourᵤ Prop_Inc_Indᵤ =>
                                           cases Prop_Inc_Indᵤ with | intro Coloursᵤ Prop_Inc_Indᵤ =>
                                           cases Prop_Inc_Indᵤ with | intro Ancᵤ Prop_Inc_Indᵤ =>
                                           --
                                           apply Exists.intro Colourᵤ;
                                           apply Exists.intro Coloursᵤ;
                                           apply Exists.intro Ancᵤ;
                                           exact ( by simp only [List.Mem_Or_Mem_Iff_Mem_Append];                 /- := path anc INC.START (0::colour::colours) ∈ INDIRECT -/
                                                      apply Or.inr;
                                                      exact Prop_Inc_Indᵤ; ); );
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  /- Outgoing Edges -/------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  apply And.intro ( by simp only [type_outgoing₃] at prop_outgoingᵤ prop_outgoingᵥ ⊢;
                       simp only [List.Mem_Or_Mem_Iff_Mem_Append];
                       intro out out_cases;
                       cases out_cases with
                       | inl out_casesᵥ => have Out_Caseᵥ := REWRITE.Mem_Of_Mem_RwOutgoing out_casesᵥ;          /- := out ∈ RULEᵥ.OUTGOING -/
                                           cases Out_Caseᵥ with | intro Originalᵥ Out_Memᵥ =>
                                           have Prop_Outgoingᵥ := prop_outgoingᵥ Out_Memᵥ;                      /- := type_outgoing.check out RULEᵥ.CENTER -/
                                           cases Prop_Outgoingᵥ with
                                           | inl Prop_Outgoing₁ᵥ => cases Prop_Outgoing₁ᵥ with
                                                                    | inl Prop_Outgoingₕ₁ᵥ => simp only [type_outgoing₁.check_h₁] at Prop_Outgoingₕ₁ᵥ ⊢;
                                                                                              cases Prop_Outgoingₕ₁ᵥ with | intro Prop_HPTₕ₁ᵥ Prop_Outgoingₕ₁ᵥ =>
                                                                                              cases Prop_Outgoingₕ₁ᵥ with | intro Prop_Startₕ₁ᵥ Prop_Outgoingₕ₁ᵥ =>
                                                                                              cases Prop_Outgoingₕ₁ᵥ with | intro Prop_Endₕ₁ᵥ Prop_Colourₕ₁ᵥ =>
                                                                                              --
                                                                                              apply Or.inl; apply Or.inl;
                                                                                              apply And.intro ( by rewrite [Bool.or_eq_true_iff];                       /- := Type 1 Hypothesis -/
                                                                                                                   exact Or.inr Prop_HPTₕ₁ᵥ; );
                                                                                              apply And.intro ( by exact REWRITE.Get_Start_RwOutgoing out_casesᵥ; );    /- := Start Node -/
                                                                                              apply And.intro ( by rewrite [prop_eq_lvl];                               /- := End Node -/
                                                                                                                   exact Prop_Endₕ₁ᵥ; );
                                                                                              exact Prop_Colourₕ₁ᵥ;                                                     /- := Colours -/
                                                                    | inr Prop_Outgoingᵢₑ₁ᵥ => simp only [type_outgoing₁.check_ie₁] at Prop_Outgoingᵢₑ₁ᵥ ⊢;
                                                                                               cases Prop_Outgoingᵢₑ₁ᵥ with | intro Prop_HPTᵢₑ₁ᵥ Prop_Outgoingᵢₑ₁ᵥ =>
                                                                                               cases Prop_Outgoingᵢₑ₁ᵥ with | intro Prop_Startᵢₑ₁ᵥ Prop_Outgoingᵢₑ₁ᵥ =>
                                                                                               cases Prop_Outgoingᵢₑ₁ᵥ with | intro Prop_Endᵢₑ₁ᵥ Prop_Outgoingᵢₑ₁ᵥ =>
                                                                                               cases Prop_Outgoingᵢₑ₁ᵥ with | intro Prop_Colourᵢₑ₁ᵥ Prop_Out_Indᵢₑ₁ᵥ =>
                                                                                               --
                                                                                               apply Or.inl; apply Or.inr;
                                                                                               apply And.intro ( by exact Or.inr trivial; );                                                 /- := Type 1 Introduction & Elimination -/
                                                                                               apply And.intro ( by exact REWRITE.Get_Start_RwOutgoing out_casesᵥ; );                        /- := Start Node -/
                                                                                               apply And.intro ( by rewrite [prop_eq_lvl];                                                   /- := End Node -/
                                                                                                                    exact Prop_Endᵢₑ₁ᵥ; );
                                                                                               apply And.intro ( by rewrite [prop_pstᵥ, List.Eq_Iff_Mem_Unit] at Prop_Colourᵢₑ₁ᵥ;            /- := Colours -/
                                                                                                                    rewrite [Prop_Colourᵢₑ₁ᵥ];
                                                                                                                    exact List.Mem.tail ( RULEᵤ.CENTER.NUMBER )
                                                                                                                                        ( List.Mem.head RULEᵤ.CENTER.PAST ) );
                                                                                               /- := Check Outgoing-Indirect Duo: -/
                                                                                               cases Prop_Out_Indᵢₑ₁ᵥ with | intro Incᵢₑ₁ᵥ Prop_Out_Indᵢₑ₁ᵥ =>
                                                                                               --
                                                                                               apply Exists.intro Incᵢₑ₁ᵥ;
                                                                                               exact ( by simp only [List.Mem_Or_Mem_Iff_Mem_Append];                   /- := path OUT.END inc [0, OUT.COLOUR] ∈ INDIRECT -/
                                                                                                           apply Or.inl;
                                                                                                           exact Prop_Out_Indᵢₑ₁ᵥ; );
                                           | inr Prop_Outgoing₃ᵥ => cases Prop_Outgoing₃ᵥ with
                                                                    | inl Prop_Outgoingₕ₃ᵥ => simp only [type_outgoing₃.check_h₃] at Prop_Outgoingₕ₃ᵥ ⊢;
                                                                                              cases Prop_Outgoingₕ₃ᵥ with | intro Prop_HPTₕ₃ᵥ Prop_Outgoingₕ₃ᵥ =>
                                                                                              cases Prop_Outgoingₕ₃ᵥ with | intro Prop_Startₕ₃ᵥ Prop_Outgoingₕ₃ᵥ =>
                                                                                              cases Prop_Outgoingₕ₃ᵥ with | intro Prop_Endₕ₃ᵥ Prop_Outgoingₕ₃ᵥ =>
                                                                                              cases Prop_Outgoingₕ₃ᵥ with | intro Prop_Colourₕ₃ᵥ Prop_Out_Dirₕ₃ᵥ =>
                                                                                              --
                                                                                              apply Or.inr; apply Or.inl;
                                                                                              apply And.intro ( by rewrite [Bool.or_eq_true_iff];                                            /- := Type 3 Hypothesis -/
                                                                                                                   exact Or.inr Prop_HPTₕ₃ᵥ; );
                                                                                              apply And.intro ( by exact REWRITE.Get_Start_RwOutgoing out_casesᵥ; );                         /- := Start Node -/
                                                                                              apply And.intro ( by rewrite [prop_eq_lvl];                                                    /- := End Node -/
                                                                                                                   exact Prop_Endₕ₃ᵥ; );
                                                                                              apply And.intro ( by rewrite [prop_pstᵥ, List.Eq_Iff_Mem_Unit] at Prop_Colourₕ₃ᵥ;              /- := Colours -/
                                                                                                                   rewrite [Prop_Colourₕ₃ᵥ];
                                                                                                                   exact List.Mem.tail ( RULEᵤ.CENTER.NUMBER )
                                                                                                                                       ( List.Mem.head RULEᵤ.CENTER.PAST ) );
                                                                                              /- := Check Outgoing-Direct Duo: -/
                                                                                              cases Prop_Out_Dirₕ₃ᵥ with | intro Coloursₕ₃ᵥ Prop_Out_Dirₕ₃ᵥ =>
                                                                                              cases Prop_Out_Dirₕ₃ᵥ with | intro Ancₕ₃ᵥ Prop_Out_Dirₕ₃ᵥ =>
                                                                                              --
                                                                                              apply Exists.intro Coloursₕ₃ᵥ;
                                                                                              apply Exists.intro Ancₕ₃ᵥ;
                                                                                              exact ( by simp only [List.Mem_Or_Mem_Iff_Mem_Append];                    /- := path anc CENTER (OUT.COLOUR::colours) ∈ DIRECT -/
                                                                                                         apply Or.inl;
                                                                                                         exact REWRITE.Mem_RwDirect_Of_Mem Prop_Out_Dirₕ₃ᵥ; );
                                                                    | inr Prop_Outgoingᵢₑ₃ᵥ => simp only [type_outgoing₃.check_ie₃] at Prop_Outgoingᵢₑ₃ᵥ ⊢;
                                                                                               cases Prop_Outgoingᵢₑ₃ᵥ with | intro Prop_HPTᵢₑ₃ᵥ Prop_Outgoingᵢₑ₃ᵥ =>
                                                                                               cases Prop_Outgoingᵢₑ₃ᵥ with | intro Prop_Startᵢₑ₃ᵥ Prop_Outgoingᵢₑ₃ᵥ =>
                                                                                               cases Prop_Outgoingᵢₑ₃ᵥ with | intro Prop_Endᵢₑ₃ᵥ Prop_Outgoingᵢₑ₃ᵥ =>
                                                                                               cases Prop_Outgoingᵢₑ₃ᵥ with | intro Prop_Colourᵢₑ₃ᵥ Prop_Out_Indᵢₑ₃ᵥ =>
                                                                                               --
                                                                                               apply Or.inr; apply Or.inr;
                                                                                               apply And.intro ( by exact Or.inr trivial; );                                                 /- := Type 3 Introduction & Elimination -/
                                                                                               apply And.intro ( by exact REWRITE.Get_Start_RwOutgoing out_casesᵥ; );                        /- := Start Node -/
                                                                                               apply And.intro ( by rewrite [prop_eq_lvl];                                                   /- := End Node -/
                                                                                                                    exact Prop_Endᵢₑ₃ᵥ; );
                                                                                               apply And.intro ( by rewrite [prop_pstᵥ, List.Eq_Iff_Mem_Unit] at Prop_Colourᵢₑ₃ᵥ;            /- := Colours -/
                                                                                                                    rewrite [Prop_Colourᵢₑ₃ᵥ];
                                                                                                                    exact List.Mem.tail ( RULEᵤ.CENTER.NUMBER )
                                                                                                                                        ( List.Mem.head RULEᵤ.CENTER.PAST ) );
                                                                                               /- := Check Outgoing-Indirect Duo: -/
                                                                                               cases Prop_Out_Indᵢₑ₃ᵥ with | intro Coloursᵢₑ₃ᵥ Prop_Out_Indᵢₑ₃ᵥ =>
                                                                                               cases Prop_Out_Indᵢₑ₃ᵥ with | intro Incᵢₑ₃ᵥ Prop_Out_Indᵢₑ₃ᵥ =>
                                                                                               cases Prop_Out_Indᵢₑ₃ᵥ with | intro Ancᵢₑ₃ᵥ Prop_Out_Indᵢₑ₃ᵥ =>
                                                                                               --
                                                                                               apply Exists.intro Coloursᵢₑ₃ᵥ;
                                                                                               apply Exists.intro Incᵢₑ₃ᵥ;
                                                                                               apply Exists.intro Ancᵢₑ₃ᵥ;
                                                                                               exact ( by simp only [List.Mem_Or_Mem_Iff_Mem_Append];                   /- := path anc inc (0::OUT.COLOUR::colours) ∈ INDIRECT -/
                                                                                                          apply Or.inl;
                                                                                                          exact Prop_Out_Indᵢₑ₃ᵥ; );
                       | inr out_casesᵤ => have Out_Caseᵤ := REWRITE.Mem_Of_Mem_RwOutgoing out_casesᵤ;          /- := out ∈ RULEᵤ.OUTGOING -/
                                           cases Out_Caseᵤ with | intro Originalᵤ Out_Memᵤ =>
                                           have Prop_Outgoingᵤ := prop_outgoingᵤ Out_Memᵤ;                      /- := type_outgoing.check out RULEᵤ.CENTER -/
                                           cases Prop_Outgoingᵤ with
                                           | inl Prop_Outgoing₁ᵤ => cases Prop_Outgoing₁ᵤ with
                                                                    | inl Prop_Outgoingₕ₁ᵤ => simp only [type_outgoing₁.check_h₁] at Prop_Outgoingₕ₁ᵤ ⊢;
                                                                                              cases Prop_Outgoingₕ₁ᵤ with | intro Prop_HPTₕ₁ᵤ Prop_Outgoingₕ₁ᵤ =>
                                                                                              cases Prop_Outgoingₕ₁ᵤ with | intro Prop_Startₕ₁ᵤ Prop_Outgoingₕ₁ᵤ =>
                                                                                              cases Prop_Outgoingₕ₁ᵤ with | intro Prop_Endₕ₁ᵤ Prop_Colourₕ₁ᵤ =>
                                                                                              --
                                                                                              apply Or.inl; apply Or.inl;
                                                                                              apply And.intro ( by rewrite [Bool.or_eq_true_iff];                       /- := Type 1 Hypothesis -/
                                                                                                                   exact Or.inl Prop_HPTₕ₁ᵤ; );
                                                                                              apply And.intro ( by exact REWRITE.Get_Start_RwOutgoing out_casesᵤ; );    /- := Start Node -/
                                                                                              apply And.intro ( by exact Prop_Endₕ₁ᵤ; );                                /- := End Node -/
                                                                                              exact Prop_Colourₕ₁ᵤ;                                                     /- := Colours -/
                                                                    | inr Prop_Outgoingᵢₑ₁ᵤ => simp only [type_outgoing₁.check_ie₁] at Prop_Outgoingᵢₑ₁ᵤ ⊢;
                                                                                               cases Prop_Outgoingᵢₑ₁ᵤ with | intro Prop_HPTᵢₑ₁ᵤ Prop_Outgoingᵢₑ₁ᵤ =>
                                                                                               cases Prop_Outgoingᵢₑ₁ᵤ with | intro Prop_Startᵢₑ₁ᵤ Prop_Outgoingᵢₑ₁ᵤ =>
                                                                                               cases Prop_Outgoingᵢₑ₁ᵤ with | intro Prop_Endᵢₑ₁ᵤ Prop_Outgoingᵢₑ₁ᵤ =>
                                                                                               cases Prop_Outgoingᵢₑ₁ᵤ with | intro Prop_Colourᵢₑ₁ᵤ Prop_Out_Indᵢₑ₁ᵤ =>
                                                                                               --
                                                                                               apply Or.inl; apply Or.inr;
                                                                                               apply And.intro ( by exact Or.inr trivial; );                                                 /- := Type 1 Introduction & Elimination -/
                                                                                               apply And.intro ( by exact REWRITE.Get_Start_RwOutgoing out_casesᵤ; );                        /- := Start Node -/
                                                                                               apply And.intro ( by exact Prop_Endᵢₑ₁ᵤ; );                                                   /- := End Node -/
                                                                                               apply And.intro ( by rewrite [List.Eq_Or_Mem_Iff_Mem_Cons] at Prop_Colourᵢₑ₁ᵤ;                /- := Colours -/
                                                                                                                    cases Prop_Colourᵢₑ₁ᵤ with
                                                                                                                    | inl Prop_NBR_Colourᵢₑ₁ᵤ => rewrite [Prop_NBR_Colourᵢₑ₁ᵤ];
                                                                                                                                                 exact List.Mem.head ( RULEᵥ.CENTER.NUMBER :: RULEᵤ.CENTER.PAST );
                                                                                                                    | inr Prop_PST_Colourᵢₑ₁ᵤ => exact List.Mem.tail ( RULEᵤ.CENTER.NUMBER )
                                                                                                                                                                     ( List.Mem.tail RULEᵥ.CENTER.NUMBER Prop_PST_Colourᵢₑ₁ᵤ ); );
                                                                                               /- := Check Outgoing-Indirect Duo: -/
                                                                                               cases Prop_Out_Indᵢₑ₁ᵤ with | intro Incᵢₑ₁ᵤ Prop_Out_Indᵢₑ₁ᵤ =>
                                                                                               --
                                                                                               apply Exists.intro Incᵢₑ₁ᵤ;
                                                                                               exact ( by simp only [List.Mem_Or_Mem_Iff_Mem_Append];                   /- := path OUT.END inc [0, OUT.COLOUR] ∈ INDIRECT -/
                                                                                                           apply Or.inr;
                                                                                                           exact Prop_Out_Indᵢₑ₁ᵤ; );
                                           | inr Prop_Outgoing₃ᵤ => cases Prop_Outgoing₃ᵤ with
                                                                    | inl Prop_Outgoingₕ₃ᵤ => simp only [type_outgoing₃.check_h₃] at Prop_Outgoingₕ₃ᵤ ⊢;
                                                                                              cases Prop_Outgoingₕ₃ᵤ with | intro Prop_HPTₕ₃ᵤ Prop_Outgoingₕ₃ᵤ =>
                                                                                              cases Prop_Outgoingₕ₃ᵤ with | intro Prop_Startₕ₃ᵤ Prop_Outgoingₕ₃ᵤ =>
                                                                                              cases Prop_Outgoingₕ₃ᵤ with | intro Prop_Endₕ₃ᵤ Prop_Outgoingₕ₃ᵤ =>
                                                                                              cases Prop_Outgoingₕ₃ᵤ with | intro Prop_Colourₕ₃ᵤ Prop_Out_Dirₕ₃ᵤ =>
                                                                                              --
                                                                                              apply Or.inr; apply Or.inl;
                                                                                              apply And.intro ( by rewrite [Bool.or_eq_true_iff];                       /- := Type 1 Hypothesis -/
                                                                                                                   exact Or.inl Prop_HPTₕ₃ᵤ; );
                                                                                              apply And.intro ( by exact REWRITE.Get_Start_RwOutgoing out_casesᵤ; );    /- := Start Node -/
                                                                                              apply And.intro ( by exact Prop_Endₕ₃ᵤ; );                                /- := End Node -/
                                                                                              apply And.intro ( by rewrite [List.Eq_Or_Mem_Iff_Mem_Cons] at Prop_Colourₕ₃ᵤ;                  /- := Colours -/
                                                                                                                   cases Prop_Colourₕ₃ᵤ with
                                                                                                                   | inl Prop_NBR_Colourᵢₑ₃ᵤ => rewrite [Prop_NBR_Colourᵢₑ₃ᵤ];
                                                                                                                                                exact List.Mem.head ( RULEᵥ.CENTER.NUMBER :: RULEᵤ.CENTER.PAST );
                                                                                                                   | inr Prop_PST_Colourᵢₑ₃ᵤ => exact List.Mem.tail ( RULEᵤ.CENTER.NUMBER )
                                                                                                                                                                    ( List.Mem.tail RULEᵥ.CENTER.NUMBER Prop_PST_Colourᵢₑ₃ᵤ ); );
                                                                                              /- := Check Outgoing-Direct Duo: -/
                                                                                              cases Prop_Out_Dirₕ₃ᵤ with | intro Coloursₕ₃ᵤ Prop_Out_Dirₕ₃ᵤ =>
                                                                                              cases Prop_Out_Dirₕ₃ᵤ with | intro Ancₕ₃ᵤ Prop_Out_Dirₕ₃ᵤ =>
                                                                                              --
                                                                                              apply Exists.intro Coloursₕ₃ᵤ;
                                                                                              apply Exists.intro Ancₕ₃ᵤ;
                                                                                              exact ( by simp only [List.Mem_Or_Mem_Iff_Mem_Append];                    /- := path anc CENTER (OUT.COLOUR::colours) ∈ DIRECT -/
                                                                                                         apply Or.inr;
                                                                                                         exact REWRITE.Mem_RwDirect_Of_Mem Prop_Out_Dirₕ₃ᵤ; );
                                                                    | inr Prop_Outgoingᵢₑ₃ᵤ => simp only [type_outgoing₃.check_ie₃] at Prop_Outgoingᵢₑ₃ᵤ ⊢;
                                                                                               cases Prop_Outgoingᵢₑ₃ᵤ with | intro Prop_HPTᵢₑ₃ᵤ Prop_Outgoingᵢₑ₃ᵤ =>
                                                                                               cases Prop_Outgoingᵢₑ₃ᵤ with | intro Prop_Startᵢₑ₃ᵤ Prop_Outgoingᵢₑ₃ᵤ =>
                                                                                               cases Prop_Outgoingᵢₑ₃ᵤ with | intro Prop_Endᵢₑ₃ᵤ Prop_Outgoingᵢₑ₃ᵤ =>
                                                                                               cases Prop_Outgoingᵢₑ₃ᵤ with | intro Prop_Colourᵢₑ₃ᵤ Prop_Out_Indᵢₑ₃ᵤ =>
                                                                                               --
                                                                                               apply Or.inr; apply Or.inr;
                                                                                               apply And.intro ( by exact Or.inr trivial; );                            /- := Type 1 Introduction & Elimination -/
                                                                                               apply And.intro ( by exact REWRITE.Get_Start_RwOutgoing out_casesᵤ; );   /- := Start Node -/
                                                                                               apply And.intro ( by exact Prop_Endᵢₑ₃ᵤ; );                              /- := End Node -/
                                                                                               apply And.intro ( by rewrite [List.Eq_Or_Mem_Iff_Mem_Cons] at Prop_Colourᵢₑ₃ᵤ;                /- := Colours -/
                                                                                                                    cases Prop_Colourᵢₑ₃ᵤ with
                                                                                                                    | inl Prop_NBR_Colourᵢₑ₃ᵤ => rewrite [Prop_NBR_Colourᵢₑ₃ᵤ];
                                                                                                                                                 exact List.Mem.head ( RULEᵥ.CENTER.NUMBER :: RULEᵤ.CENTER.PAST );
                                                                                                                    | inr Prop_PST_Colourᵢₑ₃ᵤ => exact List.Mem.tail ( RULEᵤ.CENTER.NUMBER )
                                                                                                                                                                     ( List.Mem.tail RULEᵥ.CENTER.NUMBER Prop_PST_Colourᵢₑ₃ᵤ ); );
                                                                                               /- := Check Outgoing-Indirect Duo: -/
                                                                                               cases Prop_Out_Indᵢₑ₃ᵤ with | intro Coloursᵢₑ₃ᵤ Prop_Out_Indᵢₑ₃ᵤ =>
                                                                                               cases Prop_Out_Indᵢₑ₃ᵤ with | intro Incᵢₑ₃ᵤ Prop_Out_Indᵢₑ₃ᵤ =>
                                                                                               cases Prop_Out_Indᵢₑ₃ᵤ with | intro Ancᵢₑ₃ᵤ Prop_Out_Indᵢₑ₃ᵤ =>
                                                                                               --
                                                                                               apply Exists.intro Coloursᵢₑ₃ᵤ;
                                                                                               apply Exists.intro Incᵢₑ₃ᵤ;
                                                                                               apply Exists.intro Ancᵢₑ₃ᵤ;
                                                                                               exact ( by simp only [List.Mem_Or_Mem_Iff_Mem_Append];                   /- := path anc inc (0::OUT.COLOUR::colours) ∈ INDIRECT -/
                                                                                                          apply Or.inr;
                                                                                                          exact Prop_Out_Indᵢₑ₃ᵤ; ); );
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  /- Direct Paths -/--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  apply And.intro ( by simp only [type_direct] at prop_directᵤ prop_directᵥ ⊢;
                       simp only [List.Mem_Or_Mem_Iff_Mem_Append];
                       intro dir dir_cases;
                       cases dir_cases with
                       | inl dir_casesᵥ => have Dir_Casesᵥ := REWRITE.Mem_Of_Mem_RwDirect dir_casesᵥ;
                                           cases Dir_Casesᵥ with | intro Originalᵥ Dir_Memᵥ =>
                                           have Prop_Directᵥ := prop_directᵥ Dir_Memᵥ;
                                           simp only [type_direct.check] at Prop_Directᵥ ⊢;
                                           cases Prop_Directᵥ with | intro Prop_Startᵥ Prop_Directᵥ =>
                                           cases Prop_Directᵥ with | intro Prop_Endᵥ Prop_Directᵥ =>
                                           cases Prop_Directᵥ with | intro Prop_Levelᵥ Prop_Directᵥ =>
                                           cases Prop_Directᵥ with | intro Colour₁ᵥ Prop_Directᵥ =>
                                           cases Prop_Directᵥ with | intro Colour₂ᵥ Prop_Directᵥ =>
                                           cases Prop_Directᵥ with | intro Coloursᵥ Prop_Directᵥ =>
                                           cases Prop_Directᵥ with | intro Prop_Check_Coloursᵥ Prop_Directᵥ =>
                                           cases Prop_Directᵥ with | intro Prop_Colour₁ᵥ Prop_Directᵥ =>
                                           cases Prop_Directᵥ with | intro Prop_Coloursᵥ Prop_Dir_Outᵥ =>
                                           --
                                           apply And.intro ( by rewrite [prop_eq_lvl];                          /- := Start Node -/
                                                                exact Prop_Startᵥ; );
                                           apply And.intro ( by exact REWRITE.Get_End_RwDirect dir_casesᵥ; );   /- := End Node -/
                                           apply And.intro ( by rewrite [prop_eq_lvl];                          /- := Colours -/
                                                                exact Prop_Levelᵥ; );
                                           apply Exists.intro Colour₁ᵥ;
                                           apply Exists.intro Colour₂ᵥ;
                                           apply Exists.intro Coloursᵥ;
                                           apply And.intro ( by exact Prop_Check_Coloursᵥ; );
                                           apply And.intro ( by rewrite [prop_pstᵥ, List.Eq_Iff_Mem_Unit] at Prop_Colour₁ᵥ;
                                                                rewrite [Prop_Colour₁ᵥ];
                                                                exact List.Mem.tail ( RULEᵤ.CENTER.NUMBER )
                                                                                    ( List.Mem.head RULEᵤ.CENTER.PAST ); );
                                           apply And.intro ( by exact Prop_Coloursᵥ; );
                                           /- := Check Direct-Outgoing Duo: -/
                                           cases Prop_Dir_Outᵥ with | intro Outᵥ Prop_Dir_Outᵥ =>
                                           cases Prop_Dir_Outᵥ with | intro Dep_Outᵥ Prop_Dir_Outᵥ =>
                                           cases Prop_Dir_Outᵥ with | intro Prop_Out_Colᵥ Prop_Dir_Outᵥ =>
                                           cases Prop_Dir_Outᵥ with | intro Prop_Colour₂ᵥ Prop_Dir_Outᵥ =>
                                           cases Prop_Dir_Outᵥ with | intro Prop_Dir_Outᵥ Prop_All_Dir_Outᵥ =>
                                           --
                                           apply Exists.intro Outᵥ;
                                           apply Exists.intro Dep_Outᵥ;
                                           apply And.intro ( by exact Prop_Out_Colᵥ; );
                                           apply And.intro ( by exact Prop_Colour₂ᵥ; );
                                           apply And.intro ( by simp only [List.Mem_Or_Mem_Iff_Mem_Append];     /- := edge CENTER out colour₁ dep_out ∈ OUTGOING -/
                                                                apply Or.inl;
                                                                rewrite [←collapse.center];
                                                                exact REWRITE.Mem_RwOutgoing_Of_Mem Prop_Dir_Outᵥ; );
                                           intro all_outᵥ all_out_casesᵥ;                                       /- := all_out.COLOUR = colour₁ ↔ all_out = edge CENTER out colour₁ dep_out -/
                                           simp only [List.Mem_Or_Mem_Iff_Mem_Append] at all_out_casesᵥ;
                                           cases all_out_casesᵥ with
                                           | inl all_out_casesᵥᵥ => have Dir_Out_Casesᵥᵥ := REWRITE.Mem_Of_Mem_RwOutgoing all_out_casesᵥᵥ;                      /- := all_out ∈ RULEᵥ.OUTGOING -/
                                                                    cases Dir_Out_Casesᵥᵥ with | intro Originalᵥ Dir_Out_Memᵥᵥ =>
                                                                    have Prop_All_Dir_Outᵥᵥ := Prop_All_Dir_Outᵥ Dir_Out_Memᵥᵥ;                                 /- := all_out.COLOUR = Colour₁ ↔ all_out = edge CENTER out Colour₁ dep_out -/
                                                                    rewrite [Deduction.edge.injEq] at Prop_All_Dir_Outᵥᵥ ⊢;
                                                                    rewrite [←COLLAPSE.Simp_Out_Start₃ (prop_outgoingᵥ Dir_Out_Memᵥᵥ)] at Prop_All_Dir_Outᵥᵥ;   /- := all_out.START = RULEᵥ.CENTER -/
                                                                    rewrite [←REWRITE.Get_Start_RwOutgoing all_out_casesᵥᵥ];                                    /- := all_out.START = collapse.center RULEᵤ.CENTER RULEᵥ.CENTER -/
                                                                    simp only [true_and] at Prop_All_Dir_Outᵥᵥ ⊢;
                                                                    exact Prop_All_Dir_Outᵥᵥ;
                                           | inr all_out_casesᵥᵤ => have Dir_Out_Casesᵥᵤ := REWRITE.Mem_Of_Mem_RwOutgoing all_out_casesᵥᵤ;                      /- := all_out ∈ RULEᵤ.OUTGOING -/
                                                                    cases Dir_Out_Casesᵥᵤ with | intro Originalᵤ Dir_Out_Memᵥᵤ =>
                                                                    have Dir_Out_Colourᵥᵤ := COLLAPSE.Simp_Out_Colour₃ (prop_outgoingᵤ Dir_Out_Memᵥᵤ);          /- := all_out.COLOUR = 0 ∨ all_out.COLOUR ∈ RULEᵤ.CENTER.NUMBER :: RULEᵤ.CENTER.PAST -/
                                                                    simp only [prop_pstᵥ, List.Eq_Iff_Mem_Unit] at Prop_Colour₁ᵥ;                               /- := Colour₁ = RULEᵥ.CENTER.NUMBER -/
                                                                    rewrite [Deduction.edge.injEq];
                                                                    have NE_Colourᵥ : all_outᵥ.COLOUR ≠ Colour₁ᵥ := by rewrite [ne_eq, ←imp_false];
                                                                                                                       intro EQ_Colour;
                                                                                                                       rewrite [EQ_Colour, Prop_Colour₁ᵥ] at Dir_Out_Colourᵥᵤ;
                                                                                                                       cases Dir_Out_Colourᵥᵤ with
                                                                                                                       | inl EQ_Zero => apply absurd EQ_Zero;
                                                                                                                                        exact Nat.ne_of_lt' prop_nbrᵥ;
                                                                                                                       | inr GT_Zero => apply absurd GT_Zero;
                                                                                                                                        rewrite [List.Eq_Or_Mem_Iff_Mem_Cons, not_or];
                                                                                                                                        exact And.intro ( by exact Nat.ne_of_lt prop_lt_nbr; )
                                                                                                                                                        ( by exact prop_ne_pst; );
                                                                    simp only [NE_Colourᵥ, false_and, and_false];
                       | inr dir_casesᵤ => have Dir_Casesᵤ := REWRITE.Mem_Of_Mem_RwDirect dir_casesᵤ;
                                           cases Dir_Casesᵤ with | intro Originalᵤ Dir_Memᵤ =>
                                           have Prop_Directᵤ := prop_directᵤ Dir_Memᵤ;
                                           simp only [type_direct.check] at Prop_Directᵤ ⊢;
                                           cases Prop_Directᵤ with | intro Prop_Startᵤ Prop_Directᵤ =>
                                           cases Prop_Directᵤ with | intro Prop_Endᵤ Prop_Directᵤ =>
                                           cases Prop_Directᵤ with | intro Prop_Levelᵤ Prop_Directᵤ =>
                                           cases Prop_Directᵤ with | intro Colour₁ᵤ Prop_Directᵤ =>
                                           cases Prop_Directᵤ with | intro Colour₂ᵤ Prop_Directᵤ =>
                                           cases Prop_Directᵤ with | intro Coloursᵤ Prop_Directᵤ =>
                                           cases Prop_Directᵤ with | intro Prop_Check_Coloursᵤ Prop_Directᵤ =>
                                           cases Prop_Directᵤ with | intro Prop_Colour₁ᵤ Prop_Directᵤ =>
                                           cases Prop_Directᵤ with | intro Prop_Coloursᵤ Prop_Dir_Outᵤ =>
                                           --
                                           apply And.intro ( by exact Prop_Startᵤ; );                           /- := Start Node -/
                                           apply And.intro ( by exact REWRITE.Get_End_RwDirect dir_casesᵤ; );   /- := End Node -/
                                           apply And.intro ( by exact Prop_Levelᵤ; );                           /- := Colours -/
                                           apply Exists.intro Colour₁ᵤ;
                                           apply Exists.intro Colour₂ᵤ;
                                           apply Exists.intro Coloursᵤ;
                                           apply And.intro ( by exact Prop_Check_Coloursᵤ; );
                                           apply And.intro ( by rewrite [List.Eq_Or_Mem_Iff_Mem_Cons] at Prop_Colour₁ᵤ;
                                                                cases Prop_Colour₁ᵤ with
                                                                | inl Prop_NBR_Colour₁ᵤ => rewrite [Prop_NBR_Colour₁ᵤ];
                                                                                           exact List.Mem.head ( RULEᵥ.CENTER.NUMBER :: RULEᵤ.CENTER.PAST );
                                                                | inr Prop_PST_Colour₁ᵤ => exact List.Mem.tail ( RULEᵤ.CENTER.NUMBER )
                                                                                                               ( List.Mem.tail RULEᵥ.CENTER.NUMBER Prop_PST_Colour₁ᵤ ); );
                                           apply And.intro ( by exact Prop_Coloursᵤ; );
                                           /- := Check Direct-Outgoing Duo: -/
                                           cases Prop_Dir_Outᵤ with | intro Outᵤ Prop_Dir_Outᵤ =>
                                           cases Prop_Dir_Outᵤ with | intro Dep_Outᵤ Prop_Dir_Outᵤ =>
                                           cases Prop_Dir_Outᵤ with | intro Prop_Out_Colᵤ Prop_Dir_Outᵤ =>
                                           cases Prop_Dir_Outᵤ with | intro Prop_Colour₂ᵤ Prop_Dir_Outᵤ =>
                                           cases Prop_Dir_Outᵤ with | intro Prop_Dir_Outᵤ Prop_All_Dir_Outᵤ =>
                                           --
                                           apply Exists.intro Outᵤ;
                                           apply Exists.intro Dep_Outᵤ;
                                           apply And.intro ( by exact Prop_Out_Colᵤ; );
                                           apply And.intro ( by exact Prop_Colour₂ᵤ; );
                                           apply And.intro ( by simp only [List.Mem_Or_Mem_Iff_Mem_Append];     /- := edge CENTER out colour₁ dep_out ∈ OUTGOING -/
                                                                apply Or.inr;
                                                                rewrite [←collapse.center];
                                                                exact REWRITE.Mem_RwOutgoing_Of_Mem Prop_Dir_Outᵤ; );
                                           intro all_outᵤ all_out_casesᵤ;                                       /- := all_out.COLOUR = colour₁ ↔ all_out = edge CENTER out colour₁ dep_out -/
                                           simp only [List.Mem_Or_Mem_Iff_Mem_Append] at all_out_casesᵤ;
                                           cases all_out_casesᵤ with
                                           | inl all_out_casesᵤᵥ => have Dir_Out_Casesᵤᵥ := REWRITE.Mem_Of_Mem_RwOutgoing all_out_casesᵤᵥ;                      /- := all_out ∈ RULEᵥ.OUTGOING -/
                                                                    cases Dir_Out_Casesᵤᵥ with | intro Originalᵥ Dir_Out_Memᵤᵥ =>
                                                                    have Dir_Out_Colourᵤᵥ := COLLAPSE.Simp_Out_Colour₃ (prop_outgoingᵥ Dir_Out_Memᵤᵥ);          /- := all_out.COLOUR = 0 ∨ all_out.COLOUR ∈ RULEᵥ.CENTER.NUMBER :: RULEᵥ.CENTER.PAST -/
                                                                    simp only [prop_pstᵥ, List.Eq_Iff_Mem_Unit] at Dir_Out_Colourᵤᵥ;
                                                                    rewrite [Deduction.edge.injEq];
                                                                    have NE_Colourᵤ : all_outᵤ.COLOUR ≠ Colour₁ᵤ := by rewrite [ne_eq, ←imp_false];
                                                                                                                       intro EQ_Colour;
                                                                                                                       apply absurd Prop_Colour₁ᵤ;              /- := Colour₁ ∉ RULEᵤ.CENTER.NUMBER :: RULEᵤ.CENTER.PAST -/
                                                                                                                       cases Dir_Out_Colourᵤᵥ with
                                                                                                                       | inl EQ_Zero => rewrite [←EQ_Colour, EQ_Zero, prop_pstᵤ];
                                                                                                                                        rewrite [List.Eq_Or_Mem_Iff_Mem_Cons, not_or];
                                                                                                                                        exact And.intro ( by exact Nat.ne_of_lt prop_nbrᵤ; )
                                                                                                                                                        ( by rewrite [←imp_false];
                                                                                                                                                             intro Past_Zero;
                                                                                                                                                             simp only [check_numbers] at prop_check_pastᵤ;
                                                                                                                                                             cases prop_check_pastᵤ with | intro _ prop_check_pastᵤ =>
                                                                                                                                                             apply absurd (prop_check_pastᵤ Past_Zero);
                                                                                                                                                             trivial; );
                                                                                                                       | inr GT_Zero => rewrite [←EQ_Colour, GT_Zero];
                                                                                                                                        rewrite [List.Eq_Or_Mem_Iff_Mem_Cons, not_or];
                                                                                                                                        exact And.intro ( by exact Nat.ne_of_lt prop_lt_nbr; )
                                                                                                                                                        ( by exact prop_ne_pst; );
                                                                    simp only [NE_Colourᵤ, false_and, and_false];
                                           | inr all_out_casesᵤᵤ => have Dir_Out_Casesᵤᵤ := REWRITE.Mem_Of_Mem_RwOutgoing all_out_casesᵤᵤ;                      /- := all_out ∈ RULEᵤ.OUTGOING -/
                                                                    cases Dir_Out_Casesᵤᵤ with | intro Originalᵤ Dir_Out_Memᵤᵤ =>
                                                                    have Prop_All_Dir_Outᵤᵤ := Prop_All_Dir_Outᵤ Dir_Out_Memᵤᵤ;                                 /- := all_out.COLOUR = Colour₁ ↔ all_out = edge CENTER out Colour₁ dep_out -/
                                                                    rewrite [Deduction.edge.injEq] at Prop_All_Dir_Outᵤᵤ ⊢;
                                                                    rewrite [←COLLAPSE.Simp_Out_Start₃ (prop_outgoingᵤ Dir_Out_Memᵤᵤ)] at Prop_All_Dir_Outᵤᵤ;   /- := all_out.START = RULEᵤ.CENTER -/
                                                                    rewrite [←REWRITE.Get_Start_RwOutgoing all_out_casesᵤᵤ];                                    /- := all_out.START = collapse.center RULEᵤ.CENTER RULEᵥ.CENTER -/
                                                                    simp only [true_and] at Prop_All_Dir_Outᵤᵤ ⊢;
                                                                    exact Prop_All_Dir_Outᵤᵤ; );
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  /- Indirect Paths -/------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  simp only [type_indirect] at prop_indirectᵤ prop_indirectᵥ ⊢;
  simp only [List.Mem_Or_Mem_Iff_Mem_Append];
  intro ind ind_cases;
  cases ind_cases with
  | inl ind_casesᵥ => have Prop_Indirectᵥ := prop_indirectᵥ ind_casesᵥ;
                      simp only [type_indirect.check] at Prop_Indirectᵥ ⊢;
                      cases Prop_Indirectᵥ with | intro Prop_Startᵥ Prop_Indirectᵥ =>
                      cases Prop_Indirectᵥ with | intro Prop_Endᵥ Prop_Indirectᵥ =>
                      cases Prop_Indirectᵥ with | intro Prop_Levelᵥ Prop_Indirectᵥ =>
                      cases Prop_Indirectᵥ with | intro Colourᵥ Prop_Indirectᵥ =>
                      cases Prop_Indirectᵥ with | intro Coloursᵥ Prop_Indirectᵥ =>
                      cases Prop_Indirectᵥ with | intro Prop_Check_Coloursᵥ Prop_Indirectᵥ =>
                      cases Prop_Indirectᵥ with | intro Prop_Colourᵥ Prop_Indirectᵥ =>
                      cases Prop_Indirectᵥ with | intro Prop_Coloursᵥ Prop_Indirectᵥ =>
                      cases Prop_Indirectᵥ with | intro Prop_Ind_Incᵥ Prop_Ind_Outᵥ =>
                      --
                      apply And.intro ( by rewrite [prop_eq_lvl];         /- := Start Node -/
                                           exact Prop_Startᵥ; );
                      apply And.intro ( by rewrite [prop_eq_lvl];         /- := End Node -/
                                           exact Prop_Endᵥ; );
                      apply And.intro ( by rewrite [prop_eq_lvl];         /- := Colours -/
                                           exact Prop_Levelᵥ; );
                      apply Exists.intro Colourᵥ;
                      apply Exists.intro Coloursᵥ;
                      apply And.intro ( by exact Prop_Check_Coloursᵥ; );
                      apply And.intro ( by rewrite [prop_pstᵥ, List.Eq_Iff_Mem_Unit] at Prop_Colourᵥ;
                                           rewrite [Prop_Colourᵥ];
                                           exact List.Mem.tail ( RULEᵤ.CENTER.NUMBER )
                                                               ( List.Mem.head RULEᵤ.CENTER.PAST ); );
                      apply And.intro ( by exact Prop_Coloursᵥ; );
                      /- := Check Indirect-Incoming Duo: -/
                      cases Prop_Ind_Incᵥ with | intro Dep_Incᵥ Prop_Ind_Incᵥ =>
                      cases Prop_Ind_Incᵥ with | intro Prop_Ind_Incᵥ Prop_All_Ind_Incᵥ =>
                      --
                      apply And.intro ( by apply Exists.intro Dep_Incᵥ;
                                           apply And.intro ( by simp only [List.Mem_Or_Mem_Iff_Mem_Append];   /- := edge IND.END CENTER 0 dep_inc ∈ INCOMING -/
                                                                apply Or.inl;
                                                                rewrite [←collapse.center];
                                                                exact REWRITE.Mem_RwIncoming_Of_Mem Prop_Ind_Incᵥ; );
                                           intro all_incᵥ all_inc_casesᵥ;                                     /- := all_inc.START = IND.END ↔ all_inc = edge IND.END CENTER 0 dep_inc -/
                                           simp only [List.Mem_Or_Mem_Iff_Mem_Append] at all_inc_casesᵥ;
                                           cases all_inc_casesᵥ with
                                           | inl all_inc_casesᵥᵥ => have Ind_Inc_Casesᵥᵥ := REWRITE.Mem_Of_Mem_RwIncoming all_inc_casesᵥᵥ;                      /- := all_inc ∈ RULEᵥ.INCOMING -/
                                                                    cases Ind_Inc_Casesᵥᵥ with | intro Originalᵥ Ind_Inc_Memᵥᵥ =>
                                                                    have Prop_All_Ind_Incᵥᵥ := Prop_All_Ind_Incᵥ Ind_Inc_Memᵥᵥ;                                 /- := all_inc.START = IND.END ↔ all_inc = edge IND.END CENTER 0 dep_inc -/
                                                                    rewrite [Deduction.edge.injEq] at Prop_All_Ind_Incᵥᵥ ⊢;
                                                                    rewrite [←COLLAPSE.Simp_Inc_End (prop_incomingᵥ Ind_Inc_Memᵥᵥ)] at Prop_All_Ind_Incᵥᵥ;      /- := all_inc.END = RULEᵥ.CENTER -/
                                                                    rewrite [←REWRITE.Get_End_RwIncoming all_inc_casesᵥᵥ];                                      /- := all_inc.END = collapse.center RULEᵤ.CENTER RULEᵥ.CENTER -/
                                                                    simp only [true_and] at Prop_All_Ind_Incᵥᵥ ⊢;
                                                                    exact Prop_All_Ind_Incᵥᵥ;
                                           | inr all_inc_casesᵥᵤ => have Ind_Inc_Casesᵥᵤ := REWRITE.Mem_Of_Mem_RwIncoming all_inc_casesᵥᵤ;                      /- := all_inc ∈ RULEᵤ.INCOMING -/
                                                                    cases Ind_Inc_Casesᵥᵤ with | intro Originalᵤ Ind_Inc_Memᵥᵤ =>
                                                                    rewrite [Deduction.edge.injEq];
                                                                    have Prop_Check_Incomingᵥᵤ := prop_check_incoming Ind_Inc_Memᵥᵤ Prop_Ind_Incᵥ;              /- := all_inc.START ≠ IND.END -/
                                                                    simp only [Prop_Check_Incomingᵥᵤ, false_and]; );
                      /- := Check Indirect-Outgoing Duo: -/
                      cases Prop_Ind_Outᵥ with | intro Outᵥ Prop_Ind_Outᵥ =>
                      cases Prop_Ind_Outᵥ with | intro Dep_Outᵥ Prop_Ind_Outᵥ =>
                      cases Prop_Ind_Outᵥ with | intro Prop_Out_Colᵥ Prop_Ind_Outᵥ =>
                      cases Prop_Ind_Outᵥ with | intro Prop_Ind_Outᵥ Prop_All_Ind_Outᵥ =>
                      --
                      apply Exists.intro Outᵥ;
                      apply Exists.intro Dep_Outᵥ;
                      apply And.intro ( by exact Prop_Out_Colᵥ; );
                      apply And.intro ( by simp only [List.Mem_Or_Mem_Iff_Mem_Append];     /- := edge CENTER out colour₁ dep_out ∈ OUTGOING -/
                                           apply Or.inl;
                                           rewrite [←collapse.center];
                                           exact REWRITE.Mem_RwOutgoing_Of_Mem Prop_Ind_Outᵥ; );
                      intro all_outᵥ all_out_casesᵥ;                                       /- := all_out.COLOUR = colour₁ ↔ all_out = edge CENTER out colour₁ dep_out -/
                      simp only [List.Mem_Or_Mem_Iff_Mem_Append] at all_out_casesᵥ;
                      cases all_out_casesᵥ with
                      | inl all_out_casesᵥᵥ => have Ind_Out_Casesᵥᵥ := REWRITE.Mem_Of_Mem_RwOutgoing all_out_casesᵥᵥ;                      /- := all_out ∈ RULEᵥ.OUTGOING -/
                                               cases Ind_Out_Casesᵥᵥ with | intro Originalᵥ Ind_Out_Memᵥᵥ =>
                                               have Prop_All_Ind_Outᵥᵥ := Prop_All_Ind_Outᵥ Ind_Out_Memᵥᵥ;                                 /- := all_out.COLOUR = Colour ↔ all_out = edge CENTER out Colour dep_out -/
                                               rewrite [Deduction.edge.injEq] at Prop_All_Ind_Outᵥᵥ ⊢;
                                               rewrite [←COLLAPSE.Simp_Out_Start₃ (prop_outgoingᵥ Ind_Out_Memᵥᵥ)] at Prop_All_Ind_Outᵥᵥ;   /- := all_out.START = RULEᵥ.CENTER -/
                                               rewrite [←REWRITE.Get_Start_RwOutgoing all_out_casesᵥᵥ];                                    /- := all_out.START = collapse.center RULEᵤ.CENTER RULEᵥ.CENTER -/
                                               simp only [true_and] at Prop_All_Ind_Outᵥᵥ ⊢;
                                               exact Prop_All_Ind_Outᵥᵥ;
                      | inr all_out_casesᵥᵤ => have Ind_Out_Casesᵥᵤ := REWRITE.Mem_Of_Mem_RwOutgoing all_out_casesᵥᵤ;                      /- := all_out ∈ RULEᵤ.OUTGOING -/
                                               cases Ind_Out_Casesᵥᵤ with | intro Originalᵤ Ind_Out_Memᵥᵤ =>
                                               have Ind_Out_Colourᵥᵤ := COLLAPSE.Simp_Out_Colour₃ (prop_outgoingᵤ Ind_Out_Memᵥᵤ);          /- := all_out.COLOUR = 0 ∨ all_out.COLOUR ∈ RULEᵤ.CENTER.NUMBER :: RULEᵤ.CENTER.PAST -/
                                               simp only [prop_pstᵥ, List.Eq_Iff_Mem_Unit] at Prop_Colourᵥ;                                /- := Colour = RULEᵥ.CENTER.NUMBER -/
                                               rewrite [Deduction.edge.injEq];
                                               have NE_Colourᵥ : all_outᵥ.COLOUR ≠ Colourᵥ := by rewrite [ne_eq, ←imp_false];
                                                                                                 intro EQ_Colour;
                                                                                                 rewrite [EQ_Colour, Prop_Colourᵥ] at Ind_Out_Colourᵥᵤ;
                                                                                                 cases Ind_Out_Colourᵥᵤ with
                                                                                                 | inl EQ_Zero => apply absurd EQ_Zero;
                                                                                                                  exact Nat.ne_of_lt' prop_nbrᵥ;
                                                                                                 | inr GT_Zero => apply absurd GT_Zero;
                                                                                                                  rewrite [List.Eq_Or_Mem_Iff_Mem_Cons, not_or];
                                                                                                                  exact And.intro ( by exact Nat.ne_of_lt prop_lt_nbr; )
                                                                                                                                  ( by exact prop_ne_pst; );
                                               simp only [NE_Colourᵥ, false_and, and_false];
  | inr ind_casesᵤ => have Prop_Indirectᵤ := prop_indirectᵤ ind_casesᵤ;
                      simp only [type_indirect.check] at Prop_Indirectᵤ ⊢;
                      cases Prop_Indirectᵤ with | intro Prop_Startᵤ Prop_Indirectᵤ =>
                      cases Prop_Indirectᵤ with | intro Prop_Endᵤ Prop_Indirectᵤ =>
                      cases Prop_Indirectᵤ with | intro Prop_Levelᵤ Prop_Indirectᵤ =>
                      cases Prop_Indirectᵤ with | intro Colourᵤ Prop_Indirectᵤ =>
                      cases Prop_Indirectᵤ with | intro Coloursᵤ Prop_Indirectᵤ =>
                      cases Prop_Indirectᵤ with | intro Prop_Check_Coloursᵤ Prop_Indirectᵤ =>
                      cases Prop_Indirectᵤ with | intro Prop_Colourᵤ Prop_Indirectᵤ =>
                      cases Prop_Indirectᵤ with | intro Prop_Coloursᵤ Prop_Indirectᵤ =>
                      cases Prop_Indirectᵤ with | intro Prop_Ind_Incᵤ Prop_Ind_Outᵤ =>
                      --
                      apply And.intro ( by exact Prop_Startᵤ; );           /- := Start Node -/
                      apply And.intro ( by exact Prop_Endᵤ; );             /- := End Node -/
                      apply And.intro ( by exact Prop_Levelᵤ; );           /- := Colours -/
                      apply Exists.intro Colourᵤ;
                      apply Exists.intro Coloursᵤ;
                      apply And.intro ( by exact Prop_Check_Coloursᵤ; );
                      apply And.intro ( by rewrite [List.Eq_Or_Mem_Iff_Mem_Cons] at Prop_Colourᵤ;
                                           cases Prop_Colourᵤ with
                                           | inl Prop_NBR_Colourᵤ => rewrite [Prop_NBR_Colourᵤ];
                                                                     exact List.Mem.head ( RULEᵥ.CENTER.NUMBER :: RULEᵤ.CENTER.PAST );
                                           | inr Prop_PST_Colourᵤ => exact List.Mem.tail ( RULEᵤ.CENTER.NUMBER )
                                                                                         ( List.Mem.tail RULEᵥ.CENTER.NUMBER Prop_PST_Colourᵤ ); );
                      apply And.intro ( by exact Prop_Coloursᵤ; );
                      /- := Check Indirect-Incoming Duo: -/
                      cases Prop_Ind_Incᵤ with | intro Dep_Incᵤ Prop_Ind_Incᵤ =>
                      cases Prop_Ind_Incᵤ with | intro Prop_Ind_Incᵤ Prop_All_Ind_Incᵤ =>
                      --
                      apply And.intro ( by apply Exists.intro Dep_Incᵤ;
                                           apply And.intro ( by simp only [List.Mem_Or_Mem_Iff_Mem_Append];   /- := edge IND.END CENTER 0 dep_inc ∈ INCOMING -/
                                                                apply Or.inr;
                                                                rewrite [←collapse.center];
                                                                exact REWRITE.Mem_RwIncoming_Of_Mem Prop_Ind_Incᵤ; );
                                           intro all_incᵤ all_inc_casesᵤ;                                     /- := all_inc.START = IND.END ↔ all_inc = edge IND.END CENTER 0 dep_inc -/
                                           simp only [List.Mem_Or_Mem_Iff_Mem_Append] at all_inc_casesᵤ;
                                           cases all_inc_casesᵤ with
                                           | inl all_inc_casesᵤᵥ => have Ind_Inc_Casesᵤᵥ := REWRITE.Mem_Of_Mem_RwIncoming all_inc_casesᵤᵥ;                      /- := all_inc ∈ RULEᵥ.INCOMING -/
                                                                    cases Ind_Inc_Casesᵤᵥ with | intro Originalᵥ Ind_Inc_Memᵤᵥ =>
                                                                    rewrite [Deduction.edge.injEq];
                                                                    have Prop_Check_Incomingᵤᵥ := prop_check_incoming Prop_Ind_Incᵤ Ind_Inc_Memᵤᵥ;              /- := IND.END ≠ all_inc.START -/
                                                                    rewrite [ne_comm] at Prop_Check_Incomingᵤᵥ;
                                                                    simp only [Prop_Check_Incomingᵤᵥ, false_and];
                                           | inr all_inc_casesᵤᵤ => have Ind_Inc_Casesᵤᵤ := REWRITE.Mem_Of_Mem_RwIncoming all_inc_casesᵤᵤ;                      /- := all_inc ∈ RULEᵤ.INCOMING -/
                                                                    cases Ind_Inc_Casesᵤᵤ with | intro Originalᵤ Ind_Inc_Memᵤᵤ =>
                                                                    have Prop_All_Ind_Incᵤᵤ := Prop_All_Ind_Incᵤ Ind_Inc_Memᵤᵤ;                                 /- := all_inc.START = IND.END ↔ all_inc = edge IND.END CENTER 0 dep_inc -/
                                                                    rewrite [Deduction.edge.injEq] at Prop_All_Ind_Incᵤᵤ ⊢;
                                                                    rewrite [←COLLAPSE.Simp_Inc_End (prop_incomingᵤ Ind_Inc_Memᵤᵤ)] at Prop_All_Ind_Incᵤᵤ;      /- := all_inc.END = RULEᵤ.CENTER -/
                                                                    rewrite [←REWRITE.Get_End_RwIncoming all_inc_casesᵤᵤ];                                      /- := all_inc.END = collapse.center RULEᵤ.CENTER RULEᵥ.CENTER -/
                                                                    simp only [true_and] at Prop_All_Ind_Incᵤᵤ ⊢;
                                                                    exact Prop_All_Ind_Incᵤᵤ; );
                      /- Check Outgoing-Indirect Duo: -/
                      cases Prop_Ind_Outᵤ with | intro Outᵤ Prop_Ind_Outᵤ =>
                      cases Prop_Ind_Outᵤ with | intro Dep_Outᵤ Prop_Ind_Outᵤ =>
                      cases Prop_Ind_Outᵤ with | intro Prop_Out_Colᵤ Prop_Ind_Outᵤ =>
                      cases Prop_Ind_Outᵤ with | intro Prop_Ind_Outᵤ Prop_All_Ind_Outᵤ =>
                      --
                      apply Exists.intro Outᵤ;
                      apply Exists.intro Dep_Outᵤ;
                      apply And.intro ( by exact Prop_Out_Colᵤ; );
                      apply And.intro ( by simp only [List.Mem_Or_Mem_Iff_Mem_Append];     /- := edge CENTER out colour dep_out ∈ OUTGOING -/
                                           apply Or.inr;
                                           rewrite [←collapse.center];
                                           exact REWRITE.Mem_RwOutgoing_Of_Mem Prop_Ind_Outᵤ; );
                      intro all_outᵤ all_out_casesᵤ;                                       /- := all_out.COLOUR = colour ↔ all_out = edge CENTER out colour₁ dep_out -/
                      simp only [List.Mem_Or_Mem_Iff_Mem_Append] at all_out_casesᵤ;
                      cases all_out_casesᵤ with
                      | inl all_out_casesᵤᵥ => have Ind_Out_Casesᵤᵥ := REWRITE.Mem_Of_Mem_RwOutgoing all_out_casesᵤᵥ;                      /- := all_out ∈ RULEᵥ.OUTGOING -/
                                               cases Ind_Out_Casesᵤᵥ with | intro Originalᵥ Ind_Out_Memᵤᵥ =>
                                               have Ind_Out_Colourᵤᵥ := COLLAPSE.Simp_Out_Colour₃ (prop_outgoingᵥ Ind_Out_Memᵤᵥ);          /- := all_out.COLOUR = 0 ∨ all_out.COLOUR ∈ RULEᵥ.CENTER.NUMBER :: RULEᵥ.CENTER.PAST -/
                                               simp only [prop_pstᵥ, List.Eq_Iff_Mem_Unit] at Ind_Out_Colourᵤᵥ;
                                               rewrite [Deduction.edge.injEq];
                                               have NE_Colourᵤ : all_outᵤ.COLOUR ≠ Colourᵤ := by rewrite [ne_eq, ←imp_false];
                                                                                                 intro EQ_Colour;
                                                                                                 apply absurd Prop_Colourᵤ;              /- := Colour ∉ RULEᵤ.CENTER.NUMBER :: RULEᵤ.CENTER.PAST -/
                                                                                                 cases Ind_Out_Colourᵤᵥ with
                                                                                                 | inl EQ_Zero => rewrite [←EQ_Colour, EQ_Zero, prop_pstᵤ];
                                                                                                                  rewrite [List.Eq_Or_Mem_Iff_Mem_Cons, not_or];
                                                                                                                  exact And.intro ( by exact Nat.ne_of_lt prop_nbrᵤ; )
                                                                                                                                  ( by rewrite [←imp_false];
                                                                                                                                       intro Past_Zero;
                                                                                                                                       simp only [check_numbers] at prop_check_pastᵤ;
                                                                                                                                       cases prop_check_pastᵤ with | intro _ prop_check_pastᵤ =>
                                                                                                                                       apply absurd (prop_check_pastᵤ Past_Zero);
                                                                                                                                       trivial; );
                                                                                                 | inr GT_Zero => rewrite [←EQ_Colour, GT_Zero];
                                                                                                                  rewrite [List.Eq_Or_Mem_Iff_Mem_Cons, not_or];
                                                                                                                  exact And.intro ( by exact Nat.ne_of_lt prop_lt_nbr; )
                                                                                                                                  ( by exact prop_ne_pst; );
                                               simp only [NE_Colourᵤ, false_and, and_false];
                      | inr all_out_casesᵤᵤ => have Ind_Out_Casesᵤᵤ := REWRITE.Mem_Of_Mem_RwOutgoing all_out_casesᵤᵤ;                      /- := all_out ∈ RULEᵤ.OUTGOING -/
                                               cases Ind_Out_Casesᵤᵤ with | intro Originalᵤ Ind_Out_Memᵤᵤ =>
                                               have Prop_All_Ind_Outᵤᵤ := Prop_All_Ind_Outᵤ Ind_Out_Memᵤᵤ;                                 /- := all_out.COLOUR = Colour ↔ all_out = edge CENTER out Colour dep_out -/
                                               rewrite [Deduction.edge.injEq] at Prop_All_Ind_Outᵤᵤ ⊢;
                                               rewrite [←COLLAPSE.Simp_Out_Start₃ (prop_outgoingᵤ Ind_Out_Memᵤᵤ)] at Prop_All_Ind_Outᵤᵤ;   /- := all_out.START = RULEᵤ.CENTER -/
                                               rewrite [←REWRITE.Get_Start_RwOutgoing all_out_casesᵤᵤ];                                    /- := all_out.START = collapse.center RULEᵤ.CENTER RULEᵥ.CENTER -/
                                               simp only [true_and] at Prop_All_Ind_Outᵤᵤ ⊢;
                                               exact Prop_All_Ind_Outᵤᵤ;
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
end COVERAGE.T3_Of_T3.NODES


namespace COVERAGE.T3_Of_T3.EDGES
  --333 set_option trace.Meta.Tactic.simp true
  /- Lemma: Collapse Execution (Type 2 & Type 3 => Type 3) (Nodes & Edges) -/
  theorem Col_Of_Collapse_Pre_Pre {RULEᵤ RULEᵥ : Neighborhood} :
    ( check_collapse_edges RULEᵤ RULEᵥ ) →
    ( type3_pre_collapse RULEᵤ ) →
    ( type3_pre_collapse RULEᵥ ) →
    ---------------------------
    ( type3_collapse (collapse RULEᵤ RULEᵥ) ) := by
  intro prop_check_collapse prop_typeᵤ prop_typeᵥ;
  --
  simp only [check_collapse_edges] at prop_check_collapse;
  cases prop_check_collapse with | intro prop_eq_out prop_check_collapse =>
  cases prop_check_collapse with | intro prop_eq_lvl prop_check_collapse =>
  cases prop_check_collapse with | intro prop_eq_fml prop_check_incoming =>
  --
  cases prop_eq_out with | intro eq_outᵤ prop_eq_out =>
  cases prop_eq_out with | intro eq_outᵥ prop_eq_out =>
  cases prop_eq_out with | intro eq_out_memᵤ prop_eq_out =>
  cases prop_eq_out with | intro eq_out_memᵥ prop_eq_out =>
  cases prop_eq_out with | intro eq_out_colourᵤ prop_eq_out =>
  --
  simp only [type3_pre_collapse] at prop_typeᵤ;
  cases prop_typeᵤ with | intro prop_nbrᵤ prop_typeᵤ =>
  cases prop_typeᵤ with | intro prop_lvlᵤ prop_typeᵤ =>
  cases prop_typeᵤ with | intro prop_colᵤ prop_typeᵤ =>
  cases prop_typeᵤ with | intro prop_pstᵤ prop_typeᵤ =>
  cases prop_typeᵤ with | intro prop_inc_nilᵤ prop_typeᵤ =>
  cases prop_typeᵤ with | intro prop_inc_lenᵤ prop_typeᵤ =>
  cases prop_typeᵤ with | intro prop_out_unitᵤ prop_typeᵤ =>
  cases prop_typeᵤ with | intro prop_out_coloursᵤ prop_typeᵤ =>
  cases prop_typeᵤ with | intro prop_dir_nilᵤ prop_typeᵤ =>
  cases prop_typeᵤ with | intro prop_dir_consᵤ prop_typeᵤ =>
  cases prop_typeᵤ with | intro prop_dir_unitᵤ prop_typeᵤ =>
  cases prop_typeᵤ with | intro prop_ind_startsᵤ prop_typeᵤ =>
  cases prop_typeᵤ with | intro prop_ind_lenᵤ prop_typeᵤ =>
  cases prop_typeᵤ with | intro prop_incomingᵤ prop_typeᵤ =>
  cases prop_typeᵤ with | intro prop_outgoingᵤ prop_typeᵤ =>
  cases prop_typeᵤ with | intro prop_directᵤ prop_indirectᵤ =>
  --
  cases prop_out_unitᵤ with | intro outᵤ prop_out_unitᵤ =>
  --
  simp only [type3_pre_collapse] at prop_typeᵥ;
  cases prop_typeᵥ with | intro prop_nbrᵥ prop_typeᵥ =>
  cases prop_typeᵥ with | intro prop_lvlᵥ prop_typeᵥ =>
  cases prop_typeᵥ with | intro prop_colᵥ prop_typeᵥ =>
  cases prop_typeᵥ with | intro prop_pstᵥ prop_typeᵥ =>
  cases prop_typeᵥ with | intro prop_inc_nilᵥ prop_typeᵥ =>
  cases prop_typeᵥ with | intro prop_inc_lenᵥ prop_typeᵥ =>
  cases prop_typeᵥ with | intro prop_out_unitᵥ prop_typeᵥ =>
  cases prop_typeᵥ with | intro prop_out_coloursᵥ prop_typeᵥ =>
  cases prop_typeᵥ with | intro prop_dir_nilᵥ prop_typeᵥ =>
  cases prop_typeᵥ with | intro prop_dir_consᵥ prop_typeᵥ =>
  cases prop_typeᵥ with | intro prop_dir_unitᵥ prop_typeᵥ =>
  cases prop_typeᵥ with | intro prop_ind_startsᵥ prop_typeᵥ =>
  cases prop_typeᵥ with | intro prop_ind_lenᵥ prop_typeᵥ =>
  cases prop_typeᵥ with | intro prop_incomingᵥ prop_typeᵥ =>
  cases prop_typeᵥ with | intro prop_outgoingᵥ prop_typeᵥ =>
  cases prop_typeᵥ with | intro prop_directᵥ prop_indirectᵥ =>
  --
  cases prop_out_unitᵥ with | intro outᵥ prop_out_unitᵥ =>
  --
  rewrite [prop_out_unitᵥ] at eq_out_memᵥ;
  simp only [List.Eq_Iff_Mem_Unit] at eq_out_memᵥ;
  simp only [eq_out_memᵥ] at prop_eq_out;
  cases prop_eq_out with | intro prop_eq_out_end prop_eq_out =>
  cases prop_eq_out with | intro prop_eq_out_colour prop_eq_out_dependency =>
  --
  simp only [collapse];
  simp only [collapse.center];
  simp only [type3_collapse];
  /- Check Center-/
  apply And.intro ( by exact prop_nbrᵤ; );                                        /- := RULE.CENTER.NUMBER > 0 -/
  apply And.intro ( by exact prop_lvlᵤ; );                                        /- := RULE.CENTER.LEVEL > 0 -/
  apply And.intro ( by trivial; );                                                /- := RULE.CENTER.COLLAPSED = true -/
  apply And.intro ( by apply Exists.intro RULEᵥ.CENTER.NUMBER;                    /- := check_numbers (past :: pasts) ∧ RULE.CENTER.PAST = (past::pasts) -/
                       apply Exists.intro RULEᵤ.CENTER.PAST;
                       apply And.intro ( by simp only [prop_pstᵤ];
                                            exact COLLAPSE.Check_Numbers_Unit prop_nbrᵥ; );
                       trivial; );
  /- Check Deduction Edges -/
  apply And.intro ( by intro prop_inc_nil;                                        /- := ( RULE.INCOMING = [] ) → ( RULE.CENTER.HYPOTHESIS = true ) -/
                       simp only [List.append_eq_nil] at prop_inc_nil;
                       simp only [←List.length_eq_zero] at prop_inc_nil prop_inc_nilᵥ;
                       simp only [REWRITE.Eq_Length_RwIncoming] at prop_inc_nil;
                       simp only [prop_inc_nilᵥ] at prop_inc_nil;
                       simp only [Bool.or_eq_true];
                       exact Or.inr (And.left prop_inc_nil); );
  apply And.intro ( by simp only [prop_out_unitᵥ];                                                                    /- := RULE.OUTGOING = (out::outs) -/
                       apply Exists.intro ( edge ( collapse.center RULEᵤ.CENTER RULEᵥ.CENTER )                        /- RULEᵥ.OUTGOING -/
                                                 ( outᵥ.END )
                                                 ( outᵥ.COLOUR )
                                                 ( outᵥ.DEPENDENCY ) );
                       apply Exists.intro ( collapse.rewrite_outgoing ( collapse.center RULEᵤ.CENTER RULEᵥ.CENTER )   /- RULEᵤ.OUTGOING -/
                                                                      ( RULEᵤ.OUTGOING ) );
                       simp only [collapse.rewrite_outgoing];
                       simp only [collapse.center];
                       trivial; );
  apply And.intro ( by intro out₁ out₂ out_mem₁ out_mem₂ gt_zero₁₂;                          /- := OUT₁.COLOUR = OUT₂.COLOUR ↔ OUT₁ = OUT₂ -/
                       rewrite [prop_out_unitᵥ] at out_mem₁ out_mem₂;
                       simp only [collapse.rewrite_outgoing] at out_mem₁ out_mem₂;
                       simp only [List.Mem_Or_Mem_Iff_Mem_Append] at out_mem₁ out_mem₂;
                       simp only [List.Eq_Iff_Mem_Unit] at out_mem₁ out_mem₂;
                       simp only [Deduction.edge.injEq'];
                       --
                       simp only [type_outgoing₃] at prop_outgoingᵤ;
                       have Eq_Out_Colourᵤ := COLLAPSE.Simp_Out_Start₃ (prop_outgoingᵤ eq_out_memᵤ);
                       --
                       cases out_mem₁ with
                       | inl out_mem₁ᵥ => cases out_mem₂ with
                                          | inl out_mem₂ᵥ => rewrite [out_mem₁ᵥ, out_mem₂ᵥ]; simp only [true_and];
                                          | inr out_mem₂ᵤ => rewrite [out_mem₁ᵥ, REWRITE.Get_Start_RwOutgoing out_mem₂ᵤ];                 /- := out₁ = outᵥ, out₂.START = collapse.center RULEᵤ.CENTER RULEᵥ.CENTER -/
                                                             simp only [prop_eq_out_end, prop_eq_out_colour, prop_eq_out_dependency, true_and];
                                                             --
                                                             have Out_Cases₂ᵤ := REWRITE.Mem_Of_Mem_RwOutgoing out_mem₂ᵤ;                 /- := out₂ ∈ RULEᵥ.OUTGOING -/
                                                             cases Out_Cases₂ᵤ with | intro Originalᵤ Out_Mem₂ᵤ =>
                                                             have Out_Start₂ᵤ := COLLAPSE.Simp_Out_Start₃ (prop_outgoingᵤ Out_Mem₂ᵤ);     /- := out₂.START = RULEᵤ.CENTER -/
                                                             --
                                                             have Iff_Out_Colourᵤ := prop_out_coloursᵤ eq_out_memᵤ Out_Mem₂ᵤ (Or.inl eq_out_colourᵤ);
                                                             simp only [Deduction.edge.injEq'] at Out_Start₂ᵤ Iff_Out_Colourᵤ;
                                                             simp only [Eq_Out_Colourᵤ, Out_Start₂ᵤ, true_and] at Iff_Out_Colourᵤ;
                                                             exact Iff_Out_Colourᵤ;
                       | inr out_mem₁ᵤ => cases out_mem₂ with
                                          | inl out_mem₂ᵥ => rewrite [REWRITE.Get_Start_RwOutgoing out_mem₁ᵤ, out_mem₂ᵥ];                 /- := out₁.START = collapse.center RULEᵤ.CENTER RULEᵥ.CENTER, out₂ = outᵥ -/
                                                             simp only [prop_eq_out_end, prop_eq_out_colour, prop_eq_out_dependency, true_and];
                                                             --
                                                             have Out_Cases₁ᵤ := REWRITE.Mem_Of_Mem_RwOutgoing out_mem₁ᵤ;                 /- := out₁ ∈ RULEᵥ.OUTGOING -/
                                                             cases Out_Cases₁ᵤ with | intro Originalᵤ Out_Mem₁ᵤ =>
                                                             have Out_Start₁ᵤ := COLLAPSE.Simp_Out_Start₃ (prop_outgoingᵤ Out_Mem₁ᵤ);     /- := out₁.START = RULEᵤ.CENTER -/
                                                             --
                                                             have Iff_Out_Colourᵤ := prop_out_coloursᵤ Out_Mem₁ᵤ eq_out_memᵤ (Or.inr eq_out_colourᵤ);
                                                             simp only [Deduction.edge.injEq'] at Out_Start₁ᵤ Iff_Out_Colourᵤ;
                                                             simp only [Out_Start₁ᵤ, Eq_Out_Colourᵤ, true_and] at Iff_Out_Colourᵤ;
                                                             exact Iff_Out_Colourᵤ;
                                          | inr out_mem₂ᵤ => rewrite [REWRITE.Get_Start_RwOutgoing out_mem₁ᵤ];              /- := out₁.START = collapse.center RULEᵤ.CENTER RULEᵥ.CENTER -/
                                                             rewrite [REWRITE.Get_Start_RwOutgoing out_mem₂ᵤ];              /- := out₂.START = collapse.center RULEᵤ.CENTER RULEᵥ.CENTER -/
                                                             simp only [true_and];
                                                             --
                                                             have Out_Cases₁ᵤ := REWRITE.Mem_Of_Mem_RwOutgoing out_mem₁ᵤ;               /- := out₁ ∈ RULEᵥ.OUTGOING -/
                                                             cases Out_Cases₁ᵤ with | intro Original₁ᵤ Out_Mem₁ᵤ =>
                                                             have Out_Start₁ᵤ := COLLAPSE.Simp_Out_Start₃ (prop_outgoingᵤ Out_Mem₁ᵤ);   /- := out₁.START = RULEᵤ.CENTER -/
                                                             have Out_Cases₂ᵤ := REWRITE.Mem_Of_Mem_RwOutgoing out_mem₂ᵤ;               /- := out₂ ∈ RULEᵥ.OUTGOING -/
                                                             cases Out_Cases₂ᵤ with | intro Original₂ᵤ Out_Mem₂ᵤ =>
                                                             have Out_Start₂ᵤ := COLLAPSE.Simp_Out_Start₃ (prop_outgoingᵤ Out_Mem₂ᵤ);   /- := out₂.START = RULEᵤ.CENTER -/
                                                             --
                                                             have Iff_Out_Colourᵤ := prop_out_coloursᵤ Out_Mem₁ᵤ Out_Mem₂ᵤ gt_zero₁₂;
                                                             simp only [Deduction.edge.injEq] at Out_Start₁ᵤ Out_Start₂ᵤ Iff_Out_Colourᵤ;
                                                             simp only [Out_Start₁ᵤ, Out_Start₂ᵤ, true_and] at Iff_Out_Colourᵤ;
                                                             exact Iff_Out_Colourᵤ; );
  apply And.intro ( by intro case_hpt;                                /- := ( RULE.CENTER.HYPOTHESIS = false ) → ( RULE.DIRECT = [] ) -/
                       rewrite [Bool.or_eq_false_iff] at case_hpt;
                       cases case_hpt with | intro case_hptᵤ case_hptᵥ =>
                       simp only [prop_dir_nilᵤ case_hptᵤ, prop_dir_nilᵥ case_hptᵥ];
                       simp only [collapse.rewrite_direct];
                       trivial; );
  apply And.intro ( by intro case_dir_cons;                           /- := ( RULE.DIRECT ≠ [] ) → ( RULE.CENTER.HYPOTHESIS = true ) -/
                       simp only [Bool.or_eq_true];
                       cases List.NeNil_Or_NeNil_Of_NeNil_Append case_dir_cons with
                       | inl case_dir_consᵥ => exact Or.inr (prop_dir_consᵥ (REWRITE.NeNil_RwDirect case_dir_consᵥ));
                       | inr case_dir_consᵤ => exact Or.inl (prop_dir_consᵤ (REWRITE.NeNil_RwDirect case_dir_consᵤ)); );
  apply And.intro ( by simp only [List.length_append];                /- := List.length (RULE.INDIRECT) = List.length (RULE.INCOMING) -/
                       simp only [REWRITE.Eq_Length_RwIncoming];
                       simp only [prop_ind_lenᵤ, prop_ind_lenᵥ]; );
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  /- Incoming Edges -/------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  apply And.intro ( by simp only [type_incoming] at prop_incomingᵤ prop_incomingᵥ ⊢;
                       simp only [List.Mem_Or_Mem_Iff_Mem_Append];
                       intro inc inc_cases;
                       cases inc_cases with
                       | inl inc_casesᵥ => have Inc_Caseᵥ := REWRITE.Mem_Of_Mem_RwIncoming inc_casesᵥ;            /- := inc ∈ RULEᵥ.INCOMING -/
                                           cases Inc_Caseᵥ with | intro Originalᵥ Inc_Memᵥ =>
                                           have Prop_Incomingᵥ := prop_incomingᵥ Inc_Memᵥ;                        /- := type_incoming.check inc RULEᵥ.CENTER -/
                                           simp only [type_incoming.check] at Prop_Incomingᵥ ⊢;
                                           cases Prop_Incomingᵥ with | intro Prop_Startᵥ Prop_Incomingᵥ =>
                                           cases Prop_Incomingᵥ with | intro Prop_Endᵥ Prop_Incomingᵥ =>
                                           cases Prop_Incomingᵥ with | intro Prop_Colourᵥ Prop_Inc_Indᵥ =>
                                           --
                                           apply And.intro ( by rewrite [prop_eq_lvl];                            /- := Start Node -/
                                                                exact Prop_Startᵥ; );
                                           apply And.intro ( by exact REWRITE.Get_End_RwIncoming inc_casesᵥ; );   /- := End Node -/
                                           apply And.intro ( by exact Prop_Colourᵥ; );                            /- := Colours -/
                                           /- := Check Incoming-Indirect Duo: -/
                                           cases Prop_Inc_Indᵥ with | intro Colourᵥ Prop_Inc_Indᵥ =>
                                           cases Prop_Inc_Indᵥ with | intro Coloursᵥ Prop_Inc_Indᵥ =>
                                           cases Prop_Inc_Indᵥ with | intro Ancᵥ Prop_Inc_Indᵥ =>
                                           --
                                           apply Exists.intro Colourᵥ;
                                           apply Exists.intro Coloursᵥ;
                                           apply Exists.intro Ancᵥ;
                                           exact ( by simp only [List.Mem_Or_Mem_Iff_Mem_Append];                 /- := path anc INC.START (0::colour::colours) ∈ INDIRECT -/
                                                      apply Or.inl;
                                                      exact Prop_Inc_Indᵥ; );
                       | inr inc_casesᵤ => have Inc_Caseᵤ := REWRITE.Mem_Of_Mem_RwIncoming inc_casesᵤ;            /- := inc ∈ RULEᵤ.INCOMING -/
                                           cases Inc_Caseᵤ with | intro Originalᵤ Inc_Memᵤ =>
                                           have Prop_Incomingᵤ := prop_incomingᵤ Inc_Memᵤ;                        /- := type_incoming.check inc RULEᵤ.CENTER -/
                                           simp only [type_incoming.check] at Prop_Incomingᵤ ⊢;
                                           cases Prop_Incomingᵤ with | intro Prop_Startᵤ Prop_Incomingᵤ =>
                                           cases Prop_Incomingᵤ with | intro Prop_Endᵤ Prop_Incomingᵤ =>
                                           cases Prop_Incomingᵤ with | intro Prop_Colourᵤ Prop_Inc_Indᵤ =>
                                           --
                                           apply And.intro ( by exact Prop_Startᵤ; );                             /- := Start Node -/
                                           apply And.intro ( by exact REWRITE.Get_End_RwIncoming inc_casesᵤ; );   /- := End Node -/
                                           apply And.intro ( by exact Prop_Colourᵤ; );                            /- := Colours -/
                                           /- := Check Incoming-Indirect Duo: -/
                                           cases Prop_Inc_Indᵤ with | intro Colourᵤ Prop_Inc_Indᵤ =>
                                           cases Prop_Inc_Indᵤ with | intro Coloursᵤ Prop_Inc_Indᵤ =>
                                           cases Prop_Inc_Indᵤ with | intro Ancᵤ Prop_Inc_Indᵤ =>
                                           --
                                           apply Exists.intro Colourᵤ;
                                           apply Exists.intro Coloursᵤ;
                                           apply Exists.intro Ancᵤ;
                                           exact ( by simp only [List.Mem_Or_Mem_Iff_Mem_Append];                 /- := path anc INC.START (0::colour::colours) ∈ INDIRECT -/
                                                      apply Or.inr;
                                                      exact Prop_Inc_Indᵤ; ); );
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  /- Outgoing Edges -/------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  apply And.intro ( by simp only [type_outgoing₃] at prop_outgoingᵤ prop_outgoingᵥ ⊢;
                       simp only [List.Mem_Or_Mem_Iff_Mem_Append];
                       intro out out_cases;
                       cases out_cases with
                       | inl out_casesᵥ => have Out_Caseᵥ := REWRITE.Mem_Of_Mem_RwOutgoing out_casesᵥ;          /- := out ∈ RULEᵥ.OUTGOING -/
                                           cases Out_Caseᵥ with | intro Originalᵥ Out_Memᵥ =>
                                           have Prop_Outgoingᵥ := prop_outgoingᵥ Out_Memᵥ;                      /- := type_outgoing.check out RULEᵥ.CENTER -/
                                           cases Prop_Outgoingᵥ with
                                           | inl Prop_Outgoing₁ᵥ => cases Prop_Outgoing₁ᵥ with
                                                                    | inl Prop_Outgoingₕ₁ᵥ => simp only [type_outgoing₁.check_h₁] at Prop_Outgoingₕ₁ᵥ ⊢;
                                                                                              cases Prop_Outgoingₕ₁ᵥ with | intro Prop_HPTₕ₁ᵥ Prop_Outgoingₕ₁ᵥ =>
                                                                                              cases Prop_Outgoingₕ₁ᵥ with | intro Prop_Startₕ₁ᵥ Prop_Outgoingₕ₁ᵥ =>
                                                                                              cases Prop_Outgoingₕ₁ᵥ with | intro Prop_Endₕ₁ᵥ Prop_Colourₕ₁ᵥ =>
                                                                                              --
                                                                                              apply Or.inl; apply Or.inl;
                                                                                              apply And.intro ( by rewrite [Bool.or_eq_true_iff];                       /- := Type 1 Hypothesis -/
                                                                                                                   exact Or.inr Prop_HPTₕ₁ᵥ; );
                                                                                              apply And.intro ( by exact REWRITE.Get_Start_RwOutgoing out_casesᵥ; );    /- := Start Node -/
                                                                                              apply And.intro ( by rewrite [prop_eq_lvl];                               /- := End Node -/
                                                                                                                   exact Prop_Endₕ₁ᵥ; );
                                                                                              exact Prop_Colourₕ₁ᵥ;                                                     /- := Colours -/
                                                                    | inr Prop_Outgoingᵢₑ₁ᵥ => simp only [type_outgoing₁.check_ie₁] at Prop_Outgoingᵢₑ₁ᵥ ⊢;
                                                                                               cases Prop_Outgoingᵢₑ₁ᵥ with | intro Prop_HPTᵢₑ₁ᵥ Prop_Outgoingᵢₑ₁ᵥ =>
                                                                                               cases Prop_Outgoingᵢₑ₁ᵥ with | intro Prop_Startᵢₑ₁ᵥ Prop_Outgoingᵢₑ₁ᵥ =>
                                                                                               cases Prop_Outgoingᵢₑ₁ᵥ with | intro Prop_Endᵢₑ₁ᵥ Prop_Outgoingᵢₑ₁ᵥ =>
                                                                                               cases Prop_Outgoingᵢₑ₁ᵥ with | intro Prop_Colourᵢₑ₁ᵥ Prop_Out_Indᵢₑ₁ᵥ =>
                                                                                               --
                                                                                               apply Or.inl; apply Or.inr;
                                                                                               apply And.intro ( by exact Or.inr trivial; );                                                 /- := Type 1 Introduction & Elimination -/
                                                                                               apply And.intro ( by exact REWRITE.Get_Start_RwOutgoing out_casesᵥ; );                        /- := Start Node -/
                                                                                               apply And.intro ( by rewrite [prop_eq_lvl];                                                   /- := End Node -/
                                                                                                                    exact Prop_Endᵢₑ₁ᵥ; );
                                                                                               apply And.intro ( by rewrite [prop_pstᵥ, List.Eq_Iff_Mem_Unit] at Prop_Colourᵢₑ₁ᵥ;            /- := Colours -/
                                                                                                                    rewrite [Prop_Colourᵢₑ₁ᵥ];
                                                                                                                    exact List.Mem.tail ( RULEᵤ.CENTER.NUMBER )
                                                                                                                                        ( List.Mem.head RULEᵤ.CENTER.PAST ) );
                                                                                               /- := Check Outgoing-Indirect Duo: -/
                                                                                               cases Prop_Out_Indᵢₑ₁ᵥ with | intro Incᵢₑ₁ᵥ Prop_Out_Indᵢₑ₁ᵥ =>
                                                                                               --
                                                                                               apply Exists.intro Incᵢₑ₁ᵥ;
                                                                                               exact ( by simp only [List.Mem_Or_Mem_Iff_Mem_Append];                   /- := path OUT.END inc [0, OUT.COLOUR] ∈ INDIRECT -/
                                                                                                           apply Or.inl;
                                                                                                           exact Prop_Out_Indᵢₑ₁ᵥ; );
                                           | inr Prop_Outgoing₃ᵥ => cases Prop_Outgoing₃ᵥ with
                                                                    | inl Prop_Outgoingₕ₃ᵥ => simp only [type_outgoing₃.check_h₃] at Prop_Outgoingₕ₃ᵥ ⊢;
                                                                                              cases Prop_Outgoingₕ₃ᵥ with | intro Prop_HPTₕ₃ᵥ Prop_Outgoingₕ₃ᵥ =>
                                                                                              cases Prop_Outgoingₕ₃ᵥ with | intro Prop_Startₕ₃ᵥ Prop_Outgoingₕ₃ᵥ =>
                                                                                              cases Prop_Outgoingₕ₃ᵥ with | intro Prop_Endₕ₃ᵥ Prop_Outgoingₕ₃ᵥ =>
                                                                                              cases Prop_Outgoingₕ₃ᵥ with | intro Prop_Colourₕ₃ᵥ Prop_Out_Dirₕ₃ᵥ =>
                                                                                              --
                                                                                              apply Or.inr; apply Or.inl;
                                                                                              apply And.intro ( by rewrite [Bool.or_eq_true_iff];                                            /- := Type 3 Hypothesis -/
                                                                                                                   exact Or.inr Prop_HPTₕ₃ᵥ; );
                                                                                              apply And.intro ( by exact REWRITE.Get_Start_RwOutgoing out_casesᵥ; );                         /- := Start Node -/
                                                                                              apply And.intro ( by rewrite [prop_eq_lvl];                                                    /- := End Node -/
                                                                                                                   exact Prop_Endₕ₃ᵥ; );
                                                                                              apply And.intro ( by rewrite [prop_pstᵥ, List.Eq_Iff_Mem_Unit] at Prop_Colourₕ₃ᵥ;              /- := Colours -/
                                                                                                                   rewrite [Prop_Colourₕ₃ᵥ];
                                                                                                                   exact List.Mem.tail ( RULEᵤ.CENTER.NUMBER )
                                                                                                                                       ( List.Mem.head RULEᵤ.CENTER.PAST ) );
                                                                                              /- := Check Outgoing-Direct Duo: -/
                                                                                              cases Prop_Out_Dirₕ₃ᵥ with | intro Coloursₕ₃ᵥ Prop_Out_Dirₕ₃ᵥ =>
                                                                                              cases Prop_Out_Dirₕ₃ᵥ with | intro Ancₕ₃ᵥ Prop_Out_Dirₕ₃ᵥ =>
                                                                                              --
                                                                                              apply Exists.intro Coloursₕ₃ᵥ;
                                                                                              apply Exists.intro Ancₕ₃ᵥ;
                                                                                              exact ( by simp only [List.Mem_Or_Mem_Iff_Mem_Append];                    /- := path anc CENTER (OUT.COLOUR::colours) ∈ DIRECT -/
                                                                                                         apply Or.inl;
                                                                                                         exact REWRITE.Mem_RwDirect_Of_Mem Prop_Out_Dirₕ₃ᵥ; );
                                                                    | inr Prop_Outgoingᵢₑ₃ᵥ => simp only [type_outgoing₃.check_ie₃] at Prop_Outgoingᵢₑ₃ᵥ ⊢;
                                                                                               cases Prop_Outgoingᵢₑ₃ᵥ with | intro Prop_HPTᵢₑ₃ᵥ Prop_Outgoingᵢₑ₃ᵥ =>
                                                                                               cases Prop_Outgoingᵢₑ₃ᵥ with | intro Prop_Startᵢₑ₃ᵥ Prop_Outgoingᵢₑ₃ᵥ =>
                                                                                               cases Prop_Outgoingᵢₑ₃ᵥ with | intro Prop_Endᵢₑ₃ᵥ Prop_Outgoingᵢₑ₃ᵥ =>
                                                                                               cases Prop_Outgoingᵢₑ₃ᵥ with | intro Prop_Colourᵢₑ₃ᵥ Prop_Out_Indᵢₑ₃ᵥ =>
                                                                                               --
                                                                                               apply Or.inr; apply Or.inr;
                                                                                               apply And.intro ( by exact Or.inr trivial; );                                                 /- := Type 3 Introduction & Elimination -/
                                                                                               apply And.intro ( by exact REWRITE.Get_Start_RwOutgoing out_casesᵥ; );                        /- := Start Node -/
                                                                                               apply And.intro ( by rewrite [prop_eq_lvl];                                                   /- := End Node -/
                                                                                                                    exact Prop_Endᵢₑ₃ᵥ; );
                                                                                               apply And.intro ( by rewrite [prop_pstᵥ, List.Eq_Iff_Mem_Unit] at Prop_Colourᵢₑ₃ᵥ;            /- := Colours -/
                                                                                                                    rewrite [Prop_Colourᵢₑ₃ᵥ];
                                                                                                                    exact List.Mem.tail ( RULEᵤ.CENTER.NUMBER )
                                                                                                                                        ( List.Mem.head RULEᵤ.CENTER.PAST ) );
                                                                                               /- := Check Outgoing-Indirect Duo: -/
                                                                                               cases Prop_Out_Indᵢₑ₃ᵥ with | intro Coloursᵢₑ₃ᵥ Prop_Out_Indᵢₑ₃ᵥ =>
                                                                                               cases Prop_Out_Indᵢₑ₃ᵥ with | intro Incᵢₑ₃ᵥ Prop_Out_Indᵢₑ₃ᵥ =>
                                                                                               cases Prop_Out_Indᵢₑ₃ᵥ with | intro Ancᵢₑ₃ᵥ Prop_Out_Indᵢₑ₃ᵥ =>
                                                                                               --
                                                                                               apply Exists.intro Coloursᵢₑ₃ᵥ;
                                                                                               apply Exists.intro Incᵢₑ₃ᵥ;
                                                                                               apply Exists.intro Ancᵢₑ₃ᵥ;
                                                                                               exact ( by simp only [List.Mem_Or_Mem_Iff_Mem_Append];                   /- := path anc inc (0::OUT.COLOUR::colours) ∈ INDIRECT -/
                                                                                                          apply Or.inl;
                                                                                                          exact Prop_Out_Indᵢₑ₃ᵥ; );
                       | inr out_casesᵤ => have Out_Caseᵤ := REWRITE.Mem_Of_Mem_RwOutgoing out_casesᵤ;          /- := out ∈ RULEᵤ.OUTGOING -/
                                           cases Out_Caseᵤ with | intro Originalᵤ Out_Memᵤ =>
                                           have Prop_Outgoingᵤ := prop_outgoingᵤ Out_Memᵤ;                      /- := type_outgoing.check out RULEᵤ.CENTER -/
                                           cases Prop_Outgoingᵤ with
                                           | inl Prop_Outgoing₁ᵤ => cases Prop_Outgoing₁ᵤ with
                                                                    | inl Prop_Outgoingₕ₁ᵤ => simp only [type_outgoing₁.check_h₁] at Prop_Outgoingₕ₁ᵤ ⊢;
                                                                                              cases Prop_Outgoingₕ₁ᵤ with | intro Prop_HPTₕ₁ᵤ Prop_Outgoingₕ₁ᵤ =>
                                                                                              cases Prop_Outgoingₕ₁ᵤ with | intro Prop_Startₕ₁ᵤ Prop_Outgoingₕ₁ᵤ =>
                                                                                              cases Prop_Outgoingₕ₁ᵤ with | intro Prop_Endₕ₁ᵤ Prop_Colourₕ₁ᵤ =>
                                                                                              --
                                                                                              apply Or.inl; apply Or.inl;
                                                                                              apply And.intro ( by rewrite [Bool.or_eq_true_iff];                       /- := Type 1 Hypothesis -/
                                                                                                                   exact Or.inl Prop_HPTₕ₁ᵤ; );
                                                                                              apply And.intro ( by exact REWRITE.Get_Start_RwOutgoing out_casesᵤ; );    /- := Start Node -/
                                                                                              apply And.intro ( by exact Prop_Endₕ₁ᵤ; );                                /- := End Node -/
                                                                                              exact Prop_Colourₕ₁ᵤ;                                                     /- := Colours -/
                                                                    | inr Prop_Outgoingᵢₑ₁ᵤ => simp only [type_outgoing₁.check_ie₁] at Prop_Outgoingᵢₑ₁ᵤ ⊢;
                                                                                               cases Prop_Outgoingᵢₑ₁ᵤ with | intro Prop_HPTᵢₑ₁ᵤ Prop_Outgoingᵢₑ₁ᵤ =>
                                                                                               cases Prop_Outgoingᵢₑ₁ᵤ with | intro Prop_Startᵢₑ₁ᵤ Prop_Outgoingᵢₑ₁ᵤ =>
                                                                                               cases Prop_Outgoingᵢₑ₁ᵤ with | intro Prop_Endᵢₑ₁ᵤ Prop_Outgoingᵢₑ₁ᵤ =>
                                                                                               cases Prop_Outgoingᵢₑ₁ᵤ with | intro Prop_Colourᵢₑ₁ᵤ Prop_Out_Indᵢₑ₁ᵤ =>
                                                                                               --
                                                                                               apply Or.inl; apply Or.inr;
                                                                                               apply And.intro ( by exact Or.inr trivial; );                                                 /- := Type 1 Introduction & Elimination -/
                                                                                               apply And.intro ( by exact REWRITE.Get_Start_RwOutgoing out_casesᵤ; );                        /- := Start Node -/
                                                                                               apply And.intro ( by exact Prop_Endᵢₑ₁ᵤ; );                                                   /- := End Node -/
                                                                                               apply And.intro ( by rewrite [List.Eq_Or_Mem_Iff_Mem_Cons] at Prop_Colourᵢₑ₁ᵤ;                /- := Colours -/
                                                                                                                    cases Prop_Colourᵢₑ₁ᵤ with
                                                                                                                    | inl Prop_NBR_Colourᵢₑ₁ᵤ => rewrite [Prop_NBR_Colourᵢₑ₁ᵤ];
                                                                                                                                                 exact List.Mem.head ( RULEᵥ.CENTER.NUMBER :: RULEᵤ.CENTER.PAST );
                                                                                                                    | inr Prop_PST_Colourᵢₑ₁ᵤ => exact List.Mem.tail ( RULEᵤ.CENTER.NUMBER )
                                                                                                                                                                     ( List.Mem.tail RULEᵥ.CENTER.NUMBER Prop_PST_Colourᵢₑ₁ᵤ ); );
                                                                                               /- := Check Outgoing-Indirect Duo: -/
                                                                                               cases Prop_Out_Indᵢₑ₁ᵤ with | intro Incᵢₑ₁ᵤ Prop_Out_Indᵢₑ₁ᵤ =>
                                                                                               --
                                                                                               apply Exists.intro Incᵢₑ₁ᵤ;
                                                                                               exact ( by simp only [List.Mem_Or_Mem_Iff_Mem_Append];                   /- := path OUT.END inc [0, OUT.COLOUR] ∈ INDIRECT -/
                                                                                                           apply Or.inr;
                                                                                                           exact Prop_Out_Indᵢₑ₁ᵤ; );
                                           | inr Prop_Outgoing₃ᵤ => cases Prop_Outgoing₃ᵤ with
                                                                    | inl Prop_Outgoingₕ₃ᵤ => simp only [type_outgoing₃.check_h₃] at Prop_Outgoingₕ₃ᵤ ⊢;
                                                                                              cases Prop_Outgoingₕ₃ᵤ with | intro Prop_HPTₕ₃ᵤ Prop_Outgoingₕ₃ᵤ =>
                                                                                              cases Prop_Outgoingₕ₃ᵤ with | intro Prop_Startₕ₃ᵤ Prop_Outgoingₕ₃ᵤ =>
                                                                                              cases Prop_Outgoingₕ₃ᵤ with | intro Prop_Endₕ₃ᵤ Prop_Outgoingₕ₃ᵤ =>
                                                                                              cases Prop_Outgoingₕ₃ᵤ with | intro Prop_Colourₕ₃ᵤ Prop_Out_Dirₕ₃ᵤ =>
                                                                                              --
                                                                                              apply Or.inr; apply Or.inl;
                                                                                              apply And.intro ( by rewrite [Bool.or_eq_true_iff];                       /- := Type 1 Hypothesis -/
                                                                                                                   exact Or.inl Prop_HPTₕ₃ᵤ; );
                                                                                              apply And.intro ( by exact REWRITE.Get_Start_RwOutgoing out_casesᵤ; );    /- := Start Node -/
                                                                                              apply And.intro ( by exact Prop_Endₕ₃ᵤ; );                                /- := End Node -/
                                                                                              apply And.intro ( by rewrite [List.Eq_Or_Mem_Iff_Mem_Cons] at Prop_Colourₕ₃ᵤ;                  /- := Colours -/
                                                                                                                   cases Prop_Colourₕ₃ᵤ with
                                                                                                                   | inl Prop_NBR_Colourᵢₑ₃ᵤ => rewrite [Prop_NBR_Colourᵢₑ₃ᵤ];
                                                                                                                                                exact List.Mem.head ( RULEᵥ.CENTER.NUMBER :: RULEᵤ.CENTER.PAST );
                                                                                                                   | inr Prop_PST_Colourᵢₑ₃ᵤ => exact List.Mem.tail ( RULEᵤ.CENTER.NUMBER )
                                                                                                                                                                    ( List.Mem.tail RULEᵥ.CENTER.NUMBER Prop_PST_Colourᵢₑ₃ᵤ ); );
                                                                                              /- := Check Outgoing-Direct Duo: -/
                                                                                              cases Prop_Out_Dirₕ₃ᵤ with | intro Coloursₕ₃ᵤ Prop_Out_Dirₕ₃ᵤ =>
                                                                                              cases Prop_Out_Dirₕ₃ᵤ with | intro Ancₕ₃ᵤ Prop_Out_Dirₕ₃ᵤ =>
                                                                                              --
                                                                                              apply Exists.intro Coloursₕ₃ᵤ;
                                                                                              apply Exists.intro Ancₕ₃ᵤ;
                                                                                              exact ( by simp only [List.Mem_Or_Mem_Iff_Mem_Append];                    /- := path anc CENTER (OUT.COLOUR::colours) ∈ DIRECT -/
                                                                                                         apply Or.inr;
                                                                                                         exact REWRITE.Mem_RwDirect_Of_Mem Prop_Out_Dirₕ₃ᵤ; );
                                                                    | inr Prop_Outgoingᵢₑ₃ᵤ => simp only [type_outgoing₃.check_ie₃] at Prop_Outgoingᵢₑ₃ᵤ ⊢;
                                                                                               cases Prop_Outgoingᵢₑ₃ᵤ with | intro Prop_HPTᵢₑ₃ᵤ Prop_Outgoingᵢₑ₃ᵤ =>
                                                                                               cases Prop_Outgoingᵢₑ₃ᵤ with | intro Prop_Startᵢₑ₃ᵤ Prop_Outgoingᵢₑ₃ᵤ =>
                                                                                               cases Prop_Outgoingᵢₑ₃ᵤ with | intro Prop_Endᵢₑ₃ᵤ Prop_Outgoingᵢₑ₃ᵤ =>
                                                                                               cases Prop_Outgoingᵢₑ₃ᵤ with | intro Prop_Colourᵢₑ₃ᵤ Prop_Out_Indᵢₑ₃ᵤ =>
                                                                                               --
                                                                                               apply Or.inr; apply Or.inr;
                                                                                               apply And.intro ( by exact Or.inr trivial; );                            /- := Type 1 Introduction & Elimination -/
                                                                                               apply And.intro ( by exact REWRITE.Get_Start_RwOutgoing out_casesᵤ; );   /- := Start Node -/
                                                                                               apply And.intro ( by exact Prop_Endᵢₑ₃ᵤ; );                              /- := End Node -/
                                                                                               apply And.intro ( by rewrite [List.Eq_Or_Mem_Iff_Mem_Cons] at Prop_Colourᵢₑ₃ᵤ;                /- := Colours -/
                                                                                                                    cases Prop_Colourᵢₑ₃ᵤ with
                                                                                                                    | inl Prop_NBR_Colourᵢₑ₃ᵤ => rewrite [Prop_NBR_Colourᵢₑ₃ᵤ];
                                                                                                                                                 exact List.Mem.head ( RULEᵥ.CENTER.NUMBER :: RULEᵤ.CENTER.PAST );
                                                                                                                    | inr Prop_PST_Colourᵢₑ₃ᵤ => exact List.Mem.tail ( RULEᵤ.CENTER.NUMBER )
                                                                                                                                                                     ( List.Mem.tail RULEᵥ.CENTER.NUMBER Prop_PST_Colourᵢₑ₃ᵤ ); );
                                                                                               /- := Check Outgoing-Indirect Duo: -/
                                                                                               cases Prop_Out_Indᵢₑ₃ᵤ with | intro Coloursᵢₑ₃ᵤ Prop_Out_Indᵢₑ₃ᵤ =>
                                                                                               cases Prop_Out_Indᵢₑ₃ᵤ with | intro Incᵢₑ₃ᵤ Prop_Out_Indᵢₑ₃ᵤ =>
                                                                                               cases Prop_Out_Indᵢₑ₃ᵤ with | intro Ancᵢₑ₃ᵤ Prop_Out_Indᵢₑ₃ᵤ =>
                                                                                               --
                                                                                               apply Exists.intro Coloursᵢₑ₃ᵤ;
                                                                                               apply Exists.intro Incᵢₑ₃ᵤ;
                                                                                               apply Exists.intro Ancᵢₑ₃ᵤ;
                                                                                               exact ( by simp only [List.Mem_Or_Mem_Iff_Mem_Append];                   /- := path anc inc (0::OUT.COLOUR::colours) ∈ INDIRECT -/
                                                                                                          apply Or.inr;
                                                                                                          exact Prop_Out_Indᵢₑ₃ᵤ; ); );
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  /- Direct Paths -/--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  apply And.intro ( by simp only [type_direct] at prop_directᵤ prop_directᵥ ⊢;
                       simp only [List.Mem_Or_Mem_Iff_Mem_Append];
                       intro dir dir_cases;
                       cases dir_cases with
                       | inl dir_casesᵥ => have Dir_Casesᵥ := REWRITE.Mem_Of_Mem_RwDirect dir_casesᵥ;
                                           cases Dir_Casesᵥ with | intro Originalᵥ Dir_Memᵥ =>
                                           have Prop_Directᵥ := prop_directᵥ Dir_Memᵥ;
                                           simp only [type_direct.check] at Prop_Directᵥ ⊢;
                                           cases Prop_Directᵥ with | intro Prop_Startᵥ Prop_Directᵥ =>
                                           cases Prop_Directᵥ with | intro Prop_Endᵥ Prop_Directᵥ =>
                                           cases Prop_Directᵥ with | intro Prop_Levelᵥ Prop_Directᵥ =>
                                           cases Prop_Directᵥ with | intro Colour₁ᵥ Prop_Directᵥ =>
                                           cases Prop_Directᵥ with | intro Colour₂ᵥ Prop_Directᵥ =>
                                           cases Prop_Directᵥ with | intro Coloursᵥ Prop_Directᵥ =>
                                           cases Prop_Directᵥ with | intro Prop_Check_Coloursᵥ Prop_Directᵥ =>
                                           cases Prop_Directᵥ with | intro Prop_Colour₁ᵥ Prop_Directᵥ =>
                                           cases Prop_Directᵥ with | intro Prop_Coloursᵥ Prop_Dir_Outᵥ =>
                                           --
                                           apply And.intro ( by rewrite [prop_eq_lvl];                          /- := Start Node -/
                                                                exact Prop_Startᵥ; );
                                           apply And.intro ( by exact REWRITE.Get_End_RwDirect dir_casesᵥ; );   /- := End Node -/
                                           apply And.intro ( by rewrite [prop_eq_lvl];                          /- := Colours -/
                                                                exact Prop_Levelᵥ; );
                                           apply Exists.intro Colour₁ᵥ;
                                           apply Exists.intro Colour₂ᵥ;
                                           apply Exists.intro Coloursᵥ;
                                           apply And.intro ( by exact Prop_Check_Coloursᵥ; );
                                           apply And.intro ( by rewrite [prop_pstᵥ, List.Eq_Iff_Mem_Unit] at Prop_Colour₁ᵥ;
                                                                rewrite [Prop_Colour₁ᵥ];
                                                                exact List.Mem.tail ( RULEᵤ.CENTER.NUMBER )
                                                                                    ( List.Mem.head RULEᵤ.CENTER.PAST ); );
                                           apply And.intro ( by exact Prop_Coloursᵥ; );
                                           /- := Check Direct-Outgoing Duo: -/
                                           cases Prop_Dir_Outᵥ with | intro Outᵥ Prop_Dir_Outᵥ =>
                                           cases Prop_Dir_Outᵥ with | intro Dep_Outᵥ Prop_Dir_Outᵥ =>
                                           cases Prop_Dir_Outᵥ with | intro Prop_Out_Colᵥ Prop_Dir_Outᵥ =>
                                           cases Prop_Dir_Outᵥ with | intro Prop_Colour₂ᵥ Prop_Dir_Outᵥ =>
                                           cases Prop_Dir_Outᵥ with | intro Prop_Dir_Outᵥ Prop_All_Dir_Outᵥ =>
                                           --
                                           apply Exists.intro Outᵥ;
                                           apply Exists.intro Dep_Outᵥ;
                                           apply And.intro ( by exact Prop_Out_Colᵥ; );
                                           apply And.intro ( by exact Prop_Colour₂ᵥ; );
                                           apply And.intro ( by simp only [List.Mem_Or_Mem_Iff_Mem_Append];     /- := edge CENTER out colour₁ dep_out ∈ OUTGOING -/
                                                                apply Or.inl;
                                                                rewrite [←collapse.center];
                                                                exact REWRITE.Mem_RwOutgoing_Of_Mem Prop_Dir_Outᵥ; );
                                           intro all_outᵥ all_out_casesᵥ;                                       /- := all_out.COLOUR = colour₁ ↔ all_out = edge CENTER out colour₁ dep_out -/
                                           simp only [List.Mem_Or_Mem_Iff_Mem_Append] at all_out_casesᵥ;
                                           cases all_out_casesᵥ with
                                           | inl all_out_casesᵥᵥ => have Dir_Out_Casesᵥᵥ := REWRITE.Mem_Of_Mem_RwOutgoing all_out_casesᵥᵥ;                      /- := all_out ∈ RULEᵥ.OUTGOING -/
                                                                    cases Dir_Out_Casesᵥᵥ with | intro Originalᵥ Dir_Out_Memᵥᵥ =>
                                                                    --
                                                                    have Prop_All_Dir_Outᵥᵥ := Prop_All_Dir_Outᵥ Dir_Out_Memᵥᵥ;                                 /- := all_out.COLOUR = Colour₁ ↔ all_out = edge CENTER out Colour₁ dep_out -/
                                                                    rewrite [Deduction.edge.injEq] at Prop_All_Dir_Outᵥᵥ ⊢;
                                                                    --
                                                                    rewrite [←COLLAPSE.Simp_Out_Start₃ (prop_outgoingᵥ Dir_Out_Memᵥᵥ)] at Prop_All_Dir_Outᵥᵥ;   /- := all_out.START = RULEᵥ.CENTER -/
                                                                    rewrite [←REWRITE.Get_Start_RwOutgoing all_out_casesᵥᵥ];                                    /- := all_out.START = collapse.center RULEᵤ.CENTER RULEᵥ.CENTER -/
                                                                    simp only [true_and] at Prop_All_Dir_Outᵥᵥ ⊢;
                                                                    exact Prop_All_Dir_Outᵥᵥ;
                                           | inr all_out_casesᵥᵤ => have Dir_Out_Casesᵥᵤ := REWRITE.Mem_Of_Mem_RwOutgoing all_out_casesᵥᵤ;                      /- := all_out ∈ RULEᵤ.OUTGOING -/
                                                                    cases Dir_Out_Casesᵥᵤ with | intro Originalᵤ Dir_Out_Memᵥᵤ =>
                                                                    --
                                                                    have Prop_All_Outᵤ := prop_out_coloursᵤ Dir_Out_Memᵥᵤ eq_out_memᵤ (Or.inr eq_out_colourᵤ);  /- := all_out.COLOUR = eq_out.COLOUR ↔ all_out = eq_out -/
                                                                    rewrite [Deduction.edge.injEq] at Prop_All_Outᵤ ⊢;
                                                                    rewrite [←REWRITE.Get_Start_RwOutgoing all_out_casesᵥᵤ];                                    /- := all_out.START = collapse.center RULEᵤ.CENTER RULEᵥ.CENTER -/
                                                                    simp only [true_and] at Prop_All_Outᵤ ⊢;
                                                                    --
                                                                    rewrite [prop_out_unitᵥ] at Prop_Dir_Outᵥ;
                                                                    simp only [List.Eq_Iff_Mem_Unit] at Prop_Dir_Outᵥ;
                                                                    simp only [←Prop_Dir_Outᵥ] at prop_eq_out_end prop_eq_out_colour prop_eq_out_dependency;
                                                                    rewrite [prop_eq_out_end, prop_eq_out_colour, prop_eq_out_dependency];
                                                                    --
                                                                    exact Iff.intro ( by intro iff_eq_colourᵥᵤ;
                                                                                         rewrite [Prop_All_Outᵤ] at iff_eq_colourᵥᵤ;
                                                                                         simp only [iff_eq_colourᵥᵤ];
                                                                                         trivial; )
                                                                                    ( by intro iff_eq_edgeᵥᵤ;
                                                                                         simp only [iff_eq_edgeᵥᵤ]; );
                       | inr dir_casesᵤ => have Dir_Casesᵤ := REWRITE.Mem_Of_Mem_RwDirect dir_casesᵤ;
                                           cases Dir_Casesᵤ with | intro Originalᵤ Dir_Memᵤ =>
                                           have Prop_Directᵤ := prop_directᵤ Dir_Memᵤ;
                                           simp only [type_direct.check] at Prop_Directᵤ ⊢;
                                           cases Prop_Directᵤ with | intro Prop_Startᵤ Prop_Directᵤ =>
                                           cases Prop_Directᵤ with | intro Prop_Endᵤ Prop_Directᵤ =>
                                           cases Prop_Directᵤ with | intro Prop_Levelᵤ Prop_Directᵤ =>
                                           cases Prop_Directᵤ with | intro Colour₁ᵤ Prop_Directᵤ =>
                                           cases Prop_Directᵤ with | intro Colour₂ᵤ Prop_Directᵤ =>
                                           cases Prop_Directᵤ with | intro Coloursᵤ Prop_Directᵤ =>
                                           cases Prop_Directᵤ with | intro Prop_Check_Coloursᵤ Prop_Directᵤ =>
                                           cases Prop_Directᵤ with | intro Prop_Colour₁ᵤ Prop_Directᵤ =>
                                           cases Prop_Directᵤ with | intro Prop_Coloursᵤ Prop_Dir_Outᵤ =>
                                           --
                                           apply And.intro ( by exact Prop_Startᵤ; );                           /- := Start Node -/
                                           apply And.intro ( by exact REWRITE.Get_End_RwDirect dir_casesᵤ; );   /- := End Node -/
                                           apply And.intro ( by exact Prop_Levelᵤ; );                           /- := Colours -/
                                           apply Exists.intro Colour₁ᵤ;
                                           apply Exists.intro Colour₂ᵤ;
                                           apply Exists.intro Coloursᵤ;
                                           apply And.intro ( by exact Prop_Check_Coloursᵤ; );
                                           apply And.intro ( by rewrite [List.Eq_Or_Mem_Iff_Mem_Cons] at Prop_Colour₁ᵤ;
                                                                cases Prop_Colour₁ᵤ with
                                                                | inl Prop_NBR_Colour₁ᵤ => rewrite [Prop_NBR_Colour₁ᵤ];
                                                                                           exact List.Mem.head ( RULEᵥ.CENTER.NUMBER :: RULEᵤ.CENTER.PAST );
                                                                | inr Prop_PST_Colour₁ᵤ => exact List.Mem.tail ( RULEᵤ.CENTER.NUMBER )
                                                                                                              ( List.Mem.tail RULEᵥ.CENTER.NUMBER Prop_PST_Colour₁ᵤ ); );
                                           apply And.intro ( by exact Prop_Coloursᵤ; );
                                           /- := Check Direct-Outgoing Duo: -/
                                           cases Prop_Dir_Outᵤ with | intro Outᵤ Prop_Dir_Outᵤ =>
                                           cases Prop_Dir_Outᵤ with | intro Dep_Outᵤ Prop_Dir_Outᵤ =>
                                           cases Prop_Dir_Outᵤ with | intro Prop_Out_Colᵤ Prop_Dir_Outᵤ =>
                                           cases Prop_Dir_Outᵤ with | intro Prop_Colour₂ᵤ Prop_Dir_Outᵤ =>
                                           cases Prop_Dir_Outᵤ with | intro Prop_Dir_Outᵤ Prop_All_Dir_Outᵤ =>
                                           --
                                           apply Exists.intro Outᵤ;
                                           apply Exists.intro Dep_Outᵤ;
                                           apply And.intro ( by exact Prop_Out_Colᵤ; );
                                           apply And.intro ( by exact Prop_Colour₂ᵤ; );
                                           apply And.intro ( by simp only [List.Mem_Or_Mem_Iff_Mem_Append];     /- := edge CENTER out colour₁ dep_out ∈ OUTGOING -/
                                                                apply Or.inr;
                                                                rewrite [←collapse.center];
                                                                exact REWRITE.Mem_RwOutgoing_Of_Mem Prop_Dir_Outᵤ; );
                                           intro all_outᵤ all_out_casesᵤ;                                       /- := all_out.COLOUR = colour₁ ↔ all_out = edge CENTER out colour₁ dep_out -/
                                           simp only [List.Mem_Or_Mem_Iff_Mem_Append] at all_out_casesᵤ;
                                           cases all_out_casesᵤ with
                                           | inl all_out_casesᵤᵥ => have Dir_Out_Casesᵤᵥ := REWRITE.Mem_Of_Mem_RwOutgoing all_out_casesᵤᵥ;                      /- := all_out ∈ RULEᵥ.OUTGOING -/
                                                                    cases Dir_Out_Casesᵤᵥ with | intro Originalᵥ Dir_Out_Memᵤᵥ =>
                                                                    rewrite [prop_out_unitᵥ] at Dir_Out_Memᵤᵥ;
                                                                    rewrite [List.Eq_Iff_Mem_Unit] at Dir_Out_Memᵤᵥ;
                                                                    rewrite [Deduction.edge.injEq] at Dir_Out_Memᵤᵥ ⊢;
                                                                    cases Dir_Out_Memᵤᵥ with | intro Dir_Out_Startᵤᵥ Dir_Out_Memᵤᵥ =>
                                                                    cases Dir_Out_Memᵤᵥ with | intro Dir_Out_Endᵤᵥ Dir_Out_Memᵤᵥ =>
                                                                    cases Dir_Out_Memᵤᵥ with | intro Dir_Out_Colourᵤᵥ Dir_Out_Dependencyᵤᵥ =>
                                                                    rewrite [Dir_Out_Endᵤᵥ, Dir_Out_Colourᵤᵥ, Dir_Out_Dependencyᵤᵥ];
                                                                    rewrite [prop_eq_out_end, prop_eq_out_colour, prop_eq_out_dependency];
                                                                    --
                                                                    have Prop_All_Outᵤ := prop_out_coloursᵤ eq_out_memᵤ Prop_Dir_Outᵤ (Or.inl eq_out_colourᵤ);  /- := all_out.COLOUR = eq_out.COLOUR ↔ all_out = eq_out -/
                                                                    rewrite [Deduction.edge.injEq] at Prop_All_Outᵤ;
                                                                    rewrite [←REWRITE.Get_Start_RwOutgoing all_out_casesᵤᵥ];                                    /- := all_out.START = collapse.center RULEᵤ.CENTER RULEᵥ.CENTER -/
                                                                    simp only [true_and] at Prop_All_Outᵤ ⊢;
                                                                    --
                                                                    exact Iff.intro ( by intro iff_eq_colourᵤᵥ;
                                                                                         rewrite [Prop_All_Outᵤ] at iff_eq_colourᵤᵥ;
                                                                                         simp only [iff_eq_colourᵤᵥ];
                                                                                         trivial; )
                                                                                    ( by intro iff_eq_edgeᵤᵥ;
                                                                                         simp only [iff_eq_edgeᵤᵥ]; );
                                           | inr all_out_casesᵤᵤ => have Dir_Out_Casesᵤᵤ := REWRITE.Mem_Of_Mem_RwOutgoing all_out_casesᵤᵤ;                      /- := all_out ∈ RULEᵤ.OUTGOING -/
                                                                    cases Dir_Out_Casesᵤᵤ with | intro Originalᵤ Dir_Out_Memᵤᵤ =>
                                                                    have Prop_All_Dir_Outᵤᵤ := Prop_All_Dir_Outᵤ Dir_Out_Memᵤᵤ;                                 /- := all_out.COLOUR = Colour₁ ↔ all_out = edge CENTER out Colour₁ dep_out -/
                                                                    rewrite [Deduction.edge.injEq] at Prop_All_Dir_Outᵤᵤ ⊢;
                                                                    rewrite [←COLLAPSE.Simp_Out_Start₃ (prop_outgoingᵤ Dir_Out_Memᵤᵤ)] at Prop_All_Dir_Outᵤᵤ;   /- := all_out.START = RULEᵤ.CENTER -/
                                                                    rewrite [←REWRITE.Get_Start_RwOutgoing all_out_casesᵤᵤ];                                    /- := all_out.START = collapse.center RULEᵤ.CENTER RULEᵥ.CENTER -/
                                                                    simp only [true_and] at Prop_All_Dir_Outᵤᵤ ⊢;
                                                                    exact Prop_All_Dir_Outᵤᵤ; );
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  /- Indirect Paths -/------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  simp only [type_indirect] at prop_indirectᵤ prop_indirectᵥ ⊢;
  simp only [List.Mem_Or_Mem_Iff_Mem_Append];
  intro ind ind_cases;
  cases ind_cases with
  | inl ind_casesᵥ => have Prop_Indirectᵥ := prop_indirectᵥ ind_casesᵥ;
                      simp only [type_indirect.check] at Prop_Indirectᵥ ⊢;
                      cases Prop_Indirectᵥ with | intro Prop_Startᵥ Prop_Indirectᵥ =>
                      cases Prop_Indirectᵥ with | intro Prop_Endᵥ Prop_Indirectᵥ =>
                      cases Prop_Indirectᵥ with | intro Prop_Levelᵥ Prop_Indirectᵥ =>
                      cases Prop_Indirectᵥ with | intro Colourᵥ Prop_Indirectᵥ =>
                      cases Prop_Indirectᵥ with | intro Coloursᵥ Prop_Indirectᵥ =>
                      cases Prop_Indirectᵥ with | intro Prop_Check_Coloursᵥ Prop_Indirectᵥ =>
                      cases Prop_Indirectᵥ with | intro Prop_Colourᵥ Prop_Indirectᵥ =>
                      cases Prop_Indirectᵥ with | intro Prop_Coloursᵥ Prop_Indirectᵥ =>
                      cases Prop_Indirectᵥ with | intro Prop_Ind_Incᵥ Prop_Ind_Outᵥ =>
                      --
                      apply And.intro ( by rewrite [prop_eq_lvl];         /- := Start Node -/
                                           exact Prop_Startᵥ; );
                      apply And.intro ( by rewrite [prop_eq_lvl];         /- := End Node -/
                                           exact Prop_Endᵥ; );
                      apply And.intro ( by rewrite [prop_eq_lvl];         /- := Colours -/
                                           exact Prop_Levelᵥ; );
                      apply Exists.intro Colourᵥ;
                      apply Exists.intro Coloursᵥ;
                      apply And.intro ( by exact Prop_Check_Coloursᵥ; );
                      apply And.intro ( by rewrite [prop_pstᵥ, List.Eq_Iff_Mem_Unit] at Prop_Colourᵥ;
                                           rewrite [Prop_Colourᵥ];
                                           exact List.Mem.tail ( RULEᵤ.CENTER.NUMBER )
                                                               ( List.Mem.head RULEᵤ.CENTER.PAST ); );
                      apply And.intro ( by exact Prop_Coloursᵥ; );
                      /- := Check Indirect-Incoming Duo: -/
                      cases Prop_Ind_Incᵥ with | intro Dep_Incᵥ Prop_Ind_Incᵥ =>
                      cases Prop_Ind_Incᵥ with | intro Prop_Ind_Incᵥ Prop_All_Ind_Incᵥ =>
                      --
                      apply And.intro ( by apply Exists.intro Dep_Incᵥ;
                                           apply And.intro ( by simp only [List.Mem_Or_Mem_Iff_Mem_Append];   /- := edge IND.END CENTER 0 dep_inc ∈ INCOMING -/
                                                                apply Or.inl;
                                                                rewrite [←collapse.center];
                                                                exact REWRITE.Mem_RwIncoming_Of_Mem Prop_Ind_Incᵥ; );
                                           intro all_incᵥ all_inc_casesᵥ;                                     /- := all_inc.START = IND.END ↔ all_inc = edge IND.END CENTER 0 dep_inc -/
                                           simp only [List.Mem_Or_Mem_Iff_Mem_Append] at all_inc_casesᵥ;
                                           cases all_inc_casesᵥ with
                                           | inl all_inc_casesᵥᵥ => have Ind_Inc_Casesᵥᵥ := REWRITE.Mem_Of_Mem_RwIncoming all_inc_casesᵥᵥ;                      /- := all_inc ∈ RULEᵥ.INCOMING -/
                                                                    cases Ind_Inc_Casesᵥᵥ with | intro Originalᵥ Ind_Inc_Memᵥᵥ =>
                                                                    have Prop_All_Ind_Incᵥᵥ := Prop_All_Ind_Incᵥ Ind_Inc_Memᵥᵥ;                                 /- := all_inc.START = IND.END ↔ all_inc = edge IND.END CENTER 0 dep_inc -/
                                                                    rewrite [Deduction.edge.injEq] at Prop_All_Ind_Incᵥᵥ ⊢;
                                                                    rewrite [←COLLAPSE.Simp_Inc_End (prop_incomingᵥ Ind_Inc_Memᵥᵥ)] at Prop_All_Ind_Incᵥᵥ;      /- := all_inc.END = RULEᵥ.CENTER -/
                                                                    rewrite [←REWRITE.Get_End_RwIncoming all_inc_casesᵥᵥ];                                      /- := all_inc.END = collapse.center RULEᵤ.CENTER RULEᵥ.CENTER -/
                                                                    simp only [true_and] at Prop_All_Ind_Incᵥᵥ ⊢;
                                                                    exact Prop_All_Ind_Incᵥᵥ;
                                           | inr all_inc_casesᵥᵤ => have Ind_Inc_Casesᵥᵤ := REWRITE.Mem_Of_Mem_RwIncoming all_inc_casesᵥᵤ;                      /- := all_inc ∈ RULEᵤ.INCOMING -/
                                                                    cases Ind_Inc_Casesᵥᵤ with | intro Originalᵤ Ind_Inc_Memᵥᵤ =>
                                                                    rewrite [Deduction.edge.injEq];
                                                                    have Prop_Check_Incomingᵥᵤ := prop_check_incoming Ind_Inc_Memᵥᵤ Prop_Ind_Incᵥ;              /- := all_inc.START ≠ IND.END -/
                                                                    simp only [Prop_Check_Incomingᵥᵤ, false_and]; );
                      /- := Check Indirect-Outgoing Duo: -/
                      cases Prop_Ind_Outᵥ with | intro Outᵥ Prop_Ind_Outᵥ =>
                      cases Prop_Ind_Outᵥ with | intro Dep_Outᵥ Prop_Ind_Outᵥ =>
                      cases Prop_Ind_Outᵥ with | intro Prop_Out_Colᵥ Prop_Ind_Outᵥ =>
                      cases Prop_Ind_Outᵥ with | intro Prop_Ind_Outᵥ Prop_All_Ind_Outᵥ =>
                      --
                      apply Exists.intro Outᵥ;
                      apply Exists.intro Dep_Outᵥ;
                      apply And.intro ( by exact Prop_Out_Colᵥ; );
                      apply And.intro ( by simp only [List.Mem_Or_Mem_Iff_Mem_Append];     /- := edge CENTER out colour₁ dep_out ∈ OUTGOING -/
                                           apply Or.inl;
                                           rewrite [←collapse.center];
                                           exact REWRITE.Mem_RwOutgoing_Of_Mem Prop_Ind_Outᵥ; );
                      intro all_outᵥ all_out_casesᵥ;                                       /- := all_out.COLOUR = colour₁ ↔ all_out = edge CENTER out colour₁ dep_out -/
                      simp only [List.Mem_Or_Mem_Iff_Mem_Append] at all_out_casesᵥ;
                      cases all_out_casesᵥ with
                      | inl all_out_casesᵥᵥ => have Ind_Out_Casesᵥᵥ := REWRITE.Mem_Of_Mem_RwOutgoing all_out_casesᵥᵥ;                      /- := all_out ∈ RULEᵥ.OUTGOING -/
                                               cases Ind_Out_Casesᵥᵥ with | intro Originalᵥ Ind_Out_Memᵥᵥ =>
                                               have Prop_All_Ind_Outᵥᵥ := Prop_All_Ind_Outᵥ Ind_Out_Memᵥᵥ;                                 /- := all_out.COLOUR = Colour ↔ all_out = edge CENTER out Colour dep_out -/
                                               rewrite [Deduction.edge.injEq] at Prop_All_Ind_Outᵥᵥ ⊢;
                                               rewrite [←COLLAPSE.Simp_Out_Start₃ (prop_outgoingᵥ Ind_Out_Memᵥᵥ)] at Prop_All_Ind_Outᵥᵥ;   /- := all_out.START = RULEᵥ.CENTER -/
                                               rewrite [←REWRITE.Get_Start_RwOutgoing all_out_casesᵥᵥ];                                    /- := all_out.START = collapse.center RULEᵤ.CENTER RULEᵥ.CENTER -/
                                               simp only [true_and] at Prop_All_Ind_Outᵥᵥ ⊢;
                                               exact Prop_All_Ind_Outᵥᵥ;
                      | inr all_out_casesᵥᵤ => have Dir_Out_Casesᵥᵤ := REWRITE.Mem_Of_Mem_RwOutgoing all_out_casesᵥᵤ;                      /- := all_out ∈ RULEᵤ.OUTGOING -/
                                               cases Dir_Out_Casesᵥᵤ with | intro Originalᵤ Dir_Out_Memᵥᵤ =>
                                               --
                                               have Prop_All_Outᵤ := prop_out_coloursᵤ Dir_Out_Memᵥᵤ eq_out_memᵤ (Or.inr eq_out_colourᵤ);  /- := all_out.COLOUR = eq_out.COLOUR ↔ all_out = eq_out -/
                                               rewrite [Deduction.edge.injEq] at Prop_All_Outᵤ ⊢;
                                               simp only [true_and] at Prop_All_Outᵤ ⊢;
                                               --
                                               rewrite [prop_out_unitᵥ] at Prop_Ind_Outᵥ;
                                               simp only [List.Eq_Iff_Mem_Unit] at Prop_Ind_Outᵥ;
                                               simp only [←Prop_Ind_Outᵥ] at prop_eq_out_end prop_eq_out_colour prop_eq_out_dependency;
                                               rewrite [prop_eq_out_end, prop_eq_out_colour, prop_eq_out_dependency];
                                               --
                                               rewrite [←REWRITE.Get_Start_RwOutgoing all_out_casesᵥᵤ];                                    /- := all_out.START = collapse.center RULEᵤ.CENTER RULEᵥ.CENTER -/
                                               exact Iff.intro ( by intro iff_eq_colourᵥᵤ;
                                                                    rewrite [Prop_All_Outᵤ] at iff_eq_colourᵥᵤ;
                                                                    simp only [iff_eq_colourᵥᵤ];
                                                                    trivial; )
                                                               ( by intro iff_eq_edgeᵥᵤ;
                                                                    simp only [iff_eq_edgeᵥᵤ]; );
  | inr ind_casesᵤ => have Prop_Indirectᵤ := prop_indirectᵤ ind_casesᵤ;
                      simp only [type_indirect.check] at Prop_Indirectᵤ ⊢;
                      cases Prop_Indirectᵤ with | intro Prop_Startᵤ Prop_Indirectᵤ =>
                      cases Prop_Indirectᵤ with | intro Prop_Endᵤ Prop_Indirectᵤ =>
                      cases Prop_Indirectᵤ with | intro Prop_Levelᵤ Prop_Indirectᵤ =>
                      cases Prop_Indirectᵤ with | intro Colourᵤ Prop_Indirectᵤ =>
                      cases Prop_Indirectᵤ with | intro Coloursᵤ Prop_Indirectᵤ =>
                      cases Prop_Indirectᵤ with | intro Prop_Check_Coloursᵤ Prop_Indirectᵤ =>
                      cases Prop_Indirectᵤ with | intro Prop_Colourᵤ Prop_Indirectᵤ =>
                      cases Prop_Indirectᵤ with | intro Prop_Coloursᵤ Prop_Indirectᵤ =>
                      cases Prop_Indirectᵤ with | intro Prop_Ind_Incᵤ Prop_Ind_Outᵤ =>
                      --
                      apply And.intro ( by exact Prop_Startᵤ; );           /- := Start Node -/
                      apply And.intro ( by exact Prop_Endᵤ; );             /- := End Node -/
                      apply And.intro ( by exact Prop_Levelᵤ; );           /- := Colours -/
                      apply Exists.intro Colourᵤ;
                      apply Exists.intro Coloursᵤ;
                      apply And.intro ( by exact Prop_Check_Coloursᵤ; );
                      apply And.intro ( by rewrite [List.Eq_Or_Mem_Iff_Mem_Cons] at Prop_Colourᵤ;
                                           cases Prop_Colourᵤ with
                                           | inl Prop_NBR_Colourᵤ => rewrite [Prop_NBR_Colourᵤ];
                                                                     exact List.Mem.head ( RULEᵥ.CENTER.NUMBER :: RULEᵤ.CENTER.PAST );
                                           | inr Prop_PST_Colourᵤ => exact List.Mem.tail ( RULEᵤ.CENTER.NUMBER )
                                                                                         ( List.Mem.tail RULEᵥ.CENTER.NUMBER Prop_PST_Colourᵤ ); );
                      apply And.intro ( by exact Prop_Coloursᵤ; );
                      /- := Check Indirect-Incoming Duo: -/
                      cases Prop_Ind_Incᵤ with | intro Dep_Incᵤ Prop_Ind_Incᵤ =>
                      cases Prop_Ind_Incᵤ with | intro Prop_Ind_Incᵤ Prop_All_Ind_Incᵤ =>
                      --
                      apply And.intro ( by apply Exists.intro Dep_Incᵤ;
                                           apply And.intro ( by simp only [List.Mem_Or_Mem_Iff_Mem_Append];   /- := edge IND.END CENTER 0 dep_inc ∈ INCOMING -/
                                                                apply Or.inr;
                                                                rewrite [←collapse.center];
                                                                exact REWRITE.Mem_RwIncoming_Of_Mem Prop_Ind_Incᵤ; );
                                           intro all_incᵤ all_inc_casesᵤ;                                     /- := all_inc.START = IND.END ↔ all_inc = edge IND.END CENTER 0 dep_inc -/
                                           simp only [List.Mem_Or_Mem_Iff_Mem_Append] at all_inc_casesᵤ;
                                           cases all_inc_casesᵤ with
                                           | inl all_inc_casesᵤᵥ => have Ind_Inc_Casesᵤᵥ := REWRITE.Mem_Of_Mem_RwIncoming all_inc_casesᵤᵥ;                      /- := all_inc ∈ RULEᵥ.INCOMING -/
                                                                    cases Ind_Inc_Casesᵤᵥ with | intro Originalᵥ Ind_Inc_Memᵤᵥ =>
                                                                    rewrite [Deduction.edge.injEq];
                                                                    have Prop_Check_Incomingᵤᵥ := prop_check_incoming Prop_Ind_Incᵤ Ind_Inc_Memᵤᵥ;              /- := IND.END ≠ all_inc.START -/
                                                                    rewrite [ne_comm] at Prop_Check_Incomingᵤᵥ;
                                                                    simp only [Prop_Check_Incomingᵤᵥ, false_and];
                                           | inr all_inc_casesᵤᵤ => have Ind_Inc_Casesᵤᵤ := REWRITE.Mem_Of_Mem_RwIncoming all_inc_casesᵤᵤ;                      /- := all_inc ∈ RULEᵤ.INCOMING -/
                                                                    cases Ind_Inc_Casesᵤᵤ with | intro Originalᵤ Ind_Inc_Memᵤᵤ =>
                                                                    have Prop_All_Ind_Incᵤᵤ := Prop_All_Ind_Incᵤ Ind_Inc_Memᵤᵤ;                                 /- := all_inc.START = IND.END ↔ all_inc = edge IND.END CENTER 0 dep_inc -/
                                                                    rewrite [Deduction.edge.injEq] at Prop_All_Ind_Incᵤᵤ ⊢;
                                                                    rewrite [←COLLAPSE.Simp_Inc_End (prop_incomingᵤ Ind_Inc_Memᵤᵤ)] at Prop_All_Ind_Incᵤᵤ;      /- := all_inc.END = RULEᵤ.CENTER -/
                                                                    rewrite [←REWRITE.Get_End_RwIncoming all_inc_casesᵤᵤ];                                      /- := all_inc.END = collapse.center RULEᵤ.CENTER RULEᵥ.CENTER -/
                                                                    simp only [true_and] at Prop_All_Ind_Incᵤᵤ ⊢;
                                                                    exact Prop_All_Ind_Incᵤᵤ; );
                      /- Check Outgoing-Indirect Duo: -/
                      cases Prop_Ind_Outᵤ with | intro Outᵤ Prop_Ind_Outᵤ =>
                      cases Prop_Ind_Outᵤ with | intro Dep_Outᵤ Prop_Ind_Outᵤ =>
                      cases Prop_Ind_Outᵤ with | intro Prop_Out_Colᵤ Prop_Ind_Outᵤ =>
                      cases Prop_Ind_Outᵤ with | intro Prop_Ind_Outᵤ Prop_All_Ind_Outᵤ =>
                      --
                      apply Exists.intro Outᵤ;
                      apply Exists.intro Dep_Outᵤ;
                      apply And.intro ( by exact Prop_Out_Colᵤ; );
                      apply And.intro ( by simp only [List.Mem_Or_Mem_Iff_Mem_Append];     /- := edge CENTER out colour dep_out ∈ OUTGOING -/
                                           apply Or.inr;
                                           rewrite [←collapse.center];
                                           exact REWRITE.Mem_RwOutgoing_Of_Mem Prop_Ind_Outᵤ; );
                      intro all_outᵤ all_out_casesᵤ;                                       /- := all_out.COLOUR = colour ↔ all_out = edge CENTER out colour₁ dep_out -/
                      simp only [List.Mem_Or_Mem_Iff_Mem_Append] at all_out_casesᵤ;
                      cases all_out_casesᵤ with
                      | inl all_out_casesᵤᵥ => have Dir_Out_Casesᵤᵥ := REWRITE.Mem_Of_Mem_RwOutgoing all_out_casesᵤᵥ;                      /- := all_out ∈ RULEᵥ.OUTGOING -/
                                               cases Dir_Out_Casesᵤᵥ with | intro Originalᵥ Dir_Out_Memᵤᵥ =>
                                               rewrite [prop_out_unitᵥ] at Dir_Out_Memᵤᵥ;
                                               rewrite [List.Eq_Iff_Mem_Unit] at Dir_Out_Memᵤᵥ;
                                               rewrite [Deduction.edge.injEq] at Dir_Out_Memᵤᵥ ⊢;
                                               cases Dir_Out_Memᵤᵥ with | intro Dir_Out_Startᵤᵥ Dir_Out_Memᵤᵥ =>
                                               cases Dir_Out_Memᵤᵥ with | intro Dir_Out_Endᵤᵥ Dir_Out_Memᵤᵥ =>
                                               cases Dir_Out_Memᵤᵥ with | intro Dir_Out_Colourᵤᵥ Dir_Out_Dependencyᵤᵥ =>
                                               rewrite [Dir_Out_Endᵤᵥ, Dir_Out_Colourᵤᵥ, Dir_Out_Dependencyᵤᵥ];
                                               rewrite [prop_eq_out_end, prop_eq_out_colour, prop_eq_out_dependency];
                                               --
                                               have Prop_All_Outᵤ := prop_out_coloursᵤ eq_out_memᵤ Prop_Ind_Outᵤ (Or.inl eq_out_colourᵤ);  /- := all_out.COLOUR = eq_out.COLOUR ↔ all_out = eq_out -/
                                               rewrite [Deduction.edge.injEq] at Prop_All_Outᵤ;
                                               rewrite [←REWRITE.Get_Start_RwOutgoing all_out_casesᵤᵥ];                                    /- := all_out.START = collapse.center RULEᵤ.CENTER RULEᵥ.CENTER -/
                                               simp only [true_and] at Prop_All_Outᵤ ⊢;
                                               --
                                               exact Iff.intro ( by intro iff_eq_colourᵤᵥ;
                                                                    rewrite [Prop_All_Outᵤ] at iff_eq_colourᵤᵥ;
                                                                    simp only [iff_eq_colourᵤᵥ];
                                                                    trivial; )
                                                               ( by intro iff_eq_edgeᵤᵥ;
                                                                    simp only [iff_eq_edgeᵤᵥ]; );
                      | inr all_out_casesᵤᵤ => have Ind_Out_Casesᵤᵤ := REWRITE.Mem_Of_Mem_RwOutgoing all_out_casesᵤᵤ;                      /- := all_out ∈ RULEᵤ.OUTGOING -/
                                               cases Ind_Out_Casesᵤᵤ with | intro Originalᵤ Ind_Out_Memᵤᵤ =>
                                               have Prop_All_Ind_Outᵤᵤ := Prop_All_Ind_Outᵤ Ind_Out_Memᵤᵤ;                                 /- := all_out.COLOUR = Colour ↔ all_out = edge CENTER out Colour dep_out -/
                                               rewrite [Deduction.edge.injEq] at Prop_All_Ind_Outᵤᵤ ⊢;
                                               rewrite [←COLLAPSE.Simp_Out_Start₃ (prop_outgoingᵤ Ind_Out_Memᵤᵤ)] at Prop_All_Ind_Outᵤᵤ;   /- := all_out.START = RULEᵤ.CENTER -/
                                               rewrite [←REWRITE.Get_Start_RwOutgoing all_out_casesᵤᵤ];                                    /- := all_out.START = collapse.center RULEᵤ.CENTER RULEᵥ.CENTER -/
                                               simp only [true_and] at Prop_All_Ind_Outᵤᵤ ⊢;
                                               exact Prop_All_Ind_Outᵤᵤ;
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  /- Lemma: Collapse Execution (Type 3 & Type 2 => Type 3) (Nodes & Edges) -/
  theorem Col_Of_Collapse_Col_Pre {RULEᵤ RULEᵥ : Neighborhood} :
    ( check_collapse_edges RULEᵤ RULEᵥ ) →
    ( type3_collapse RULEᵤ ) →
    ( type3_pre_collapse RULEᵥ ) →
    ---------------------------
    ( type3_collapse (collapse RULEᵤ RULEᵥ) ) := by
  intro prop_check_collapse prop_typeᵤ prop_typeᵥ;
  --
  simp only [check_collapse_edges] at prop_check_collapse;
  cases prop_check_collapse with | intro prop_eq_out prop_check_collapse =>
  cases prop_check_collapse with | intro prop_eq_lvl prop_check_collapse =>
  cases prop_check_collapse with | intro prop_eq_fml prop_check_incoming =>
  --
  cases prop_eq_out with | intro eq_outᵤ prop_eq_out =>
  cases prop_eq_out with | intro eq_outᵥ prop_eq_out =>
  cases prop_eq_out with | intro eq_out_memᵤ prop_eq_out =>
  cases prop_eq_out with | intro eq_out_memᵥ prop_eq_out =>
  cases prop_eq_out with | intro eq_out_colourᵤ prop_eq_out =>
  --
  simp only [type3_collapse] at prop_typeᵤ;
  cases prop_typeᵤ with | intro prop_nbrᵤ prop_typeᵤ =>
  cases prop_typeᵤ with | intro prop_lvlᵤ prop_typeᵤ =>
  cases prop_typeᵤ with | intro prop_colᵤ prop_typeᵤ =>
  cases prop_typeᵤ with | intro prop_pstᵤ prop_typeᵤ =>
  cases prop_typeᵤ with | intro prop_inc_nilᵤ prop_typeᵤ =>
  cases prop_typeᵤ with | intro prop_out_consᵤ prop_typeᵤ =>
  cases prop_typeᵤ with | intro prop_out_coloursᵤ prop_typeᵤ =>
  cases prop_typeᵤ with | intro prop_dir_nilᵤ prop_typeᵤ =>
  cases prop_typeᵤ with | intro prop_dir_consᵤ prop_typeᵤ =>
  cases prop_typeᵤ with | intro prop_ind_lenᵤ prop_typeᵤ =>
  cases prop_typeᵤ with | intro prop_incomingᵤ prop_typeᵤ =>
  cases prop_typeᵤ with | intro prop_outgoingᵤ prop_typeᵤ =>
  cases prop_typeᵤ with | intro prop_directᵤ prop_indirectᵤ =>
  --
  cases prop_pstᵤ with | intro pastᵤ prop_pstᵤ =>
  cases prop_pstᵤ with | intro pastsᵤ prop_pstᵤ =>
  cases prop_pstᵤ with | intro prop_check_pastᵤ prop_pstᵤ =>
  --
  cases prop_out_consᵤ with | intro outᵤ prop_out_consᵤ =>
  cases prop_out_consᵤ with | intro outsᵤ prop_out_consᵤ =>
  --
  simp only [type3_pre_collapse] at prop_typeᵥ;
  cases prop_typeᵥ with | intro prop_nbrᵥ prop_typeᵥ =>
  cases prop_typeᵥ with | intro prop_lvlᵥ prop_typeᵥ =>
  cases prop_typeᵥ with | intro prop_colᵥ prop_typeᵥ =>
  cases prop_typeᵥ with | intro prop_pstᵥ prop_typeᵥ =>
  cases prop_typeᵥ with | intro prop_inc_nilᵥ prop_typeᵥ =>
  cases prop_typeᵥ with | intro prop_inc_lenᵥ prop_typeᵥ =>
  cases prop_typeᵥ with | intro prop_out_unitᵥ prop_typeᵥ =>
  cases prop_typeᵥ with | intro prop_out_coloursᵥ prop_typeᵥ =>
  cases prop_typeᵥ with | intro prop_dir_nilᵥ prop_typeᵥ =>
  cases prop_typeᵥ with | intro prop_dir_consᵥ prop_typeᵥ =>
  cases prop_typeᵥ with | intro prop_dir_unitᵥ prop_typeᵥ =>
  cases prop_typeᵥ with | intro prop_ind_startsᵥ prop_typeᵥ =>
  cases prop_typeᵥ with | intro prop_ind_lenᵥ prop_typeᵥ =>
  cases prop_typeᵥ with | intro prop_incomingᵥ prop_typeᵥ =>
  cases prop_typeᵥ with | intro prop_outgoingᵥ prop_typeᵥ =>
  cases prop_typeᵥ with | intro prop_directᵥ prop_indirectᵥ =>
  --
  cases prop_out_unitᵥ with | intro outᵥ prop_out_unitᵥ =>
  --
  rewrite [prop_out_unitᵥ] at eq_out_memᵥ;
  simp only [List.Eq_Iff_Mem_Unit] at eq_out_memᵥ;
  simp only [eq_out_memᵥ] at prop_eq_out;
  cases prop_eq_out with | intro prop_eq_out_end prop_eq_out =>
  cases prop_eq_out with | intro prop_eq_out_colour prop_eq_out_dependency =>
  --
  simp only [collapse];
  simp only [collapse.center];
  simp only [type3_collapse];
  /- Check Center-/
  apply And.intro ( by exact prop_nbrᵤ; );                                        /- := RULE.CENTER.NUMBER > 0 -/
  apply And.intro ( by exact prop_lvlᵤ; );                                        /- := RULE.CENTER.LEVEL > 0 -/
  apply And.intro ( by trivial; );                                                /- := RULE.CENTER.COLLAPSED = true -/
  apply And.intro ( by apply Exists.intro RULEᵥ.CENTER.NUMBER;                    /- := check_numbers (past :: pasts) ∧ RULE.CENTER.PAST = (past::pasts) -/
                       apply Exists.intro RULEᵤ.CENTER.PAST;
                       apply And.intro ( by rewrite [prop_pstᵤ];
                                            exact COLLAPSE.Check_Numbers_Cons prop_nbrᵥ prop_check_pastᵤ; );
                       trivial; );
  /- Check Deduction Edges -/
  apply And.intro ( by intro prop_inc_nil;                                        /- := ( RULE.INCOMING = [] ) → ( RULE.CENTER.HYPOTHESIS = true ) -/
                       simp only [List.append_eq_nil] at prop_inc_nil;
                       simp only [←List.length_eq_zero] at prop_inc_nil prop_inc_nilᵥ;
                       simp only [REWRITE.Eq_Length_RwIncoming] at prop_inc_nil;
                       simp only [prop_inc_nilᵥ] at prop_inc_nil;
                       simp only [Bool.or_eq_true];
                       exact Or.inr (And.left prop_inc_nil); );
  apply And.intro ( by simp only [prop_out_unitᵥ];                                                                    /- := RULE.OUTGOING = (out::outs) -/
                       apply Exists.intro ( edge ( collapse.center RULEᵤ.CENTER RULEᵥ.CENTER )                        /- RULEᵥ.OUTGOING -/
                                                 ( outᵥ.END )
                                                 ( outᵥ.COLOUR )
                                                 ( outᵥ.DEPENDENCY ) );
                       apply Exists.intro ( collapse.rewrite_outgoing ( collapse.center RULEᵤ.CENTER RULEᵥ.CENTER )   /- RULEᵤ.OUTGOING -/
                                                                      ( RULEᵤ.OUTGOING ) );
                       simp only [collapse.rewrite_outgoing];
                       simp only [collapse.center];
                       trivial; );
  apply And.intro ( by intro out₁ out₂ out_mem₁ out_mem₂ gt_zero₁₂;                          /- := OUT₁.COLOUR = OUT₂.COLOUR ↔ OUT₁ = OUT₂ -/
                       rewrite [prop_out_unitᵥ] at out_mem₁ out_mem₂;
                       simp only [collapse.rewrite_outgoing] at out_mem₁ out_mem₂;
                       simp only [List.Mem_Or_Mem_Iff_Mem_Append] at out_mem₁ out_mem₂;
                       simp only [List.Eq_Iff_Mem_Unit] at out_mem₁ out_mem₂;
                       simp only [Deduction.edge.injEq'];
                       --
                       simp only [type_outgoing₃] at prop_outgoingᵤ;
                       have Eq_Out_Colourᵤ := COLLAPSE.Simp_Out_Start₃ (prop_outgoingᵤ eq_out_memᵤ);
                       --
                       cases out_mem₁ with
                       | inl out_mem₁ᵥ => cases out_mem₂ with
                                          | inl out_mem₂ᵥ => rewrite [out_mem₁ᵥ, out_mem₂ᵥ]; simp only [true_and];
                                          | inr out_mem₂ᵤ => rewrite [out_mem₁ᵥ, REWRITE.Get_Start_RwOutgoing out_mem₂ᵤ];                 /- := out₁ = outᵥ, out₂.START = collapse.center RULEᵤ.CENTER RULEᵥ.CENTER -/
                                                             simp only [prop_eq_out_end, prop_eq_out_colour, prop_eq_out_dependency, true_and];
                                                             --
                                                             have Out_Cases₂ᵤ := REWRITE.Mem_Of_Mem_RwOutgoing out_mem₂ᵤ;                 /- := out₂ ∈ RULEᵥ.OUTGOING -/
                                                             cases Out_Cases₂ᵤ with | intro Originalᵤ Out_Mem₂ᵤ =>
                                                             have Out_Start₂ᵤ := COLLAPSE.Simp_Out_Start₃ (prop_outgoingᵤ Out_Mem₂ᵤ);     /- := out₂.START = RULEᵤ.CENTER -/
                                                             --
                                                             have Iff_Out_Colourᵤ := prop_out_coloursᵤ eq_out_memᵤ Out_Mem₂ᵤ (Or.inl eq_out_colourᵤ);
                                                             simp only [Deduction.edge.injEq'] at Out_Start₂ᵤ Iff_Out_Colourᵤ;
                                                             simp only [Eq_Out_Colourᵤ, Out_Start₂ᵤ, true_and] at Iff_Out_Colourᵤ;
                                                             exact Iff_Out_Colourᵤ;
                       | inr out_mem₁ᵤ => cases out_mem₂ with
                                          | inl out_mem₂ᵥ => rewrite [REWRITE.Get_Start_RwOutgoing out_mem₁ᵤ, out_mem₂ᵥ];                 /- := out₁.START = collapse.center RULEᵤ.CENTER RULEᵥ.CENTER, out₂ = outᵥ -/
                                                             simp only [prop_eq_out_end, prop_eq_out_colour, prop_eq_out_dependency, true_and];
                                                             --
                                                             have Out_Cases₁ᵤ := REWRITE.Mem_Of_Mem_RwOutgoing out_mem₁ᵤ;                 /- := out₁ ∈ RULEᵥ.OUTGOING -/
                                                             cases Out_Cases₁ᵤ with | intro Originalᵤ Out_Mem₁ᵤ =>
                                                             have Out_Start₁ᵤ := COLLAPSE.Simp_Out_Start₃ (prop_outgoingᵤ Out_Mem₁ᵤ);     /- := out₁.START = RULEᵤ.CENTER -/
                                                             --
                                                             have Iff_Out_Colourᵤ := prop_out_coloursᵤ Out_Mem₁ᵤ eq_out_memᵤ (Or.inr eq_out_colourᵤ);
                                                             simp only [Deduction.edge.injEq'] at Out_Start₁ᵤ Iff_Out_Colourᵤ;
                                                             simp only [Out_Start₁ᵤ, Eq_Out_Colourᵤ, true_and] at Iff_Out_Colourᵤ;
                                                             exact Iff_Out_Colourᵤ;
                                          | inr out_mem₂ᵤ => rewrite [REWRITE.Get_Start_RwOutgoing out_mem₁ᵤ];              /- := out₁.START = collapse.center RULEᵤ.CENTER RULEᵥ.CENTER -/
                                                             rewrite [REWRITE.Get_Start_RwOutgoing out_mem₂ᵤ];              /- := out₂.START = collapse.center RULEᵤ.CENTER RULEᵥ.CENTER -/
                                                             simp only [true_and];
                                                             --
                                                             have Out_Cases₁ᵤ := REWRITE.Mem_Of_Mem_RwOutgoing out_mem₁ᵤ;               /- := out₁ ∈ RULEᵥ.OUTGOING -/
                                                             cases Out_Cases₁ᵤ with | intro Original₁ᵤ Out_Mem₁ᵤ =>
                                                             have Out_Start₁ᵤ := COLLAPSE.Simp_Out_Start₃ (prop_outgoingᵤ Out_Mem₁ᵤ);   /- := out₁.START = RULEᵤ.CENTER -/
                                                             have Out_Cases₂ᵤ := REWRITE.Mem_Of_Mem_RwOutgoing out_mem₂ᵤ;               /- := out₂ ∈ RULEᵥ.OUTGOING -/
                                                             cases Out_Cases₂ᵤ with | intro Original₂ᵤ Out_Mem₂ᵤ =>
                                                             have Out_Start₂ᵤ := COLLAPSE.Simp_Out_Start₃ (prop_outgoingᵤ Out_Mem₂ᵤ);   /- := out₂.START = RULEᵤ.CENTER -/
                                                             --
                                                             have Iff_Out_Colourᵤ := prop_out_coloursᵤ Out_Mem₁ᵤ Out_Mem₂ᵤ gt_zero₁₂;
                                                             simp only [Deduction.edge.injEq] at Out_Start₁ᵤ Out_Start₂ᵤ Iff_Out_Colourᵤ;
                                                             simp only [Out_Start₁ᵤ, Out_Start₂ᵤ, true_and] at Iff_Out_Colourᵤ;
                                                             exact Iff_Out_Colourᵤ; );
  apply And.intro ( by intro case_hpt;                                /- := ( RULE.CENTER.HYPOTHESIS = false ) → ( RULE.DIRECT = [] ) -/
                       rewrite [Bool.or_eq_false_iff] at case_hpt;
                       cases case_hpt with | intro case_hptᵤ case_hptᵥ =>
                       simp only [prop_dir_nilᵤ case_hptᵤ, prop_dir_nilᵥ case_hptᵥ];
                       simp only [collapse.rewrite_direct];
                       trivial; );
  apply And.intro ( by intro case_dir_cons;                           /- := ( RULE.DIRECT ≠ [] ) → ( RULE.CENTER.HYPOTHESIS = true ) -/
                       simp only [Bool.or_eq_true];
                       cases List.NeNil_Or_NeNil_Of_NeNil_Append case_dir_cons with
                       | inl case_dir_consᵥ => exact Or.inr (prop_dir_consᵥ (REWRITE.NeNil_RwDirect case_dir_consᵥ));
                       | inr case_dir_consᵤ => exact Or.inl (prop_dir_consᵤ (REWRITE.NeNil_RwDirect case_dir_consᵤ)); );
  apply And.intro ( by simp only [List.length_append];                /- := List.length (RULE.INDIRECT) = List.length (RULE.INCOMING) -/
                       simp only [REWRITE.Eq_Length_RwIncoming];
                       simp only [prop_ind_lenᵤ, prop_ind_lenᵥ]; );
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  /- Incoming Edges -/------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  apply And.intro ( by simp only [type_incoming] at prop_incomingᵤ prop_incomingᵥ ⊢;
                       simp only [List.Mem_Or_Mem_Iff_Mem_Append];
                       intro inc inc_cases;
                       cases inc_cases with
                       | inl inc_casesᵥ => have Inc_Caseᵥ := REWRITE.Mem_Of_Mem_RwIncoming inc_casesᵥ;            /- := inc ∈ RULEᵥ.INCOMING -/
                                           cases Inc_Caseᵥ with | intro Originalᵥ Inc_Memᵥ =>
                                           have Prop_Incomingᵥ := prop_incomingᵥ Inc_Memᵥ;                        /- := type_incoming.check inc RULEᵥ.CENTER -/
                                           simp only [type_incoming.check] at Prop_Incomingᵥ ⊢;
                                           cases Prop_Incomingᵥ with | intro Prop_Startᵥ Prop_Incomingᵥ =>
                                           cases Prop_Incomingᵥ with | intro Prop_Endᵥ Prop_Incomingᵥ =>
                                           cases Prop_Incomingᵥ with | intro Prop_Colourᵥ Prop_Inc_Indᵥ =>
                                           --
                                           apply And.intro ( by rewrite [prop_eq_lvl];                            /- := Start Node -/
                                                                exact Prop_Startᵥ; );
                                           apply And.intro ( by exact REWRITE.Get_End_RwIncoming inc_casesᵥ; );   /- := End Node -/
                                           apply And.intro ( by exact Prop_Colourᵥ; );                            /- := Colours -/
                                           /- := Check Incoming-Indirect Duo: -/
                                           cases Prop_Inc_Indᵥ with | intro Colourᵥ Prop_Inc_Indᵥ =>
                                           cases Prop_Inc_Indᵥ with | intro Coloursᵥ Prop_Inc_Indᵥ =>
                                           cases Prop_Inc_Indᵥ with | intro Ancᵥ Prop_Inc_Indᵥ =>
                                           --
                                           apply Exists.intro Colourᵥ;
                                           apply Exists.intro Coloursᵥ;
                                           apply Exists.intro Ancᵥ;
                                           exact ( by simp only [List.Mem_Or_Mem_Iff_Mem_Append];                 /- := path anc INC.START (0::colour::colours) ∈ INDIRECT -/
                                                      apply Or.inl;
                                                      exact Prop_Inc_Indᵥ; );
                       | inr inc_casesᵤ => have Inc_Caseᵤ := REWRITE.Mem_Of_Mem_RwIncoming inc_casesᵤ;            /- := inc ∈ RULEᵤ.INCOMING -/
                                           cases Inc_Caseᵤ with | intro Originalᵤ Inc_Memᵤ =>
                                           have Prop_Incomingᵤ := prop_incomingᵤ Inc_Memᵤ;                        /- := type_incoming.check inc RULEᵤ.CENTER -/
                                           simp only [type_incoming.check] at Prop_Incomingᵤ ⊢;
                                           cases Prop_Incomingᵤ with | intro Prop_Startᵤ Prop_Incomingᵤ =>
                                           cases Prop_Incomingᵤ with | intro Prop_Endᵤ Prop_Incomingᵤ =>
                                           cases Prop_Incomingᵤ with | intro Prop_Colourᵤ Prop_Inc_Indᵤ =>
                                           --
                                           apply And.intro ( by exact Prop_Startᵤ; );                             /- := Start Node -/
                                           apply And.intro ( by exact REWRITE.Get_End_RwIncoming inc_casesᵤ; );   /- := End Node -/
                                           apply And.intro ( by exact Prop_Colourᵤ; );                            /- := Colours -/
                                           /- := Check Incoming-Indirect Duo: -/
                                           cases Prop_Inc_Indᵤ with | intro Colourᵤ Prop_Inc_Indᵤ =>
                                           cases Prop_Inc_Indᵤ with | intro Coloursᵤ Prop_Inc_Indᵤ =>
                                           cases Prop_Inc_Indᵤ with | intro Ancᵤ Prop_Inc_Indᵤ =>
                                           --
                                           apply Exists.intro Colourᵤ;
                                           apply Exists.intro Coloursᵤ;
                                           apply Exists.intro Ancᵤ;
                                           exact ( by simp only [List.Mem_Or_Mem_Iff_Mem_Append];                 /- := path anc INC.START (0::colour::colours) ∈ INDIRECT -/
                                                      apply Or.inr;
                                                      exact Prop_Inc_Indᵤ; ); );
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  /- Outgoing Edges -/------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  apply And.intro ( by simp only [type_outgoing₃] at prop_outgoingᵤ prop_outgoingᵥ ⊢;
                       simp only [List.Mem_Or_Mem_Iff_Mem_Append];
                       intro out out_cases;
                       cases out_cases with
                       | inl out_casesᵥ => have Out_Caseᵥ := REWRITE.Mem_Of_Mem_RwOutgoing out_casesᵥ;          /- := out ∈ RULEᵥ.OUTGOING -/
                                           cases Out_Caseᵥ with | intro Originalᵥ Out_Memᵥ =>
                                           have Prop_Outgoingᵥ := prop_outgoingᵥ Out_Memᵥ;                      /- := type_outgoing.check out RULEᵥ.CENTER -/
                                           cases Prop_Outgoingᵥ with
                                           | inl Prop_Outgoing₁ᵥ => cases Prop_Outgoing₁ᵥ with
                                                                    | inl Prop_Outgoingₕ₁ᵥ => simp only [type_outgoing₁.check_h₁] at Prop_Outgoingₕ₁ᵥ ⊢;
                                                                                              cases Prop_Outgoingₕ₁ᵥ with | intro Prop_HPTₕ₁ᵥ Prop_Outgoingₕ₁ᵥ =>
                                                                                              cases Prop_Outgoingₕ₁ᵥ with | intro Prop_Startₕ₁ᵥ Prop_Outgoingₕ₁ᵥ =>
                                                                                              cases Prop_Outgoingₕ₁ᵥ with | intro Prop_Endₕ₁ᵥ Prop_Colourₕ₁ᵥ =>
                                                                                              --
                                                                                              apply Or.inl; apply Or.inl;
                                                                                              apply And.intro ( by rewrite [Bool.or_eq_true_iff];                       /- := Type 1 Hypothesis -/
                                                                                                                   exact Or.inr Prop_HPTₕ₁ᵥ; );
                                                                                              apply And.intro ( by exact REWRITE.Get_Start_RwOutgoing out_casesᵥ; );    /- := Start Node -/
                                                                                              apply And.intro ( by rewrite [prop_eq_lvl];                               /- := End Node -/
                                                                                                                   exact Prop_Endₕ₁ᵥ; );
                                                                                              exact Prop_Colourₕ₁ᵥ;                                                     /- := Colours -/
                                                                    | inr Prop_Outgoingᵢₑ₁ᵥ => simp only [type_outgoing₁.check_ie₁] at Prop_Outgoingᵢₑ₁ᵥ ⊢;
                                                                                               cases Prop_Outgoingᵢₑ₁ᵥ with | intro Prop_HPTᵢₑ₁ᵥ Prop_Outgoingᵢₑ₁ᵥ =>
                                                                                               cases Prop_Outgoingᵢₑ₁ᵥ with | intro Prop_Startᵢₑ₁ᵥ Prop_Outgoingᵢₑ₁ᵥ =>
                                                                                               cases Prop_Outgoingᵢₑ₁ᵥ with | intro Prop_Endᵢₑ₁ᵥ Prop_Outgoingᵢₑ₁ᵥ =>
                                                                                               cases Prop_Outgoingᵢₑ₁ᵥ with | intro Prop_Colourᵢₑ₁ᵥ Prop_Out_Indᵢₑ₁ᵥ =>
                                                                                               --
                                                                                               apply Or.inl; apply Or.inr;
                                                                                               apply And.intro ( by exact Or.inr trivial; );                                                 /- := Type 1 Introduction & Elimination -/
                                                                                               apply And.intro ( by exact REWRITE.Get_Start_RwOutgoing out_casesᵥ; );                        /- := Start Node -/
                                                                                               apply And.intro ( by rewrite [prop_eq_lvl];                                                   /- := End Node -/
                                                                                                                    exact Prop_Endᵢₑ₁ᵥ; );
                                                                                               apply And.intro ( by rewrite [prop_pstᵥ, List.Eq_Iff_Mem_Unit] at Prop_Colourᵢₑ₁ᵥ;            /- := Colours -/
                                                                                                                    rewrite [Prop_Colourᵢₑ₁ᵥ];
                                                                                                                    exact List.Mem.tail ( RULEᵤ.CENTER.NUMBER )
                                                                                                                                        ( List.Mem.head RULEᵤ.CENTER.PAST ) );
                                                                                               /- := Check Outgoing-Indirect Duo: -/
                                                                                               cases Prop_Out_Indᵢₑ₁ᵥ with | intro Incᵢₑ₁ᵥ Prop_Out_Indᵢₑ₁ᵥ =>
                                                                                               --
                                                                                               apply Exists.intro Incᵢₑ₁ᵥ;
                                                                                               exact ( by simp only [List.Mem_Or_Mem_Iff_Mem_Append];                   /- := path OUT.END inc [0, OUT.COLOUR] ∈ INDIRECT -/
                                                                                                           apply Or.inl;
                                                                                                           exact Prop_Out_Indᵢₑ₁ᵥ; );
                                           | inr Prop_Outgoing₃ᵥ => cases Prop_Outgoing₃ᵥ with
                                                                    | inl Prop_Outgoingₕ₃ᵥ => simp only [type_outgoing₃.check_h₃] at Prop_Outgoingₕ₃ᵥ ⊢;
                                                                                              cases Prop_Outgoingₕ₃ᵥ with | intro Prop_HPTₕ₃ᵥ Prop_Outgoingₕ₃ᵥ =>
                                                                                              cases Prop_Outgoingₕ₃ᵥ with | intro Prop_Startₕ₃ᵥ Prop_Outgoingₕ₃ᵥ =>
                                                                                              cases Prop_Outgoingₕ₃ᵥ with | intro Prop_Endₕ₃ᵥ Prop_Outgoingₕ₃ᵥ =>
                                                                                              cases Prop_Outgoingₕ₃ᵥ with | intro Prop_Colourₕ₃ᵥ Prop_Out_Dirₕ₃ᵥ =>
                                                                                              --
                                                                                              apply Or.inr; apply Or.inl;
                                                                                              apply And.intro ( by rewrite [Bool.or_eq_true_iff];                                            /- := Type 3 Hypothesis -/
                                                                                                                   exact Or.inr Prop_HPTₕ₃ᵥ; );
                                                                                              apply And.intro ( by exact REWRITE.Get_Start_RwOutgoing out_casesᵥ; );                         /- := Start Node -/
                                                                                              apply And.intro ( by rewrite [prop_eq_lvl];                                                    /- := End Node -/
                                                                                                                   exact Prop_Endₕ₃ᵥ; );
                                                                                              apply And.intro ( by rewrite [prop_pstᵥ, List.Eq_Iff_Mem_Unit] at Prop_Colourₕ₃ᵥ;              /- := Colours -/
                                                                                                                   rewrite [Prop_Colourₕ₃ᵥ];
                                                                                                                   exact List.Mem.tail ( RULEᵤ.CENTER.NUMBER )
                                                                                                                                       ( List.Mem.head RULEᵤ.CENTER.PAST ) );
                                                                                              /- := Check Outgoing-Direct Duo: -/
                                                                                              cases Prop_Out_Dirₕ₃ᵥ with | intro Coloursₕ₃ᵥ Prop_Out_Dirₕ₃ᵥ =>
                                                                                              cases Prop_Out_Dirₕ₃ᵥ with | intro Ancₕ₃ᵥ Prop_Out_Dirₕ₃ᵥ =>
                                                                                              --
                                                                                              apply Exists.intro Coloursₕ₃ᵥ;
                                                                                              apply Exists.intro Ancₕ₃ᵥ;
                                                                                              exact ( by simp only [List.Mem_Or_Mem_Iff_Mem_Append];                    /- := path anc CENTER (OUT.COLOUR::colours) ∈ DIRECT -/
                                                                                                         apply Or.inl;
                                                                                                         exact REWRITE.Mem_RwDirect_Of_Mem Prop_Out_Dirₕ₃ᵥ; );
                                                                    | inr Prop_Outgoingᵢₑ₃ᵥ => simp only [type_outgoing₃.check_ie₃] at Prop_Outgoingᵢₑ₃ᵥ ⊢;
                                                                                               cases Prop_Outgoingᵢₑ₃ᵥ with | intro Prop_HPTᵢₑ₃ᵥ Prop_Outgoingᵢₑ₃ᵥ =>
                                                                                               cases Prop_Outgoingᵢₑ₃ᵥ with | intro Prop_Startᵢₑ₃ᵥ Prop_Outgoingᵢₑ₃ᵥ =>
                                                                                               cases Prop_Outgoingᵢₑ₃ᵥ with | intro Prop_Endᵢₑ₃ᵥ Prop_Outgoingᵢₑ₃ᵥ =>
                                                                                               cases Prop_Outgoingᵢₑ₃ᵥ with | intro Prop_Colourᵢₑ₃ᵥ Prop_Out_Indᵢₑ₃ᵥ =>
                                                                                               --
                                                                                               apply Or.inr; apply Or.inr;
                                                                                               apply And.intro ( by exact Or.inr trivial; );                                                 /- := Type 3 Introduction & Elimination -/
                                                                                               apply And.intro ( by exact REWRITE.Get_Start_RwOutgoing out_casesᵥ; );                        /- := Start Node -/
                                                                                               apply And.intro ( by rewrite [prop_eq_lvl];                                                   /- := End Node -/
                                                                                                                    exact Prop_Endᵢₑ₃ᵥ; );
                                                                                               apply And.intro ( by rewrite [prop_pstᵥ, List.Eq_Iff_Mem_Unit] at Prop_Colourᵢₑ₃ᵥ;            /- := Colours -/
                                                                                                                    rewrite [Prop_Colourᵢₑ₃ᵥ];
                                                                                                                    exact List.Mem.tail ( RULEᵤ.CENTER.NUMBER )
                                                                                                                                        ( List.Mem.head RULEᵤ.CENTER.PAST ) );
                                                                                               /- := Check Outgoing-Indirect Duo: -/
                                                                                               cases Prop_Out_Indᵢₑ₃ᵥ with | intro Coloursᵢₑ₃ᵥ Prop_Out_Indᵢₑ₃ᵥ =>
                                                                                               cases Prop_Out_Indᵢₑ₃ᵥ with | intro Incᵢₑ₃ᵥ Prop_Out_Indᵢₑ₃ᵥ =>
                                                                                               cases Prop_Out_Indᵢₑ₃ᵥ with | intro Ancᵢₑ₃ᵥ Prop_Out_Indᵢₑ₃ᵥ =>
                                                                                               --
                                                                                               apply Exists.intro Coloursᵢₑ₃ᵥ;
                                                                                               apply Exists.intro Incᵢₑ₃ᵥ;
                                                                                               apply Exists.intro Ancᵢₑ₃ᵥ;
                                                                                               exact ( by simp only [List.Mem_Or_Mem_Iff_Mem_Append];                   /- := path anc inc (0::OUT.COLOUR::colours) ∈ INDIRECT -/
                                                                                                          apply Or.inl;
                                                                                                          exact Prop_Out_Indᵢₑ₃ᵥ; );
                       | inr out_casesᵤ => have Out_Caseᵤ := REWRITE.Mem_Of_Mem_RwOutgoing out_casesᵤ;          /- := out ∈ RULEᵤ.OUTGOING -/
                                           cases Out_Caseᵤ with | intro Originalᵤ Out_Memᵤ =>
                                           have Prop_Outgoingᵤ := prop_outgoingᵤ Out_Memᵤ;                      /- := type_outgoing.check out RULEᵤ.CENTER -/
                                           cases Prop_Outgoingᵤ with
                                           | inl Prop_Outgoing₁ᵤ => cases Prop_Outgoing₁ᵤ with
                                                                    | inl Prop_Outgoingₕ₁ᵤ => simp only [type_outgoing₁.check_h₁] at Prop_Outgoingₕ₁ᵤ ⊢;
                                                                                              cases Prop_Outgoingₕ₁ᵤ with | intro Prop_HPTₕ₁ᵤ Prop_Outgoingₕ₁ᵤ =>
                                                                                              cases Prop_Outgoingₕ₁ᵤ with | intro Prop_Startₕ₁ᵤ Prop_Outgoingₕ₁ᵤ =>
                                                                                              cases Prop_Outgoingₕ₁ᵤ with | intro Prop_Endₕ₁ᵤ Prop_Colourₕ₁ᵤ =>
                                                                                              --
                                                                                              apply Or.inl; apply Or.inl;
                                                                                              apply And.intro ( by rewrite [Bool.or_eq_true_iff];                       /- := Type 1 Hypothesis -/
                                                                                                                   exact Or.inl Prop_HPTₕ₁ᵤ; );
                                                                                              apply And.intro ( by exact REWRITE.Get_Start_RwOutgoing out_casesᵤ; );    /- := Start Node -/
                                                                                              apply And.intro ( by exact Prop_Endₕ₁ᵤ; );                                /- := End Node -/
                                                                                              exact Prop_Colourₕ₁ᵤ;                                                     /- := Colours -/
                                                                    | inr Prop_Outgoingᵢₑ₁ᵤ => simp only [type_outgoing₁.check_ie₁] at Prop_Outgoingᵢₑ₁ᵤ ⊢;
                                                                                               cases Prop_Outgoingᵢₑ₁ᵤ with | intro Prop_HPTᵢₑ₁ᵤ Prop_Outgoingᵢₑ₁ᵤ =>
                                                                                               cases Prop_Outgoingᵢₑ₁ᵤ with | intro Prop_Startᵢₑ₁ᵤ Prop_Outgoingᵢₑ₁ᵤ =>
                                                                                               cases Prop_Outgoingᵢₑ₁ᵤ with | intro Prop_Endᵢₑ₁ᵤ Prop_Outgoingᵢₑ₁ᵤ =>
                                                                                               cases Prop_Outgoingᵢₑ₁ᵤ with | intro Prop_Colourᵢₑ₁ᵤ Prop_Out_Indᵢₑ₁ᵤ =>
                                                                                               --
                                                                                               apply Or.inl; apply Or.inr;
                                                                                               apply And.intro ( by exact Or.inr trivial; );                                                 /- := Type 1 Introduction & Elimination -/
                                                                                               apply And.intro ( by exact REWRITE.Get_Start_RwOutgoing out_casesᵤ; );                        /- := Start Node -/
                                                                                               apply And.intro ( by exact Prop_Endᵢₑ₁ᵤ; );                                                   /- := End Node -/
                                                                                               apply And.intro ( by rewrite [List.Eq_Or_Mem_Iff_Mem_Cons] at Prop_Colourᵢₑ₁ᵤ;                /- := Colours -/
                                                                                                                    cases Prop_Colourᵢₑ₁ᵤ with
                                                                                                                    | inl Prop_NBR_Colourᵢₑ₁ᵤ => rewrite [Prop_NBR_Colourᵢₑ₁ᵤ];
                                                                                                                                                 exact List.Mem.head ( RULEᵥ.CENTER.NUMBER :: RULEᵤ.CENTER.PAST );
                                                                                                                    | inr Prop_PST_Colourᵢₑ₁ᵤ => exact List.Mem.tail ( RULEᵤ.CENTER.NUMBER )
                                                                                                                                                                     ( List.Mem.tail RULEᵥ.CENTER.NUMBER Prop_PST_Colourᵢₑ₁ᵤ ); );
                                                                                               /- := Check Outgoing-Indirect Duo: -/
                                                                                               cases Prop_Out_Indᵢₑ₁ᵤ with | intro Incᵢₑ₁ᵤ Prop_Out_Indᵢₑ₁ᵤ =>
                                                                                               --
                                                                                               apply Exists.intro Incᵢₑ₁ᵤ;
                                                                                               exact ( by simp only [List.Mem_Or_Mem_Iff_Mem_Append];                   /- := path OUT.END inc [0, OUT.COLOUR] ∈ INDIRECT -/
                                                                                                           apply Or.inr;
                                                                                                           exact Prop_Out_Indᵢₑ₁ᵤ; );
                                           | inr Prop_Outgoing₃ᵤ => cases Prop_Outgoing₃ᵤ with
                                                                    | inl Prop_Outgoingₕ₃ᵤ => simp only [type_outgoing₃.check_h₃] at Prop_Outgoingₕ₃ᵤ ⊢;
                                                                                              cases Prop_Outgoingₕ₃ᵤ with | intro Prop_HPTₕ₃ᵤ Prop_Outgoingₕ₃ᵤ =>
                                                                                              cases Prop_Outgoingₕ₃ᵤ with | intro Prop_Startₕ₃ᵤ Prop_Outgoingₕ₃ᵤ =>
                                                                                              cases Prop_Outgoingₕ₃ᵤ with | intro Prop_Endₕ₃ᵤ Prop_Outgoingₕ₃ᵤ =>
                                                                                              cases Prop_Outgoingₕ₃ᵤ with | intro Prop_Colourₕ₃ᵤ Prop_Out_Dirₕ₃ᵤ =>
                                                                                              --
                                                                                              apply Or.inr; apply Or.inl;
                                                                                              apply And.intro ( by rewrite [Bool.or_eq_true_iff];                       /- := Type 1 Hypothesis -/
                                                                                                                   exact Or.inl Prop_HPTₕ₃ᵤ; );
                                                                                              apply And.intro ( by exact REWRITE.Get_Start_RwOutgoing out_casesᵤ; );    /- := Start Node -/
                                                                                              apply And.intro ( by exact Prop_Endₕ₃ᵤ; );                                /- := End Node -/
                                                                                              apply And.intro ( by rewrite [List.Eq_Or_Mem_Iff_Mem_Cons] at Prop_Colourₕ₃ᵤ;                  /- := Colours -/
                                                                                                                   cases Prop_Colourₕ₃ᵤ with
                                                                                                                   | inl Prop_NBR_Colourᵢₑ₃ᵤ => rewrite [Prop_NBR_Colourᵢₑ₃ᵤ];
                                                                                                                                                exact List.Mem.head ( RULEᵥ.CENTER.NUMBER :: RULEᵤ.CENTER.PAST );
                                                                                                                   | inr Prop_PST_Colourᵢₑ₃ᵤ => exact List.Mem.tail ( RULEᵤ.CENTER.NUMBER )
                                                                                                                                                                    ( List.Mem.tail RULEᵥ.CENTER.NUMBER Prop_PST_Colourᵢₑ₃ᵤ ); );
                                                                                              /- := Check Outgoing-Direct Duo: -/
                                                                                              cases Prop_Out_Dirₕ₃ᵤ with | intro Coloursₕ₃ᵤ Prop_Out_Dirₕ₃ᵤ =>
                                                                                              cases Prop_Out_Dirₕ₃ᵤ with | intro Ancₕ₃ᵤ Prop_Out_Dirₕ₃ᵤ =>
                                                                                              --
                                                                                              apply Exists.intro Coloursₕ₃ᵤ;
                                                                                              apply Exists.intro Ancₕ₃ᵤ;
                                                                                              exact ( by simp only [List.Mem_Or_Mem_Iff_Mem_Append];                    /- := path anc CENTER (OUT.COLOUR::colours) ∈ DIRECT -/
                                                                                                         apply Or.inr;
                                                                                                         exact REWRITE.Mem_RwDirect_Of_Mem Prop_Out_Dirₕ₃ᵤ; );
                                                                    | inr Prop_Outgoingᵢₑ₃ᵤ => simp only [type_outgoing₃.check_ie₃] at Prop_Outgoingᵢₑ₃ᵤ ⊢;
                                                                                               cases Prop_Outgoingᵢₑ₃ᵤ with | intro Prop_HPTᵢₑ₃ᵤ Prop_Outgoingᵢₑ₃ᵤ =>
                                                                                               cases Prop_Outgoingᵢₑ₃ᵤ with | intro Prop_Startᵢₑ₃ᵤ Prop_Outgoingᵢₑ₃ᵤ =>
                                                                                               cases Prop_Outgoingᵢₑ₃ᵤ with | intro Prop_Endᵢₑ₃ᵤ Prop_Outgoingᵢₑ₃ᵤ =>
                                                                                               cases Prop_Outgoingᵢₑ₃ᵤ with | intro Prop_Colourᵢₑ₃ᵤ Prop_Out_Indᵢₑ₃ᵤ =>
                                                                                               --
                                                                                               apply Or.inr; apply Or.inr;
                                                                                               apply And.intro ( by exact Or.inr trivial; );                            /- := Type 1 Introduction & Elimination -/
                                                                                               apply And.intro ( by exact REWRITE.Get_Start_RwOutgoing out_casesᵤ; );   /- := Start Node -/
                                                                                               apply And.intro ( by exact Prop_Endᵢₑ₃ᵤ; );                              /- := End Node -/
                                                                                               apply And.intro ( by rewrite [List.Eq_Or_Mem_Iff_Mem_Cons] at Prop_Colourᵢₑ₃ᵤ;                /- := Colours -/
                                                                                                                    cases Prop_Colourᵢₑ₃ᵤ with
                                                                                                                    | inl Prop_NBR_Colourᵢₑ₃ᵤ => rewrite [Prop_NBR_Colourᵢₑ₃ᵤ];
                                                                                                                                                 exact List.Mem.head ( RULEᵥ.CENTER.NUMBER :: RULEᵤ.CENTER.PAST );
                                                                                                                    | inr Prop_PST_Colourᵢₑ₃ᵤ => exact List.Mem.tail ( RULEᵤ.CENTER.NUMBER )
                                                                                                                                                                     ( List.Mem.tail RULEᵥ.CENTER.NUMBER Prop_PST_Colourᵢₑ₃ᵤ ); );
                                                                                               /- := Check Outgoing-Indirect Duo: -/
                                                                                               cases Prop_Out_Indᵢₑ₃ᵤ with | intro Coloursᵢₑ₃ᵤ Prop_Out_Indᵢₑ₃ᵤ =>
                                                                                               cases Prop_Out_Indᵢₑ₃ᵤ with | intro Incᵢₑ₃ᵤ Prop_Out_Indᵢₑ₃ᵤ =>
                                                                                               cases Prop_Out_Indᵢₑ₃ᵤ with | intro Ancᵢₑ₃ᵤ Prop_Out_Indᵢₑ₃ᵤ =>
                                                                                               --
                                                                                               apply Exists.intro Coloursᵢₑ₃ᵤ;
                                                                                               apply Exists.intro Incᵢₑ₃ᵤ;
                                                                                               apply Exists.intro Ancᵢₑ₃ᵤ;
                                                                                               exact ( by simp only [List.Mem_Or_Mem_Iff_Mem_Append];                   /- := path anc inc (0::OUT.COLOUR::colours) ∈ INDIRECT -/
                                                                                                          apply Or.inr;
                                                                                                          exact Prop_Out_Indᵢₑ₃ᵤ; ); );
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  /- Direct Paths -/--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  apply And.intro ( by simp only [type_direct] at prop_directᵤ prop_directᵥ ⊢;
                       simp only [List.Mem_Or_Mem_Iff_Mem_Append];
                       intro dir dir_cases;
                       cases dir_cases with
                       | inl dir_casesᵥ => have Dir_Casesᵥ := REWRITE.Mem_Of_Mem_RwDirect dir_casesᵥ;
                                           cases Dir_Casesᵥ with | intro Originalᵥ Dir_Memᵥ =>
                                           have Prop_Directᵥ := prop_directᵥ Dir_Memᵥ;
                                           simp only [type_direct.check] at Prop_Directᵥ ⊢;
                                           cases Prop_Directᵥ with | intro Prop_Startᵥ Prop_Directᵥ =>
                                           cases Prop_Directᵥ with | intro Prop_Endᵥ Prop_Directᵥ =>
                                           cases Prop_Directᵥ with | intro Prop_Levelᵥ Prop_Directᵥ =>
                                           cases Prop_Directᵥ with | intro Colour₁ᵥ Prop_Directᵥ =>
                                           cases Prop_Directᵥ with | intro Colour₂ᵥ Prop_Directᵥ =>
                                           cases Prop_Directᵥ with | intro Coloursᵥ Prop_Directᵥ =>
                                           cases Prop_Directᵥ with | intro Prop_Check_Coloursᵥ Prop_Directᵥ =>
                                           cases Prop_Directᵥ with | intro Prop_Colour₁ᵥ Prop_Directᵥ =>
                                           cases Prop_Directᵥ with | intro Prop_Coloursᵥ Prop_Dir_Outᵥ =>
                                           --
                                           apply And.intro ( by rewrite [prop_eq_lvl];                          /- := Start Node -/
                                                                exact Prop_Startᵥ; );
                                           apply And.intro ( by exact REWRITE.Get_End_RwDirect dir_casesᵥ; );   /- := End Node -/
                                           apply And.intro ( by rewrite [prop_eq_lvl];                          /- := Colours -/
                                                                exact Prop_Levelᵥ; );
                                           apply Exists.intro Colour₁ᵥ;
                                           apply Exists.intro Colour₂ᵥ;
                                           apply Exists.intro Coloursᵥ;
                                           apply And.intro ( by exact Prop_Check_Coloursᵥ; );
                                           apply And.intro ( by rewrite [prop_pstᵥ, List.Eq_Iff_Mem_Unit] at Prop_Colour₁ᵥ;
                                                                rewrite [Prop_Colour₁ᵥ];
                                                                exact List.Mem.tail ( RULEᵤ.CENTER.NUMBER )
                                                                                    ( List.Mem.head RULEᵤ.CENTER.PAST ); );
                                           apply And.intro ( by exact Prop_Coloursᵥ; );
                                           /- := Check Direct-Outgoing Duo: -/
                                           cases Prop_Dir_Outᵥ with | intro Outᵥ Prop_Dir_Outᵥ =>
                                           cases Prop_Dir_Outᵥ with | intro Dep_Outᵥ Prop_Dir_Outᵥ =>
                                           cases Prop_Dir_Outᵥ with | intro Prop_Out_Colᵥ Prop_Dir_Outᵥ =>
                                           cases Prop_Dir_Outᵥ with | intro Prop_Colour₂ᵥ Prop_Dir_Outᵥ =>
                                           cases Prop_Dir_Outᵥ with | intro Prop_Dir_Outᵥ Prop_All_Dir_Outᵥ =>
                                           --
                                           apply Exists.intro Outᵥ;
                                           apply Exists.intro Dep_Outᵥ;
                                           apply And.intro ( by exact Prop_Out_Colᵥ; );
                                           apply And.intro ( by exact Prop_Colour₂ᵥ; );
                                           apply And.intro ( by simp only [List.Mem_Or_Mem_Iff_Mem_Append];     /- := edge CENTER out colour₁ dep_out ∈ OUTGOING -/
                                                                apply Or.inl;
                                                                rewrite [←collapse.center];
                                                                exact REWRITE.Mem_RwOutgoing_Of_Mem Prop_Dir_Outᵥ; );
                                           intro all_outᵥ all_out_casesᵥ;                                       /- := all_out.COLOUR = colour₁ ↔ all_out = edge CENTER out colour₁ dep_out -/
                                           simp only [List.Mem_Or_Mem_Iff_Mem_Append] at all_out_casesᵥ;
                                           cases all_out_casesᵥ with
                                           | inl all_out_casesᵥᵥ => have Dir_Out_Casesᵥᵥ := REWRITE.Mem_Of_Mem_RwOutgoing all_out_casesᵥᵥ;                      /- := all_out ∈ RULEᵥ.OUTGOING -/
                                                                    cases Dir_Out_Casesᵥᵥ with | intro Originalᵥ Dir_Out_Memᵥᵥ =>
                                                                    have Prop_All_Dir_Outᵥᵥ := Prop_All_Dir_Outᵥ Dir_Out_Memᵥᵥ;                                 /- := all_out.COLOUR = Colour₁ ↔ all_out = edge CENTER out Colour₁ dep_out -/
                                                                    rewrite [Deduction.edge.injEq] at Prop_All_Dir_Outᵥᵥ ⊢;
                                                                    rewrite [←COLLAPSE.Simp_Out_Start₃ (prop_outgoingᵥ Dir_Out_Memᵥᵥ)] at Prop_All_Dir_Outᵥᵥ;   /- := all_out.START = RULEᵥ.CENTER -/
                                                                    rewrite [←REWRITE.Get_Start_RwOutgoing all_out_casesᵥᵥ];                                    /- := all_out.START = collapse.center RULEᵤ.CENTER RULEᵥ.CENTER -/
                                                                    simp only [true_and] at Prop_All_Dir_Outᵥᵥ ⊢;
                                                                    exact Prop_All_Dir_Outᵥᵥ;
                                           | inr all_out_casesᵥᵤ => have Dir_Out_Casesᵥᵤ := REWRITE.Mem_Of_Mem_RwOutgoing all_out_casesᵥᵤ;                      /- := all_out ∈ RULEᵤ.OUTGOING -/
                                                                    cases Dir_Out_Casesᵥᵤ with | intro Originalᵤ Dir_Out_Memᵥᵤ =>
                                                                    --
                                                                    have Prop_All_Outᵤ := prop_out_coloursᵤ Dir_Out_Memᵥᵤ eq_out_memᵤ (Or.inr eq_out_colourᵤ);  /- := all_out.COLOUR = eq_out.COLOUR ↔ all_out = eq_out -/
                                                                    rewrite [Deduction.edge.injEq] at Prop_All_Outᵤ ⊢;
                                                                    rewrite [←REWRITE.Get_Start_RwOutgoing all_out_casesᵥᵤ];                                    /- := all_out.START = collapse.center RULEᵤ.CENTER RULEᵥ.CENTER -/
                                                                    simp only [true_and] at Prop_All_Outᵤ ⊢;
                                                                    --
                                                                    rewrite [prop_out_unitᵥ] at Prop_Dir_Outᵥ;
                                                                    simp only [List.Eq_Iff_Mem_Unit] at Prop_Dir_Outᵥ;
                                                                    simp only [←Prop_Dir_Outᵥ] at prop_eq_out_end prop_eq_out_colour prop_eq_out_dependency;
                                                                    rewrite [prop_eq_out_end, prop_eq_out_colour, prop_eq_out_dependency];
                                                                    --
                                                                    exact Iff.intro ( by intro iff_eq_colourᵥᵤ;
                                                                                         rewrite [Prop_All_Outᵤ] at iff_eq_colourᵥᵤ;
                                                                                         simp only [iff_eq_colourᵥᵤ];
                                                                                         trivial; )
                                                                                    ( by intro iff_eq_edgeᵥᵤ;
                                                                                         simp only [iff_eq_edgeᵥᵤ]; );
                       | inr dir_casesᵤ => have Dir_Casesᵤ := REWRITE.Mem_Of_Mem_RwDirect dir_casesᵤ;
                                           cases Dir_Casesᵤ with | intro Originalᵤ Dir_Memᵤ =>
                                           have Prop_Directᵤ := prop_directᵤ Dir_Memᵤ;
                                           simp only [type_direct.check] at Prop_Directᵤ ⊢;
                                           cases Prop_Directᵤ with | intro Prop_Startᵤ Prop_Directᵤ =>
                                           cases Prop_Directᵤ with | intro Prop_Endᵤ Prop_Directᵤ =>
                                           cases Prop_Directᵤ with | intro Prop_Levelᵤ Prop_Directᵤ =>
                                           cases Prop_Directᵤ with | intro Colour₁ᵤ Prop_Directᵤ =>
                                           cases Prop_Directᵤ with | intro Colour₂ᵤ Prop_Directᵤ =>
                                           cases Prop_Directᵤ with | intro Coloursᵤ Prop_Directᵤ =>
                                           cases Prop_Directᵤ with | intro Prop_Check_Coloursᵤ Prop_Directᵤ =>
                                           cases Prop_Directᵤ with | intro Prop_Colour₁ᵤ Prop_Directᵤ =>
                                           cases Prop_Directᵤ with | intro Prop_Coloursᵤ Prop_Dir_Outᵤ =>
                                           --
                                           apply And.intro ( by exact Prop_Startᵤ; );                           /- := Start Node -/
                                           apply And.intro ( by exact REWRITE.Get_End_RwDirect dir_casesᵤ; );   /- := End Node -/
                                           apply And.intro ( by exact Prop_Levelᵤ; );                           /- := Colours -/
                                           apply Exists.intro Colour₁ᵤ;
                                           apply Exists.intro Colour₂ᵤ;
                                           apply Exists.intro Coloursᵤ;
                                           apply And.intro ( by exact Prop_Check_Coloursᵤ; );
                                           apply And.intro ( by rewrite [List.Eq_Or_Mem_Iff_Mem_Cons] at Prop_Colour₁ᵤ;
                                                                cases Prop_Colour₁ᵤ with
                                                                | inl Prop_NBR_Colour₁ᵤ => rewrite [Prop_NBR_Colour₁ᵤ];
                                                                                           exact List.Mem.head ( RULEᵥ.CENTER.NUMBER :: RULEᵤ.CENTER.PAST );
                                                                | inr Prop_PST_Colour₁ᵤ => exact List.Mem.tail ( RULEᵤ.CENTER.NUMBER )
                                                                                                               ( List.Mem.tail RULEᵥ.CENTER.NUMBER Prop_PST_Colour₁ᵤ ); );
                                           apply And.intro ( by exact Prop_Coloursᵤ; );
                                           /- := Check Direct-Outgoing Duo: -/
                                           cases Prop_Dir_Outᵤ with | intro Outᵤ Prop_Dir_Outᵤ =>
                                           cases Prop_Dir_Outᵤ with | intro Dep_Outᵤ Prop_Dir_Outᵤ =>
                                           cases Prop_Dir_Outᵤ with | intro Prop_Out_Colᵤ Prop_Dir_Outᵤ =>
                                           cases Prop_Dir_Outᵤ with | intro Prop_Colour₂ᵤ Prop_Dir_Outᵤ =>
                                           cases Prop_Dir_Outᵤ with | intro Prop_Dir_Outᵤ Prop_All_Dir_Outᵤ =>
                                           --
                                           apply Exists.intro Outᵤ;
                                           apply Exists.intro Dep_Outᵤ;
                                           apply And.intro ( by exact Prop_Out_Colᵤ; );
                                           apply And.intro ( by exact Prop_Colour₂ᵤ; );
                                           apply And.intro ( by simp only [List.Mem_Or_Mem_Iff_Mem_Append];     /- := edge CENTER out colour₁ dep_out ∈ OUTGOING -/
                                                                apply Or.inr;
                                                                rewrite [←collapse.center];
                                                                exact REWRITE.Mem_RwOutgoing_Of_Mem Prop_Dir_Outᵤ; );
                                           intro all_outᵤ all_out_casesᵤ;                                       /- := all_out.COLOUR = colour₁ ↔ all_out = edge CENTER out colour₁ dep_out -/
                                           simp only [List.Mem_Or_Mem_Iff_Mem_Append] at all_out_casesᵤ;
                                           cases all_out_casesᵤ with
                                           | inl all_out_casesᵤᵥ => have Dir_Out_Casesᵤᵥ := REWRITE.Mem_Of_Mem_RwOutgoing all_out_casesᵤᵥ;                      /- := all_out ∈ RULEᵥ.OUTGOING -/
                                                                    cases Dir_Out_Casesᵤᵥ with | intro Originalᵥ Dir_Out_Memᵤᵥ =>
                                                                    rewrite [prop_out_unitᵥ] at Dir_Out_Memᵤᵥ;
                                                                    rewrite [List.Eq_Iff_Mem_Unit] at Dir_Out_Memᵤᵥ;
                                                                    rewrite [Deduction.edge.injEq] at Dir_Out_Memᵤᵥ ⊢;
                                                                    cases Dir_Out_Memᵤᵥ with | intro Dir_Out_Startᵤᵥ Dir_Out_Memᵤᵥ =>
                                                                    cases Dir_Out_Memᵤᵥ with | intro Dir_Out_Endᵤᵥ Dir_Out_Memᵤᵥ =>
                                                                    cases Dir_Out_Memᵤᵥ with | intro Dir_Out_Colourᵤᵥ Dir_Out_Dependencyᵤᵥ =>
                                                                    rewrite [Dir_Out_Endᵤᵥ, Dir_Out_Colourᵤᵥ, Dir_Out_Dependencyᵤᵥ];
                                                                    rewrite [prop_eq_out_end, prop_eq_out_colour, prop_eq_out_dependency];
                                                                    --
                                                                    have Prop_All_Outᵤ := prop_out_coloursᵤ eq_out_memᵤ Prop_Dir_Outᵤ (Or.inl eq_out_colourᵤ);  /- := all_out.COLOUR = eq_out.COLOUR ↔ all_out = eq_out -/
                                                                    rewrite [Deduction.edge.injEq] at Prop_All_Outᵤ;
                                                                    rewrite [←REWRITE.Get_Start_RwOutgoing all_out_casesᵤᵥ];                                    /- := all_out.START = collapse.center RULEᵤ.CENTER RULEᵥ.CENTER -/
                                                                    simp only [true_and] at Prop_All_Outᵤ ⊢;
                                                                    --
                                                                    exact Iff.intro ( by intro iff_eq_colourᵤᵥ;
                                                                                         rewrite [Prop_All_Outᵤ] at iff_eq_colourᵤᵥ;
                                                                                         simp only [iff_eq_colourᵤᵥ];
                                                                                         trivial; )
                                                                                    ( by intro iff_eq_edgeᵤᵥ;
                                                                                         simp only [iff_eq_edgeᵤᵥ]; );
                                           | inr all_out_casesᵤᵤ => have Dir_Out_Casesᵤᵤ := REWRITE.Mem_Of_Mem_RwOutgoing all_out_casesᵤᵤ;                      /- := all_out ∈ RULEᵤ.OUTGOING -/
                                                                    cases Dir_Out_Casesᵤᵤ with | intro Originalᵤ Dir_Out_Memᵤᵤ =>
                                                                    have Prop_All_Dir_Outᵤᵤ := Prop_All_Dir_Outᵤ Dir_Out_Memᵤᵤ;                                 /- := all_out.COLOUR = Colour₁ ↔ all_out = edge CENTER out Colour₁ dep_out -/
                                                                    rewrite [Deduction.edge.injEq] at Prop_All_Dir_Outᵤᵤ ⊢;
                                                                    rewrite [←COLLAPSE.Simp_Out_Start₃ (prop_outgoingᵤ Dir_Out_Memᵤᵤ)] at Prop_All_Dir_Outᵤᵤ;   /- := all_out.START = RULEᵤ.CENTER -/
                                                                    rewrite [←REWRITE.Get_Start_RwOutgoing all_out_casesᵤᵤ];                                    /- := all_out.START = collapse.center RULEᵤ.CENTER RULEᵥ.CENTER -/
                                                                    simp only [true_and] at Prop_All_Dir_Outᵤᵤ ⊢;
                                                                    exact Prop_All_Dir_Outᵤᵤ; );
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  /- Indirect Paths -/------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  simp only [type_indirect] at prop_indirectᵤ prop_indirectᵥ ⊢;
  simp only [List.Mem_Or_Mem_Iff_Mem_Append];
  intro ind ind_cases;
  cases ind_cases with
  | inl ind_casesᵥ => have Prop_Indirectᵥ := prop_indirectᵥ ind_casesᵥ;
                      simp only [type_indirect.check] at Prop_Indirectᵥ ⊢;
                      cases Prop_Indirectᵥ with | intro Prop_Startᵥ Prop_Indirectᵥ =>
                      cases Prop_Indirectᵥ with | intro Prop_Endᵥ Prop_Indirectᵥ =>
                      cases Prop_Indirectᵥ with | intro Prop_Levelᵥ Prop_Indirectᵥ =>
                      cases Prop_Indirectᵥ with | intro Colourᵥ Prop_Indirectᵥ =>
                      cases Prop_Indirectᵥ with | intro Coloursᵥ Prop_Indirectᵥ =>
                      cases Prop_Indirectᵥ with | intro Prop_Check_Coloursᵥ Prop_Indirectᵥ =>
                      cases Prop_Indirectᵥ with | intro Prop_Colourᵥ Prop_Indirectᵥ =>
                      cases Prop_Indirectᵥ with | intro Prop_Coloursᵥ Prop_Indirectᵥ =>
                      cases Prop_Indirectᵥ with | intro Prop_Ind_Incᵥ Prop_Ind_Outᵥ =>
                      --
                      apply And.intro ( by rewrite [prop_eq_lvl];         /- := Start Node -/
                                           exact Prop_Startᵥ; );
                      apply And.intro ( by rewrite [prop_eq_lvl];         /- := End Node -/
                                           exact Prop_Endᵥ; );
                      apply And.intro ( by rewrite [prop_eq_lvl];         /- := Colours -/
                                           exact Prop_Levelᵥ; );
                      apply Exists.intro Colourᵥ;
                      apply Exists.intro Coloursᵥ;
                      apply And.intro ( by exact Prop_Check_Coloursᵥ; );
                      apply And.intro ( by rewrite [prop_pstᵥ, List.Eq_Iff_Mem_Unit] at Prop_Colourᵥ;
                                           rewrite [Prop_Colourᵥ];
                                           exact List.Mem.tail ( RULEᵤ.CENTER.NUMBER )
                                                               ( List.Mem.head RULEᵤ.CENTER.PAST ); );
                      apply And.intro ( by exact Prop_Coloursᵥ; );
                      /- := Check Indirect-Incoming Duo: -/
                      cases Prop_Ind_Incᵥ with | intro Dep_Incᵥ Prop_Ind_Incᵥ =>
                      cases Prop_Ind_Incᵥ with | intro Prop_Ind_Incᵥ Prop_All_Ind_Incᵥ =>
                      --
                      apply And.intro ( by apply Exists.intro Dep_Incᵥ;
                                           apply And.intro ( by simp only [List.Mem_Or_Mem_Iff_Mem_Append];   /- := edge IND.END CENTER 0 dep_inc ∈ INCOMING -/
                                                                apply Or.inl;
                                                                rewrite [←collapse.center];
                                                                exact REWRITE.Mem_RwIncoming_Of_Mem Prop_Ind_Incᵥ; );
                                           intro all_incᵥ all_inc_casesᵥ;                                     /- := all_inc.START = IND.END ↔ all_inc = edge IND.END CENTER 0 dep_inc -/
                                           simp only [List.Mem_Or_Mem_Iff_Mem_Append] at all_inc_casesᵥ;
                                           cases all_inc_casesᵥ with
                                           | inl all_inc_casesᵥᵥ => have Ind_Inc_Casesᵥᵥ := REWRITE.Mem_Of_Mem_RwIncoming all_inc_casesᵥᵥ;                      /- := all_inc ∈ RULEᵥ.INCOMING -/
                                                                    cases Ind_Inc_Casesᵥᵥ with | intro Originalᵥ Ind_Inc_Memᵥᵥ =>
                                                                    have Prop_All_Ind_Incᵥᵥ := Prop_All_Ind_Incᵥ Ind_Inc_Memᵥᵥ;                                 /- := all_inc.START = IND.END ↔ all_inc = edge IND.END CENTER 0 dep_inc -/
                                                                    rewrite [Deduction.edge.injEq] at Prop_All_Ind_Incᵥᵥ ⊢;
                                                                    rewrite [←COLLAPSE.Simp_Inc_End (prop_incomingᵥ Ind_Inc_Memᵥᵥ)] at Prop_All_Ind_Incᵥᵥ;      /- := all_inc.END = RULEᵥ.CENTER -/
                                                                    rewrite [←REWRITE.Get_End_RwIncoming all_inc_casesᵥᵥ];                                      /- := all_inc.END = collapse.center RULEᵤ.CENTER RULEᵥ.CENTER -/
                                                                    simp only [true_and] at Prop_All_Ind_Incᵥᵥ ⊢;
                                                                    exact Prop_All_Ind_Incᵥᵥ;
                                           | inr all_inc_casesᵥᵤ => have Ind_Inc_Casesᵥᵤ := REWRITE.Mem_Of_Mem_RwIncoming all_inc_casesᵥᵤ;                      /- := all_inc ∈ RULEᵤ.INCOMING -/
                                                                    cases Ind_Inc_Casesᵥᵤ with | intro Originalᵤ Ind_Inc_Memᵥᵤ =>
                                                                    rewrite [Deduction.edge.injEq];
                                                                    have Prop_Check_Incomingᵥᵤ := prop_check_incoming Ind_Inc_Memᵥᵤ Prop_Ind_Incᵥ;              /- := all_inc.START ≠ IND.END -/
                                                                    simp only [Prop_Check_Incomingᵥᵤ, false_and]; );
                      /- := Check Indirect-Outgoing Duo: -/
                      cases Prop_Ind_Outᵥ with | intro Outᵥ Prop_Ind_Outᵥ =>
                      cases Prop_Ind_Outᵥ with | intro Dep_Outᵥ Prop_Ind_Outᵥ =>
                      cases Prop_Ind_Outᵥ with | intro Prop_Out_Colᵥ Prop_Ind_Outᵥ =>
                      cases Prop_Ind_Outᵥ with | intro Prop_Ind_Outᵥ Prop_All_Ind_Outᵥ =>
                      --
                      apply Exists.intro Outᵥ;
                      apply Exists.intro Dep_Outᵥ;
                      apply And.intro ( by exact Prop_Out_Colᵥ; );
                      apply And.intro ( by simp only [List.Mem_Or_Mem_Iff_Mem_Append];     /- := edge CENTER out colour₁ dep_out ∈ OUTGOING -/
                                           apply Or.inl;
                                           rewrite [←collapse.center];
                                           exact REWRITE.Mem_RwOutgoing_Of_Mem Prop_Ind_Outᵥ; );
                      intro all_outᵥ all_out_casesᵥ;                                       /- := all_out.COLOUR = colour₁ ↔ all_out = edge CENTER out colour₁ dep_out -/
                      simp only [List.Mem_Or_Mem_Iff_Mem_Append] at all_out_casesᵥ;
                      cases all_out_casesᵥ with
                      | inl all_out_casesᵥᵥ => have Ind_Out_Casesᵥᵥ := REWRITE.Mem_Of_Mem_RwOutgoing all_out_casesᵥᵥ;                      /- := all_out ∈ RULEᵥ.OUTGOING -/
                                               cases Ind_Out_Casesᵥᵥ with | intro Originalᵥ Ind_Out_Memᵥᵥ =>
                                               have Prop_All_Ind_Outᵥᵥ := Prop_All_Ind_Outᵥ Ind_Out_Memᵥᵥ;                                 /- := all_out.COLOUR = Colour ↔ all_out = edge CENTER out Colour dep_out -/
                                               rewrite [Deduction.edge.injEq] at Prop_All_Ind_Outᵥᵥ ⊢;
                                               rewrite [←COLLAPSE.Simp_Out_Start₃ (prop_outgoingᵥ Ind_Out_Memᵥᵥ)] at Prop_All_Ind_Outᵥᵥ;   /- := all_out.START = RULEᵥ.CENTER -/
                                               rewrite [←REWRITE.Get_Start_RwOutgoing all_out_casesᵥᵥ];                                    /- := all_out.START = collapse.center RULEᵤ.CENTER RULEᵥ.CENTER -/
                                               simp only [true_and] at Prop_All_Ind_Outᵥᵥ ⊢;
                                               exact Prop_All_Ind_Outᵥᵥ;
                      | inr all_out_casesᵥᵤ => have Dir_Out_Casesᵥᵤ := REWRITE.Mem_Of_Mem_RwOutgoing all_out_casesᵥᵤ;                      /- := all_out ∈ RULEᵤ.OUTGOING -/
                                               cases Dir_Out_Casesᵥᵤ with | intro Originalᵤ Dir_Out_Memᵥᵤ =>
                                               --
                                               have Prop_All_Outᵤ := prop_out_coloursᵤ Dir_Out_Memᵥᵤ eq_out_memᵤ (Or.inr eq_out_colourᵤ);  /- := all_out.COLOUR = eq_out.COLOUR ↔ all_out = eq_out -/
                                               rewrite [Deduction.edge.injEq] at Prop_All_Outᵤ ⊢;
                                               rewrite [←REWRITE.Get_Start_RwOutgoing all_out_casesᵥᵤ];                                    /- := all_out.START = collapse.center RULEᵤ.CENTER RULEᵥ.CENTER -/
                                               simp only [true_and] at Prop_All_Outᵤ ⊢;
                                               --
                                               rewrite [prop_out_unitᵥ] at Prop_Ind_Outᵥ;
                                               simp only [List.Eq_Iff_Mem_Unit] at Prop_Ind_Outᵥ;
                                               simp only [←Prop_Ind_Outᵥ] at prop_eq_out_end prop_eq_out_colour prop_eq_out_dependency;
                                               rewrite [prop_eq_out_end, prop_eq_out_colour, prop_eq_out_dependency];
                                               --
                                               exact Iff.intro ( by intro iff_eq_colourᵥᵤ;
                                                                    rewrite [Prop_All_Outᵤ] at iff_eq_colourᵥᵤ;
                                                                    simp only [iff_eq_colourᵥᵤ];
                                                                    trivial; )
                                                               ( by intro iff_eq_edgeᵥᵤ;
                                                                    simp only [iff_eq_edgeᵥᵤ]; );
  | inr ind_casesᵤ => have Prop_Indirectᵤ := prop_indirectᵤ ind_casesᵤ;
                      simp only [type_indirect.check] at Prop_Indirectᵤ ⊢;
                      cases Prop_Indirectᵤ with | intro Prop_Startᵤ Prop_Indirectᵤ =>
                      cases Prop_Indirectᵤ with | intro Prop_Endᵤ Prop_Indirectᵤ =>
                      cases Prop_Indirectᵤ with | intro Prop_Levelᵤ Prop_Indirectᵤ =>
                      cases Prop_Indirectᵤ with | intro Colourᵤ Prop_Indirectᵤ =>
                      cases Prop_Indirectᵤ with | intro Coloursᵤ Prop_Indirectᵤ =>
                      cases Prop_Indirectᵤ with | intro Prop_Check_Coloursᵤ Prop_Indirectᵤ =>
                      cases Prop_Indirectᵤ with | intro Prop_Colourᵤ Prop_Indirectᵤ =>
                      cases Prop_Indirectᵤ with | intro Prop_Coloursᵤ Prop_Indirectᵤ =>
                      cases Prop_Indirectᵤ with | intro Prop_Ind_Incᵤ Prop_Ind_Outᵤ =>
                      --
                      apply And.intro ( by exact Prop_Startᵤ; );           /- := Start Node -/
                      apply And.intro ( by exact Prop_Endᵤ; );             /- := End Node -/
                      apply And.intro ( by exact Prop_Levelᵤ; );           /- := Colours -/
                      apply Exists.intro Colourᵤ;
                      apply Exists.intro Coloursᵤ;
                      apply And.intro ( by exact Prop_Check_Coloursᵤ; );
                      apply And.intro ( by rewrite [List.Eq_Or_Mem_Iff_Mem_Cons] at Prop_Colourᵤ;
                                           cases Prop_Colourᵤ with
                                           | inl Prop_NBR_Colourᵤ => rewrite [Prop_NBR_Colourᵤ];
                                                                     exact List.Mem.head ( RULEᵥ.CENTER.NUMBER :: RULEᵤ.CENTER.PAST );
                                           | inr Prop_PST_Colourᵤ => exact List.Mem.tail ( RULEᵤ.CENTER.NUMBER )
                                                                                         ( List.Mem.tail RULEᵥ.CENTER.NUMBER Prop_PST_Colourᵤ ); );
                      apply And.intro ( by exact Prop_Coloursᵤ; );
                      /- := Check Indirect-Incoming Duo: -/
                      cases Prop_Ind_Incᵤ with | intro Dep_Incᵤ Prop_Ind_Incᵤ =>
                      cases Prop_Ind_Incᵤ with | intro Prop_Ind_Incᵤ Prop_All_Ind_Incᵤ =>
                      --
                      apply And.intro ( by apply Exists.intro Dep_Incᵤ;
                                           apply And.intro ( by simp only [List.Mem_Or_Mem_Iff_Mem_Append];   /- := edge IND.END CENTER 0 dep_inc ∈ INCOMING -/
                                                                apply Or.inr;
                                                                rewrite [←collapse.center];
                                                                exact REWRITE.Mem_RwIncoming_Of_Mem Prop_Ind_Incᵤ; );
                                           intro all_incᵤ all_inc_casesᵤ;                                     /- := all_inc.START = IND.END ↔ all_inc = edge IND.END CENTER 0 dep_inc -/
                                           simp only [List.Mem_Or_Mem_Iff_Mem_Append] at all_inc_casesᵤ;
                                           cases all_inc_casesᵤ with
                                           | inl all_inc_casesᵤᵥ => have Ind_Inc_Casesᵤᵥ := REWRITE.Mem_Of_Mem_RwIncoming all_inc_casesᵤᵥ;                      /- := all_inc ∈ RULEᵥ.INCOMING -/
                                                                    cases Ind_Inc_Casesᵤᵥ with | intro Originalᵥ Ind_Inc_Memᵤᵥ =>
                                                                    rewrite [Deduction.edge.injEq];
                                                                    have Prop_Check_Incomingᵤᵥ := prop_check_incoming Prop_Ind_Incᵤ Ind_Inc_Memᵤᵥ;              /- := IND.END ≠ all_inc.START -/
                                                                    rewrite [ne_comm] at Prop_Check_Incomingᵤᵥ;
                                                                    simp only [Prop_Check_Incomingᵤᵥ, false_and];
                                           | inr all_inc_casesᵤᵤ => have Ind_Inc_Casesᵤᵤ := REWRITE.Mem_Of_Mem_RwIncoming all_inc_casesᵤᵤ;                      /- := all_inc ∈ RULEᵤ.INCOMING -/
                                                                    cases Ind_Inc_Casesᵤᵤ with | intro Originalᵤ Ind_Inc_Memᵤᵤ =>
                                                                    have Prop_All_Ind_Incᵤᵤ := Prop_All_Ind_Incᵤ Ind_Inc_Memᵤᵤ;                                 /- := all_inc.START = IND.END ↔ all_inc = edge IND.END CENTER 0 dep_inc -/
                                                                    rewrite [Deduction.edge.injEq] at Prop_All_Ind_Incᵤᵤ ⊢;
                                                                    rewrite [←COLLAPSE.Simp_Inc_End (prop_incomingᵤ Ind_Inc_Memᵤᵤ)] at Prop_All_Ind_Incᵤᵤ;      /- := all_inc.END = RULEᵤ.CENTER -/
                                                                    rewrite [←REWRITE.Get_End_RwIncoming all_inc_casesᵤᵤ];                                      /- := all_inc.END = collapse.center RULEᵤ.CENTER RULEᵥ.CENTER -/
                                                                    simp only [true_and] at Prop_All_Ind_Incᵤᵤ ⊢;
                                                                    exact Prop_All_Ind_Incᵤᵤ; );
                      /- Check Outgoing-Indirect Duo: -/
                      cases Prop_Ind_Outᵤ with | intro Outᵤ Prop_Ind_Outᵤ =>
                      cases Prop_Ind_Outᵤ with | intro Dep_Outᵤ Prop_Ind_Outᵤ =>
                      cases Prop_Ind_Outᵤ with | intro Prop_Out_Colᵤ Prop_Ind_Outᵤ =>
                      cases Prop_Ind_Outᵤ with | intro Prop_Ind_Outᵤ Prop_All_Ind_Outᵤ =>
                      --
                      apply Exists.intro Outᵤ;
                      apply Exists.intro Dep_Outᵤ;
                      apply And.intro ( by exact Prop_Out_Colᵤ; );
                      apply And.intro ( by simp only [List.Mem_Or_Mem_Iff_Mem_Append];     /- := edge CENTER out colour dep_out ∈ OUTGOING -/
                                           apply Or.inr;
                                           rewrite [←collapse.center];
                                           exact REWRITE.Mem_RwOutgoing_Of_Mem Prop_Ind_Outᵤ; );
                      intro all_outᵤ all_out_casesᵤ;                                       /- := all_out.COLOUR = colour ↔ all_out = edge CENTER out colour₁ dep_out -/
                      simp only [List.Mem_Or_Mem_Iff_Mem_Append] at all_out_casesᵤ;
                      cases all_out_casesᵤ with
                      | inl all_out_casesᵤᵥ => have Dir_Out_Casesᵤᵥ := REWRITE.Mem_Of_Mem_RwOutgoing all_out_casesᵤᵥ;                      /- := all_out ∈ RULEᵥ.OUTGOING -/
                                               cases Dir_Out_Casesᵤᵥ with | intro Originalᵥ Dir_Out_Memᵤᵥ =>
                                               rewrite [prop_out_unitᵥ] at Dir_Out_Memᵤᵥ;
                                               rewrite [List.Eq_Iff_Mem_Unit] at Dir_Out_Memᵤᵥ;
                                               rewrite [Deduction.edge.injEq] at Dir_Out_Memᵤᵥ ⊢;
                                               cases Dir_Out_Memᵤᵥ with | intro Dir_Out_Startᵤᵥ Dir_Out_Memᵤᵥ =>
                                               cases Dir_Out_Memᵤᵥ with | intro Dir_Out_Endᵤᵥ Dir_Out_Memᵤᵥ =>
                                               cases Dir_Out_Memᵤᵥ with | intro Dir_Out_Colourᵤᵥ Dir_Out_Dependencyᵤᵥ =>
                                               rewrite [Dir_Out_Endᵤᵥ, Dir_Out_Colourᵤᵥ, Dir_Out_Dependencyᵤᵥ];
                                               rewrite [prop_eq_out_end, prop_eq_out_colour, prop_eq_out_dependency];
                                               --
                                               have Prop_All_Outᵤ := prop_out_coloursᵤ eq_out_memᵤ Prop_Ind_Outᵤ (Or.inl eq_out_colourᵤ);  /- := all_out.COLOUR = eq_out.COLOUR ↔ all_out = eq_out -/
                                               rewrite [Deduction.edge.injEq] at Prop_All_Outᵤ;
                                               rewrite [←REWRITE.Get_Start_RwOutgoing all_out_casesᵤᵥ];                                    /- := all_out.START = collapse.center RULEᵤ.CENTER RULEᵥ.CENTER -/
                                               simp only [true_and] at Prop_All_Outᵤ ⊢;
                                               --
                                               exact Iff.intro ( by intro iff_eq_colourᵤᵥ;
                                                                    rewrite [Prop_All_Outᵤ] at iff_eq_colourᵤᵥ;
                                                                    simp only [iff_eq_colourᵤᵥ];
                                                                    trivial; )
                                                               ( by intro iff_eq_edgeᵤᵥ;
                                                                    simp only [iff_eq_edgeᵤᵥ]; );
                      | inr all_out_casesᵤᵤ => have Ind_Out_Casesᵤᵤ := REWRITE.Mem_Of_Mem_RwOutgoing all_out_casesᵤᵤ;                      /- := all_out ∈ RULEᵤ.OUTGOING -/
                                               cases Ind_Out_Casesᵤᵤ with | intro Originalᵤ Ind_Out_Memᵤᵤ =>
                                               have Prop_All_Ind_Outᵤᵤ := Prop_All_Ind_Outᵤ Ind_Out_Memᵤᵤ;                                 /- := all_out.COLOUR = Colour ↔ all_out = edge CENTER out Colour dep_out -/
                                               rewrite [Deduction.edge.injEq] at Prop_All_Ind_Outᵤᵤ ⊢;
                                               rewrite [←COLLAPSE.Simp_Out_Start₃ (prop_outgoingᵤ Ind_Out_Memᵤᵤ)] at Prop_All_Ind_Outᵤᵤ;   /- := all_out.START = RULEᵤ.CENTER -/
                                               rewrite [←REWRITE.Get_Start_RwOutgoing all_out_casesᵤᵤ];                                    /- := all_out.START = collapse.center RULEᵤ.CENTER RULEᵥ.CENTER -/
                                               simp only [true_and] at Prop_All_Ind_Outᵤᵤ ⊢;
                                               exact Prop_All_Ind_Outᵤᵤ;
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
end COVERAGE.T3_Of_T3.EDGES


namespace COVERAGE.R00.NODES
  /- R0E0E: Type0 ⊇-Elimination = Type0 ⊇-Elimination -/
  theorem Coverage_R0E0E {U V : Vertex} {DLDS : Graph} :
    ( check_collapse_nodes (pre_collapse (get_rule U DLDS) )
                           (pre_collapse (get_rule V DLDS) ) ) →
    ( type0_elimination (get_rule U DLDS) ) →
    ( type0_elimination (get_rule V DLDS) ) →
    ---------------------------
    ( type1_collapse (collapse_nodes U V DLDS) ) := by
  intro prop_check_nodes prop_typeᵤ prop_typeᵥ;
  have Prop_Typeᵤ := T1_Of_T0.PreCol_Of_PreCollapse_Elim prop_typeᵤ;
  have Prop_Typeᵥ := T1_Of_T0.PreCol_Of_PreCollapse_Elim prop_typeᵥ;
  exact T1_Of_T1.NODES.Col_Of_Collapse_Pre_Pre ( prop_check_nodes ) ( Prop_Typeᵤ ) ( Prop_Typeᵥ );
  -----------------------------------------------------------------------------------------------------------------------------------------
  /- R0I0E: Type0 ⊇-Introduction = Type0 ⊇-Elimination -/
  theorem Coverage_R0I0E {U V : Vertex} {DLDS : Graph} :
    ( check_collapse_nodes (pre_collapse (get_rule U DLDS) )
                           (pre_collapse (get_rule V DLDS) ) ) →
    ( type0_introduction (get_rule U DLDS) ) →
    ( type0_elimination (get_rule V DLDS) ) →
    ---------------------------
    ( type1_collapse (collapse_nodes U V DLDS) ) := by
  intro prop_check_nodes prop_typeᵤ prop_typeᵥ;
  have Prop_Typeᵤ := T1_Of_T0.PreCol_Of_PreCollapse_Intro prop_typeᵤ;
  have Prop_Typeᵥ := T1_Of_T0.PreCol_Of_PreCollapse_Elim prop_typeᵥ;
  exact T1_Of_T1.NODES.Col_Of_Collapse_Pre_Pre ( prop_check_nodes ) ( Prop_Typeᵤ ) ( Prop_Typeᵥ );
  -----------------------------------------------------------------------------------------------------------------------------------------
  /- R0H0E: Type0 Hypothesis = Type0 ⊇-Elimination -/
  theorem Coverage_R0H0E {U V : Vertex} {DLDS : Graph} :
    ( check_collapse_nodes (pre_collapse (get_rule U DLDS) )
                           (pre_collapse (get_rule V DLDS) ) ) →
    ( type0_hypothesis (get_rule U DLDS) ) →
    ( type0_elimination (get_rule V DLDS) ) →
    ---------------------------
    ( type1_collapse (collapse_nodes U V DLDS) ) := by
  intro prop_check_nodes prop_typeᵤ prop_typeᵥ;
  have Prop_Typeᵤ := T1_Of_T0.PreCol_Of_PreCollapse_Top prop_typeᵤ;
  have Prop_Typeᵥ := T1_Of_T0.PreCol_Of_PreCollapse_Elim prop_typeᵥ;
  exact T1_Of_T1.NODES.Col_Of_Collapse_Pre_Pre ( prop_check_nodes ) ( Prop_Typeᵤ ) ( Prop_Typeᵥ );
  -----------------------------------------------------------------------------------------------------------------------------------------
  /- R0E0I: Type0 ⊇-Elimination = Type0 ⊇-Introduction -/
  theorem Coverage_R0E0I {U V : Vertex} {DLDS : Graph} :
    ( check_collapse_nodes (pre_collapse (get_rule U DLDS) )
                           (pre_collapse (get_rule V DLDS) ) ) →
    ( type0_elimination (get_rule U DLDS) ) →
    ( type0_introduction (get_rule V DLDS) ) →
    ---------------------------
    ( type1_collapse (collapse_nodes U V DLDS) ) := by
  intro prop_check_nodes prop_typeᵤ prop_typeᵥ;
  have Prop_Typeᵤ := T1_Of_T0.PreCol_Of_PreCollapse_Elim prop_typeᵤ;
  have Prop_Typeᵥ := T1_Of_T0.PreCol_Of_PreCollapse_Intro prop_typeᵥ;
  exact T1_Of_T1.NODES.Col_Of_Collapse_Pre_Pre ( prop_check_nodes ) ( Prop_Typeᵤ ) ( Prop_Typeᵥ );
  -----------------------------------------------------------------------------------------------------------------------------------------
  /- R0I0I: Type0 ⊇-Introduction = Type0 ⊇-Introduction -/
  theorem Coverage_R0I0I {U V : Vertex} {DLDS : Graph} :
    ( check_collapse_nodes (pre_collapse (get_rule U DLDS) )
                           (pre_collapse (get_rule V DLDS) ) ) →
    ( type0_introduction (get_rule U DLDS) ) →
    ( type0_introduction (get_rule V DLDS) ) →
    ---------------------------
    ( type1_collapse (collapse_nodes U V DLDS) ) := by
  intro prop_check_nodes prop_typeᵤ prop_typeᵥ;
  have Prop_Typeᵤ := T1_Of_T0.PreCol_Of_PreCollapse_Intro prop_typeᵤ;
  have Prop_Typeᵥ := T1_Of_T0.PreCol_Of_PreCollapse_Intro prop_typeᵥ;
  exact T1_Of_T1.NODES.Col_Of_Collapse_Pre_Pre ( prop_check_nodes ) ( Prop_Typeᵤ ) ( Prop_Typeᵥ );
  -----------------------------------------------------------------------------------------------------------------------------------------
  /- R0I0H: Type0 Hypothesis = Type0 ⊇-Introduction -/
  theorem Coverage_R0H0I {U V : Vertex} {DLDS : Graph} :
    ( check_collapse_nodes (pre_collapse (get_rule U DLDS) )
                           (pre_collapse (get_rule V DLDS) ) ) →
    ( type0_hypothesis (get_rule U DLDS) ) →
    ( type0_introduction (get_rule V DLDS) ) →
    ---------------------------
    ( type1_collapse (collapse_nodes U V DLDS) ) := by
  intro prop_check_nodes prop_typeᵤ prop_typeᵥ;
  have Prop_Typeᵤ := T1_Of_T0.PreCol_Of_PreCollapse_Top prop_typeᵤ;
  have Prop_Typeᵥ := T1_Of_T0.PreCol_Of_PreCollapse_Intro prop_typeᵥ;
  exact T1_Of_T1.NODES.Col_Of_Collapse_Pre_Pre ( prop_check_nodes ) ( Prop_Typeᵤ ) ( Prop_Typeᵥ );
  -----------------------------------------------------------------------------------------------------------------------------------------
  /- R0E0H: Type0 ⊇-Elimination = Type0 ⊇-Hypothesis (Top Formula) -/
  theorem Coverage_R0E0H {U V : Vertex} {DLDS : Graph} :
    ( check_collapse_nodes (pre_collapse (get_rule U DLDS) )
                           (pre_collapse (get_rule V DLDS) ) ) →
    ( type0_elimination (get_rule U DLDS) ) →
    ( type0_hypothesis (get_rule V DLDS) ) →
    ---------------------------
    ( type1_collapse (collapse_nodes U V DLDS) ) := by
  intro prop_check_nodes prop_typeᵤ prop_typeᵥ;
  have Prop_Typeᵤ := T1_Of_T0.PreCol_Of_PreCollapse_Elim prop_typeᵤ;
  have Prop_Typeᵥ := T1_Of_T0.PreCol_Of_PreCollapse_Top prop_typeᵥ;
  exact T1_Of_T1.NODES.Col_Of_Collapse_Pre_Pre ( prop_check_nodes ) ( Prop_Typeᵤ ) ( Prop_Typeᵥ );
  -----------------------------------------------------------------------------------------------------------------------------------------
  /- R0I0H: Type0 ⊇-Introduction = Type0 ⊇-Hypothesis (Top Formula) -/
  theorem Coverage_R0I0H {U V : Vertex} {DLDS : Graph} :
    ( check_collapse_nodes (pre_collapse (get_rule U DLDS) )
                           (pre_collapse (get_rule V DLDS) ) ) →
    ( type0_introduction (get_rule U DLDS) ) →
    ( type0_hypothesis (get_rule V DLDS) ) →
    ---------------------------
    ( type1_collapse (collapse_nodes U V DLDS) ) := by
  intro prop_check_nodes prop_typeᵤ prop_typeᵥ;
  have Prop_Typeᵤ := T1_Of_T0.PreCol_Of_PreCollapse_Intro prop_typeᵤ;
  have Prop_Typeᵥ := T1_Of_T0.PreCol_Of_PreCollapse_Top prop_typeᵥ;
  exact T1_Of_T1.NODES.Col_Of_Collapse_Pre_Pre ( prop_check_nodes ) ( Prop_Typeᵤ ) ( Prop_Typeᵥ );
  -----------------------------------------------------------------------------------------------------------------------------------------
  /- R0H0H: Type0 Hypothesis = Type0 Hypothesis (Top Formula) -/
  theorem Coverage_R0H0H {U V : Vertex} {DLDS : Graph} :
    ( check_collapse_nodes (pre_collapse (get_rule U DLDS) )
                           (pre_collapse (get_rule V DLDS) ) ) →
    ( type0_hypothesis (get_rule U DLDS) ) →
    ( type0_hypothesis (get_rule V DLDS) ) →
    ---------------------------
    ( type1_collapse (collapse_nodes U V DLDS) ) := by
  intro prop_check_nodes prop_typeᵤ prop_typeᵥ;
  have Prop_Typeᵤ := T1_Of_T0.PreCol_Of_PreCollapse_Top prop_typeᵤ;
  have Prop_Typeᵥ := T1_Of_T0.PreCol_Of_PreCollapse_Top prop_typeᵥ;
  exact T1_Of_T1.NODES.Col_Of_Collapse_Pre_Pre ( prop_check_nodes ) ( Prop_Typeᵤ ) ( Prop_Typeᵥ );
  -----------------------------------------------------------------------------------------------------------------------------------------
end COVERAGE.R00.NODES

namespace COVERAGE.R02.NODES
  /- R0E0E: Type0 ⊇-Elimination = Type2 ⊇-Elimination -/
  theorem Coverage_R0E2E {U V : Vertex} {DLDS : Graph} :
    ( check_collapse_nodes (pre_collapse (get_rule U DLDS) )
                           (pre_collapse (get_rule V DLDS) ) ) →
    ( type0_elimination (get_rule U DLDS) ) →
    ( type2_elimination (get_rule V DLDS) ) →
    ---------------------------
    ( type3_collapse (collapse_nodes U V DLDS) ) := by
  intro prop_check_nodes prop_typeᵤ prop_typeᵥ;
  have Prop_Typeᵤ := T1_Of_T0.PreCol_Of_PreCollapse_Elim prop_typeᵤ;
  have Prop_Typeᵥ := T3_Of_T2.PreCol_Of_PreCollapse_Elim prop_typeᵥ;
  exact T3_Of_T3.NODES.Col_Of_Collapse_Pre_Pre ( prop_check_nodes ) ( T3_Of_T1.PreCol_Of_Pre Prop_Typeᵤ ) ( Prop_Typeᵥ );
  -----------------------------------------------------------------------------------------------------------------------------------------
  /- R0I0E: Type0 ⊇-Introduction = Type2 ⊇-Elimination -/
  theorem Coverage_R0I2E {U V : Vertex} {DLDS : Graph} :
    ( check_collapse_nodes (pre_collapse (get_rule U DLDS) )
                           (pre_collapse (get_rule V DLDS) ) ) →
    ( type0_introduction (get_rule U DLDS) ) →
    ( type2_elimination (get_rule V DLDS) ) →
    ---------------------------
    ( type3_collapse (collapse_nodes U V DLDS) ) := by
  intro prop_check_nodes prop_typeᵤ prop_typeᵥ;
  have Prop_Typeᵤ := T1_Of_T0.PreCol_Of_PreCollapse_Intro prop_typeᵤ;
  have Prop_Typeᵥ := T3_Of_T2.PreCol_Of_PreCollapse_Elim prop_typeᵥ;
  exact T3_Of_T3.NODES.Col_Of_Collapse_Pre_Pre ( prop_check_nodes ) ( T3_Of_T1.PreCol_Of_Pre Prop_Typeᵤ ) ( Prop_Typeᵥ );
  -----------------------------------------------------------------------------------------------------------------------------------------
  /- R0H0E: Type0 Hypothesis = Type2 ⊇-Elimination -/
  theorem Coverage_R0H2E {U V : Vertex} {DLDS : Graph} :
    ( check_collapse_nodes (pre_collapse (get_rule U DLDS) )
                           (pre_collapse (get_rule V DLDS) ) ) →
    ( type0_hypothesis (get_rule U DLDS) ) →
    ( type2_elimination (get_rule V DLDS) ) →
    ---------------------------
    ( type3_collapse (collapse_nodes U V DLDS) ) := by
  intro prop_check_nodes prop_typeᵤ prop_typeᵥ;
  have Prop_Typeᵤ := T1_Of_T0.PreCol_Of_PreCollapse_Top prop_typeᵤ;
  have Prop_Typeᵥ := T3_Of_T2.PreCol_Of_PreCollapse_Elim prop_typeᵥ;
  exact T3_Of_T3.NODES.Col_Of_Collapse_Pre_Pre ( prop_check_nodes ) ( T3_Of_T1.PreCol_Of_Pre Prop_Typeᵤ ) ( Prop_Typeᵥ );
  -----------------------------------------------------------------------------------------------------------------------------------------
  /- R0E0I: Type0 ⊇-Elimination = Type2 ⊇-Introduction -/
  theorem Coverage_R0E2I {U V : Vertex} {DLDS : Graph} :
    ( check_collapse_nodes (pre_collapse (get_rule U DLDS) )
                           (pre_collapse (get_rule V DLDS) ) ) →
    ( type0_elimination (get_rule U DLDS) ) →
    ( type2_introduction (get_rule V DLDS) ) →
    ---------------------------
    ( type3_collapse (collapse_nodes U V DLDS) ) := by
  intro prop_check_nodes prop_typeᵤ prop_typeᵥ;
  have Prop_Typeᵤ := T1_Of_T0.PreCol_Of_PreCollapse_Elim prop_typeᵤ;
  have Prop_Typeᵥ := T3_Of_T2.PreCol_Of_PreCollapse_Intro prop_typeᵥ;
  exact T3_Of_T3.NODES.Col_Of_Collapse_Pre_Pre ( prop_check_nodes ) ( T3_Of_T1.PreCol_Of_Pre Prop_Typeᵤ ) ( Prop_Typeᵥ );
  -----------------------------------------------------------------------------------------------------------------------------------------
  /- R0I0I: Type0 ⊇-Introduction = Type2 ⊇-Introduction -/
  theorem Coverage_R0I2I {U V : Vertex} {DLDS : Graph} :
    ( check_collapse_nodes (pre_collapse (get_rule U DLDS) )
                           (pre_collapse (get_rule V DLDS) ) ) →
    ( type0_introduction (get_rule U DLDS) ) →
    ( type2_introduction (get_rule V DLDS) ) →
    ---------------------------
    ( type3_collapse (collapse_nodes U V DLDS) ) := by
  intro prop_check_nodes prop_typeᵤ prop_typeᵥ;
  have Prop_Typeᵤ := T1_Of_T0.PreCol_Of_PreCollapse_Intro prop_typeᵤ;
  have Prop_Typeᵥ := T3_Of_T2.PreCol_Of_PreCollapse_Intro prop_typeᵥ;
  exact T3_Of_T3.NODES.Col_Of_Collapse_Pre_Pre ( prop_check_nodes ) ( T3_Of_T1.PreCol_Of_Pre Prop_Typeᵤ ) ( Prop_Typeᵥ );
  -----------------------------------------------------------------------------------------------------------------------------------------
  /- R0H0I: Type0 Hypothesis = Type2 Introduction -/
  theorem Coverage_R0H2I {U V : Vertex} {DLDS : Graph} :
    ( check_collapse_nodes (pre_collapse (get_rule U DLDS) )
                           (pre_collapse (get_rule V DLDS) ) ) →
    ( type0_hypothesis (get_rule U DLDS) ) →
    ( type2_introduction (get_rule V DLDS) ) →
    ---------------------------
    ( type3_collapse (collapse_nodes U V DLDS) ) := by
  intro prop_check_nodes prop_typeᵤ prop_typeᵥ;
  have Prop_Typeᵤ := T1_Of_T0.PreCol_Of_PreCollapse_Top prop_typeᵤ;
  have Prop_Typeᵥ := T3_Of_T2.PreCol_Of_PreCollapse_Intro prop_typeᵥ;
  exact T3_Of_T3.NODES.Col_Of_Collapse_Pre_Pre ( prop_check_nodes ) ( T3_Of_T1.PreCol_Of_Pre Prop_Typeᵤ ) ( Prop_Typeᵥ );
  -----------------------------------------------------------------------------------------------------------------------------------------
  /- R0E0H: Type0 ⊇-Elimination = Type2 ⊇-Hypothesis (Top Formula) -/
  theorem Coverage_R0E2H {U V : Vertex} {DLDS : Graph} :
    ( check_collapse_nodes (pre_collapse (get_rule U DLDS) )
                           (pre_collapse (get_rule V DLDS) ) ) →
    ( type0_elimination (get_rule U DLDS) ) →
    ( type2_hypothesis (get_rule V DLDS) ) →
    ---------------------------
    ( type3_collapse (collapse_nodes U V DLDS) ) := by
  intro prop_check_nodes prop_typeᵤ prop_typeᵥ;
  have Prop_Typeᵤ := T1_Of_T0.PreCol_Of_PreCollapse_Elim prop_typeᵤ;
  have Prop_Typeᵥ := T3_Of_T2.PreCol_Of_PreCollapse_Top prop_typeᵥ;
  exact T3_Of_T3.NODES.Col_Of_Collapse_Pre_Pre ( prop_check_nodes ) ( T3_Of_T1.PreCol_Of_Pre Prop_Typeᵤ ) ( Prop_Typeᵥ );
  -----------------------------------------------------------------------------------------------------------------------------------------
  /- R0I0H: Type0 ⊇-Introduction = Type2 ⊇-Hypothesis (Top Formula) -/
  theorem Coverage_R0I2H {U V : Vertex} {DLDS : Graph} :
    ( check_collapse_nodes (pre_collapse (get_rule U DLDS) )
                           (pre_collapse (get_rule V DLDS) ) ) →
    ( type0_introduction (get_rule U DLDS) ) →
    ( type2_hypothesis (get_rule V DLDS) ) →
    ---------------------------
    ( type3_collapse (collapse_nodes U V DLDS) ) := by
  intro prop_check_nodes prop_typeᵤ prop_typeᵥ;
  have Prop_Typeᵤ := T1_Of_T0.PreCol_Of_PreCollapse_Intro prop_typeᵤ;
  have Prop_Typeᵥ := T3_Of_T2.PreCol_Of_PreCollapse_Top prop_typeᵥ;
  exact T3_Of_T3.NODES.Col_Of_Collapse_Pre_Pre ( prop_check_nodes ) ( T3_Of_T1.PreCol_Of_Pre Prop_Typeᵤ ) ( Prop_Typeᵥ );
  -----------------------------------------------------------------------------------------------------------------------------------------
  /- R0H0H: Type0 Hypothesis = Type2 Hypothesis (Top Formula) -/
  theorem Coverage_R0H2H {U V : Vertex} {DLDS : Graph} :
    ( check_collapse_nodes (pre_collapse (get_rule U DLDS) )
                           (pre_collapse (get_rule V DLDS) ) ) →
    ( type0_hypothesis (get_rule U DLDS) ) →
    ( type2_hypothesis (get_rule V DLDS) ) →
    ---------------------------
    ( type3_collapse (collapse_nodes U V DLDS) ) := by
  intro prop_check_nodes prop_typeᵤ prop_typeᵥ;
  have Prop_Typeᵤ := T1_Of_T0.PreCol_Of_PreCollapse_Top prop_typeᵤ;
  have Prop_Typeᵥ := T3_Of_T2.PreCol_Of_PreCollapse_Top prop_typeᵥ;
  exact T3_Of_T3.NODES.Col_Of_Collapse_Pre_Pre ( prop_check_nodes ) ( T3_Of_T1.PreCol_Of_Pre Prop_Typeᵤ ) ( Prop_Typeᵥ );
  -----------------------------------------------------------------------------------------------------------------------------------------
end COVERAGE.R02.NODES

namespace COVERAGE.R20.NODES
  /- R2E0E: Type2 ⊇-Elimination = Type0 ⊇-Elimination -/
  theorem Coverage_R2E0E {U V : Vertex} {DLDS : Graph} :
    ( check_collapse_nodes (pre_collapse (get_rule U DLDS) )
                           (pre_collapse (get_rule V DLDS) ) ) →
    ( type2_elimination (get_rule U DLDS) ) →
    ( type0_elimination (get_rule V DLDS) ) →
    ---------------------------
    ( type3_collapse (collapse_nodes U V DLDS) ) := by
  intro prop_check_nodes prop_typeᵤ prop_typeᵥ;
  have Prop_Typeᵤ := T3_Of_T2.PreCol_Of_PreCollapse_Elim prop_typeᵤ;
  have Prop_Typeᵥ := T1_Of_T0.PreCol_Of_PreCollapse_Elim prop_typeᵥ;
  exact T3_Of_T3.NODES.Col_Of_Collapse_Pre_Pre ( prop_check_nodes ) ( Prop_Typeᵤ ) ( T3_Of_T1.PreCol_Of_Pre Prop_Typeᵥ );
  -----------------------------------------------------------------------------------------------------------------------------------------
  /- R2I0E: Type2 ⊇-Introduction = Type0 ⊇-Elimination -/
  theorem Coverage_R2I0E {U V : Vertex} {DLDS : Graph} :
    ( check_collapse_nodes (pre_collapse (get_rule U DLDS) )
                           (pre_collapse (get_rule V DLDS) ) ) →
    ( type2_introduction (get_rule U DLDS) ) →
    ( type0_elimination (get_rule V DLDS) ) →
    ---------------------------
    ( type3_collapse (collapse_nodes U V DLDS) ) := by
  intro prop_check_nodes prop_typeᵤ prop_typeᵥ;
  have Prop_Typeᵤ := T3_Of_T2.PreCol_Of_PreCollapse_Intro prop_typeᵤ;
  have Prop_Typeᵥ := T1_Of_T0.PreCol_Of_PreCollapse_Elim prop_typeᵥ;
  exact T3_Of_T3.NODES.Col_Of_Collapse_Pre_Pre ( prop_check_nodes ) ( Prop_Typeᵤ ) ( T3_Of_T1.PreCol_Of_Pre Prop_Typeᵥ );
  -----------------------------------------------------------------------------------------------------------------------------------------
  /- R2H0E: Type2 Hypothesis = Type0 ⊇-Elimination -/
  theorem Coverage_R2H0E {U V : Vertex} {DLDS : Graph} :
    ( check_collapse_nodes (pre_collapse (get_rule U DLDS) )
                           (pre_collapse (get_rule V DLDS) ) ) →
    ( type2_hypothesis (get_rule U DLDS) ) →
    ( type0_elimination (get_rule V DLDS) ) →
    ---------------------------
    ( type3_collapse (collapse_nodes U V DLDS) ) := by
  intro prop_check_nodes prop_typeᵤ prop_typeᵥ;
  have Prop_Typeᵤ := T3_Of_T2.PreCol_Of_PreCollapse_Top prop_typeᵤ;
  have Prop_Typeᵥ := T1_Of_T0.PreCol_Of_PreCollapse_Elim prop_typeᵥ;
  exact T3_Of_T3.NODES.Col_Of_Collapse_Pre_Pre ( prop_check_nodes ) ( Prop_Typeᵤ ) ( T3_Of_T1.PreCol_Of_Pre Prop_Typeᵥ );
  -----------------------------------------------------------------------------------------------------------------------------------------
  /- R2E0I: Type2 ⊇-Elimination = Type0 ⊇-Introduction -/
  theorem Coverage_R2E0I {U V : Vertex} {DLDS : Graph} :
    ( check_collapse_nodes (pre_collapse (get_rule U DLDS) )
                           (pre_collapse (get_rule V DLDS) ) ) →
    ( type2_elimination (get_rule U DLDS) ) →
    ( type0_introduction (get_rule V DLDS) ) →
    ---------------------------
    ( type3_collapse (collapse_nodes U V DLDS) ) := by
  intro prop_check_nodes prop_typeᵤ prop_typeᵥ;
  have Prop_Typeᵤ := T3_Of_T2.PreCol_Of_PreCollapse_Elim prop_typeᵤ;
  have Prop_Typeᵥ := T1_Of_T0.PreCol_Of_PreCollapse_Intro prop_typeᵥ;
  exact T3_Of_T3.NODES.Col_Of_Collapse_Pre_Pre ( prop_check_nodes ) ( Prop_Typeᵤ ) ( T3_Of_T1.PreCol_Of_Pre Prop_Typeᵥ );
  -----------------------------------------------------------------------------------------------------------------------------------------
  /- R2I0I: Type2 ⊇-Introduction = Type0 ⊇-Introduction -/
  theorem Coverage_R2I0I {U V : Vertex} {DLDS : Graph} :
    ( check_collapse_nodes (pre_collapse (get_rule U DLDS) )
                           (pre_collapse (get_rule V DLDS) ) ) →
    ( type2_introduction (get_rule U DLDS) ) →
    ( type0_introduction (get_rule V DLDS) ) →
    ---------------------------
    ( type3_collapse (collapse_nodes U V DLDS) ) := by
  intro prop_check_nodes prop_typeᵤ prop_typeᵥ;
  have Prop_Typeᵤ := T3_Of_T2.PreCol_Of_PreCollapse_Intro prop_typeᵤ;
  have Prop_Typeᵥ := T1_Of_T0.PreCol_Of_PreCollapse_Intro prop_typeᵥ;
  exact T3_Of_T3.NODES.Col_Of_Collapse_Pre_Pre ( prop_check_nodes ) ( Prop_Typeᵤ ) ( T3_Of_T1.PreCol_Of_Pre Prop_Typeᵥ );
  -----------------------------------------------------------------------------------------------------------------------------------------
  /- R2H0I: Type2 Hypothesis = Type0 Introduction -/
  theorem Coverage_R2H0I {U V : Vertex} {DLDS : Graph} :
    ( check_collapse_nodes (pre_collapse (get_rule U DLDS) )
                           (pre_collapse (get_rule V DLDS) ) ) →
    ( type2_hypothesis (get_rule U DLDS) ) →
    ( type0_introduction (get_rule V DLDS) ) →
    ---------------------------
    ( type3_collapse (collapse_nodes U V DLDS) ) := by
  intro prop_check_nodes prop_typeᵤ prop_typeᵥ;
  have Prop_Typeᵤ := T3_Of_T2.PreCol_Of_PreCollapse_Top prop_typeᵤ;
  have Prop_Typeᵥ := T1_Of_T0.PreCol_Of_PreCollapse_Intro prop_typeᵥ;
  exact T3_Of_T3.NODES.Col_Of_Collapse_Pre_Pre ( prop_check_nodes ) ( Prop_Typeᵤ ) ( T3_Of_T1.PreCol_Of_Pre Prop_Typeᵥ );
  -----------------------------------------------------------------------------------------------------------------------------------------
  /- R2E0H: Type2 ⊇-Elimination = Type0 ⊇-Hypothesis (Top Formula) -/
  theorem Coverage_R2E0H {U V : Vertex} {DLDS : Graph} :
    ( check_collapse_nodes (pre_collapse (get_rule U DLDS) )
                           (pre_collapse (get_rule V DLDS) ) ) →
    ( type2_elimination (get_rule U DLDS) ) →
    ( type0_hypothesis (get_rule V DLDS) ) →
    ---------------------------
    ( type3_collapse (collapse_nodes U V DLDS) ) := by
  intro prop_check_nodes prop_typeᵤ prop_typeᵥ;
  have Prop_Typeᵤ := T3_Of_T2.PreCol_Of_PreCollapse_Elim prop_typeᵤ;
  have Prop_Typeᵥ := T1_Of_T0.PreCol_Of_PreCollapse_Top prop_typeᵥ;
  exact T3_Of_T3.NODES.Col_Of_Collapse_Pre_Pre ( prop_check_nodes ) ( Prop_Typeᵤ ) ( T3_Of_T1.PreCol_Of_Pre Prop_Typeᵥ );
  -----------------------------------------------------------------------------------------------------------------------------------------
  /- R2I0H: Type2 ⊇-Introduction = Type0 ⊇-Hypothesis (Top Formula) -/
  theorem Coverage_R2I0H {U V : Vertex} {DLDS : Graph} :
    ( check_collapse_nodes (pre_collapse (get_rule U DLDS) )
                           (pre_collapse (get_rule V DLDS) ) ) →
    ( type2_introduction (get_rule U DLDS) ) →
    ( type0_hypothesis (get_rule V DLDS) ) →
    ---------------------------
    ( type3_collapse (collapse_nodes U V DLDS) ) := by
  intro prop_check_nodes prop_typeᵤ prop_typeᵥ;
  have Prop_Typeᵤ := T3_Of_T2.PreCol_Of_PreCollapse_Intro prop_typeᵤ;
  have Prop_Typeᵥ := T1_Of_T0.PreCol_Of_PreCollapse_Top prop_typeᵥ;
  exact T3_Of_T3.NODES.Col_Of_Collapse_Pre_Pre ( prop_check_nodes ) ( Prop_Typeᵤ ) ( T3_Of_T1.PreCol_Of_Pre Prop_Typeᵥ );
  -----------------------------------------------------------------------------------------------------------------------------------------
  /- R2H0H: Type2 Hypothesis = Type0 Hypothesis (Top Formula) -/
  theorem Coverage_R2H0H {U V : Vertex} {DLDS : Graph} :
    ( check_collapse_nodes (pre_collapse (get_rule U DLDS) )
                           (pre_collapse (get_rule V DLDS) ) ) →
    ( type2_hypothesis (get_rule U DLDS) ) →
    ( type0_hypothesis (get_rule V DLDS) ) →
    ---------------------------
    ( type3_collapse (collapse_nodes U V DLDS) ) := by
  intro prop_check_nodes prop_typeᵤ prop_typeᵥ;
  have Prop_Typeᵤ := T3_Of_T2.PreCol_Of_PreCollapse_Top prop_typeᵤ;
  have Prop_Typeᵥ := T1_Of_T0.PreCol_Of_PreCollapse_Top prop_typeᵥ;
  exact T3_Of_T3.NODES.Col_Of_Collapse_Pre_Pre ( prop_check_nodes ) ( Prop_Typeᵤ ) ( T3_Of_T1.PreCol_Of_Pre Prop_Typeᵥ );
  -----------------------------------------------------------------------------------------------------------------------------------------
end COVERAGE.R20.NODES

namespace COVERAGE.R22.NODES
  -----------------------------------------------------------------------------------------------------------------------------------------
  /- R2E2E: Type2 ⊇-Elimination = Type2 ⊇-Elimination -/
  theorem Coverage_R2E2E {U V : Vertex} {DLDS : Graph} :
    ( check_collapse_nodes (pre_collapse (get_rule U DLDS) )
                           (pre_collapse (get_rule V DLDS) ) ) →
    ( type2_elimination (get_rule U DLDS) ) →
    ( type2_elimination (get_rule V DLDS) ) →
    ---------------------------
    ( type3_collapse (collapse_nodes U V DLDS) ) := by
  intro prop_check_nodes prop_typeᵤ prop_typeᵥ;
  have Prop_Typeᵤ := T3_Of_T2.PreCol_Of_PreCollapse_Elim prop_typeᵤ;
  have Prop_Typeᵥ := T3_Of_T2.PreCol_Of_PreCollapse_Elim prop_typeᵥ;
  exact T3_Of_T3.NODES.Col_Of_Collapse_Pre_Pre ( prop_check_nodes ) ( Prop_Typeᵤ ) ( Prop_Typeᵥ );
  -----------------------------------------------------------------------------------------------------------------------------------------
  /- R2I2E: Type2 ⊇-Introduction = Type2 ⊇-Elimination -/
  theorem Coverage_R2I2E {U V : Vertex} {DLDS : Graph} :
    ( check_collapse_nodes (pre_collapse (get_rule U DLDS) )
                           (pre_collapse (get_rule V DLDS) ) ) →
    ( type2_introduction (get_rule U DLDS) ) →
    ( type2_elimination (get_rule V DLDS) ) →
    ---------------------------
    ( type3_collapse (collapse_nodes U V DLDS) ) := by
  intro prop_check_nodes prop_typeᵤ prop_typeᵥ;
  have Prop_Typeᵤ := T3_Of_T2.PreCol_Of_PreCollapse_Intro prop_typeᵤ;
  have Prop_Typeᵥ := T3_Of_T2.PreCol_Of_PreCollapse_Elim prop_typeᵥ;
  exact T3_Of_T3.NODES.Col_Of_Collapse_Pre_Pre ( prop_check_nodes ) ( Prop_Typeᵤ ) ( Prop_Typeᵥ );
  -----------------------------------------------------------------------------------------------------------------------------------------
  /- R2H2E: Type2 ⊇-Hypothesis = Type2 ⊇-Elimination -/
  theorem Coverage_R2H2E {U V : Vertex} {DLDS : Graph} :
    ( check_collapse_nodes (pre_collapse (get_rule U DLDS) )
                           (pre_collapse (get_rule V DLDS) ) ) →
    ( type2_hypothesis (get_rule U DLDS) ) →
    ( type2_elimination (get_rule V DLDS) ) →
    ---------------------------
    ( type3_collapse (collapse_nodes U V DLDS) ) := by
  intro prop_check_nodes prop_typeᵤ prop_typeᵥ;
  have Prop_Typeᵤ := T3_Of_T2.PreCol_Of_PreCollapse_Top prop_typeᵤ;
  have Prop_Typeᵥ := T3_Of_T2.PreCol_Of_PreCollapse_Elim prop_typeᵥ;
  exact T3_Of_T3.NODES.Col_Of_Collapse_Pre_Pre ( prop_check_nodes ) ( Prop_Typeᵤ ) ( Prop_Typeᵥ );
  -----------------------------------------------------------------------------------------------------------------------------------------
  /- R2E2I: Type2 ⊇-Elimination = Type2 ⊇-Introduction -/
  theorem Coverage_R2E2I {U V : Vertex} {DLDS : Graph} :
    ( check_collapse_nodes (pre_collapse (get_rule U DLDS) )
                           (pre_collapse (get_rule V DLDS) ) ) →
    ( type2_elimination (get_rule U DLDS) ) →
    ( type2_introduction (get_rule V DLDS) ) →
    ---------------------------
    ( type3_collapse (collapse_nodes U V DLDS) ) := by
  intro prop_check_nodes prop_typeᵤ prop_typeᵥ;
  have Prop_Typeᵤ := T3_Of_T2.PreCol_Of_PreCollapse_Elim prop_typeᵤ;
  have Prop_Typeᵥ := T3_Of_T2.PreCol_Of_PreCollapse_Intro prop_typeᵥ;
  exact T3_Of_T3.NODES.Col_Of_Collapse_Pre_Pre ( prop_check_nodes ) ( Prop_Typeᵤ ) ( Prop_Typeᵥ );
  -----------------------------------------------------------------------------------------------------------------------------------------
  /- R2I2I: Type2 ⊇-Introduction = Type2 ⊇-Introduction -/
  theorem Coverage_R2I2I {U V : Vertex} {DLDS : Graph} :
    ( check_collapse_nodes (pre_collapse (get_rule U DLDS) )
                           (pre_collapse (get_rule V DLDS) ) ) →
    ( type2_introduction (get_rule U DLDS) ) →
    ( type2_introduction (get_rule V DLDS) ) →
    ---------------------------
    ( type3_collapse (collapse_nodes U V DLDS) ) := by
  intro prop_check_nodes prop_typeᵤ prop_typeᵥ;
  have Prop_Typeᵤ := T3_Of_T2.PreCol_Of_PreCollapse_Intro prop_typeᵤ;
  have Prop_Typeᵥ := T3_Of_T2.PreCol_Of_PreCollapse_Intro prop_typeᵥ;
  exact T3_Of_T3.NODES.Col_Of_Collapse_Pre_Pre ( prop_check_nodes ) ( Prop_Typeᵤ ) ( Prop_Typeᵥ );
  -----------------------------------------------------------------------------------------------------------------------------------------
  /- R2H2I: Type2 ⊇-Hypothesis = Type2 Introduction -/
  theorem Coverage_R2H2I {U V : Vertex} {DLDS : Graph} :
    ( check_collapse_nodes (pre_collapse (get_rule U DLDS) )
                           (pre_collapse (get_rule V DLDS) ) ) →
    ( type2_hypothesis (get_rule U DLDS) ) →
    ( type2_introduction (get_rule V DLDS) ) →
    ---------------------------
    ( type3_collapse (collapse_nodes U V DLDS) ) := by
  intro prop_check_nodes prop_typeᵤ prop_typeᵥ;
  have Prop_Typeᵤ := T3_Of_T2.PreCol_Of_PreCollapse_Top prop_typeᵤ;
  have Prop_Typeᵥ := T3_Of_T2.PreCol_Of_PreCollapse_Intro prop_typeᵥ;
  exact T3_Of_T3.NODES.Col_Of_Collapse_Pre_Pre ( prop_check_nodes ) ( Prop_Typeᵤ ) ( Prop_Typeᵥ );
  -----------------------------------------------------------------------------------------------------------------------------------------
  /- R2E2H: Type2 ⊇-Elimination = Type2 ⊇-Hypothesis (Top Formula) -/
  theorem Coverage_R2E2H {U V : Vertex} {DLDS : Graph} :
    ( check_collapse_nodes (pre_collapse (get_rule U DLDS) )
                           (pre_collapse (get_rule V DLDS) ) ) →
    ( type2_elimination (get_rule U DLDS) ) →
    ( type2_hypothesis (get_rule V DLDS) ) →
    ---------------------------
    ( type3_collapse (collapse_nodes U V DLDS) ) := by
  intro prop_check_nodes prop_typeᵤ prop_typeᵥ;
  have Prop_Typeᵤ := T3_Of_T2.PreCol_Of_PreCollapse_Elim prop_typeᵤ;
  have Prop_Typeᵥ := T3_Of_T2.PreCol_Of_PreCollapse_Top prop_typeᵥ;
  exact T3_Of_T3.NODES.Col_Of_Collapse_Pre_Pre ( prop_check_nodes ) ( Prop_Typeᵤ ) ( Prop_Typeᵥ );
  -----------------------------------------------------------------------------------------------------------------------------------------
  /- R2I2H: Type2 ⊇-Introduction = Type2 ⊇-Hypothesis (Top Formula) -/
  theorem Coverage_R2I2H {U V : Vertex} {DLDS : Graph} :
    ( check_collapse_nodes (pre_collapse (get_rule U DLDS) )
                           (pre_collapse (get_rule V DLDS) ) ) →
    ( type2_introduction (get_rule U DLDS) ) →
    ( type2_hypothesis (get_rule V DLDS) ) →
    ---------------------------
    ( type3_collapse (collapse_nodes U V DLDS) ) := by
  intro prop_check_nodes prop_typeᵤ prop_typeᵥ;
  have Prop_Typeᵤ := T3_Of_T2.PreCol_Of_PreCollapse_Intro prop_typeᵤ;
  have Prop_Typeᵥ := T3_Of_T2.PreCol_Of_PreCollapse_Top prop_typeᵥ;
  exact T3_Of_T3.NODES.Col_Of_Collapse_Pre_Pre ( prop_check_nodes ) ( Prop_Typeᵤ ) ( Prop_Typeᵥ );
  -----------------------------------------------------------------------------------------------------------------------------------------
  /- R2H2H: Type2 Hypothesis = Type2 Hypothesis (Top Formula) -/
  theorem Coverage_R2H2H {U V : Vertex} {DLDS : Graph} :
    ( check_collapse_nodes (pre_collapse (get_rule U DLDS) )
                           (pre_collapse (get_rule V DLDS) ) ) →
    ( type2_hypothesis (get_rule U DLDS) ) →
    ( type2_hypothesis (get_rule V DLDS) ) →
    ---------------------------
    ( type3_collapse (collapse_nodes U V DLDS) ) := by
  intro prop_check_nodes prop_typeᵤ prop_typeᵥ;
  have Prop_Typeᵤ := T3_Of_T2.PreCol_Of_PreCollapse_Top prop_typeᵤ;
  have Prop_Typeᵥ := T3_Of_T2.PreCol_Of_PreCollapse_Top prop_typeᵥ;
  exact T3_Of_T3.NODES.Col_Of_Collapse_Pre_Pre ( prop_check_nodes ) ( Prop_Typeᵤ ) ( Prop_Typeᵥ );
  -----------------------------------------------------------------------------------------------------------------------------------------
end COVERAGE.R22.NODES

namespace COVERAGE.R10.NODES
  /- R1X0E: Type1 Collapsed Node = Type0 ⊇-Elimination -/
  theorem Coverage_R1X0E {U V : Vertex} {DLDS : Graph} :
    ( check_collapse_nodes (pre_collapse (get_rule U DLDS) )
                           (pre_collapse (get_rule V DLDS) ) ) →
    ( type1_collapse (get_rule U DLDS) ) →
    ( type0_elimination (get_rule V DLDS) ) →
    ---------------------------
    ( type1_collapse (collapse_nodes U V DLDS) ) := by
  intro prop_check_nodes prop_typeᵤ prop_typeᵥ;
  have Prop_Typeᵤ := T1_Of_T1.Col_Of_PreCollapse_Col prop_typeᵤ;
  have Prop_Typeᵥ := T1_Of_T0.PreCol_Of_PreCollapse_Elim prop_typeᵥ;
  exact T1_Of_T1.NODES.Col_Of_Collapse_Col_Pre ( prop_check_nodes ) ( Prop_Typeᵤ ) ( Prop_Typeᵥ );
  -----------------------------------------------------------------------------------------------------------------------------------------
  /- R1X0I: Type1 Collapsed Node = Type0 ⊇-Introduction -/
  theorem Coverage_R1X0I {U V : Vertex} {DLDS : Graph} :
    ( check_collapse_nodes (pre_collapse (get_rule U DLDS) )
                           (pre_collapse (get_rule V DLDS) ) ) →
    ( type1_collapse (get_rule U DLDS) ) →
    ( type0_introduction (get_rule V DLDS) ) →
    ---------------------------
    ( type1_collapse (collapse_nodes U V DLDS) ) := by
  intro prop_check_nodes prop_typeᵤ prop_typeᵥ;
  have Prop_Typeᵤ := T1_Of_T1.Col_Of_PreCollapse_Col prop_typeᵤ;
  have Prop_Typeᵥ := T1_Of_T0.PreCol_Of_PreCollapse_Intro prop_typeᵥ;
  exact T1_Of_T1.NODES.Col_Of_Collapse_Col_Pre ( prop_check_nodes ) ( Prop_Typeᵤ ) ( Prop_Typeᵥ );
  -----------------------------------------------------------------------------------------------------------------------------------------
  /- R1X0H: Type1 Collapsed Node = Type0 Hypothesis (Top Formula) -/
  theorem Coverage_R1X0H {U V : Vertex} {DLDS : Graph} :
    ( check_collapse_nodes (pre_collapse (get_rule U DLDS) )
                           (pre_collapse (get_rule V DLDS) ) ) →
    ( type1_collapse (get_rule U DLDS) ) →
    ( type0_hypothesis (get_rule V DLDS) ) →
    ---------------------------
    ( type1_collapse (collapse_nodes U V DLDS) ) := by
  intro prop_check_nodes prop_typeᵤ prop_typeᵥ;
  have Prop_Typeᵤ := T1_Of_T1.Col_Of_PreCollapse_Col prop_typeᵤ;
  have Prop_Typeᵥ := T1_Of_T0.PreCol_Of_PreCollapse_Top prop_typeᵥ;
  exact T1_Of_T1.NODES.Col_Of_Collapse_Col_Pre ( prop_check_nodes ) ( Prop_Typeᵤ ) ( Prop_Typeᵥ );
  -----------------------------------------------------------------------------------------------------------------------------------------
end COVERAGE.R10.NODES

namespace COVERAGE.R12.NODES
  /- R1X2E: Type1 Collapsed Node = Type2 ⊇-Elimination -/
  theorem Coverage_R1X2E {U V : Vertex} {DLDS : Graph} :
    ( check_collapse_nodes (pre_collapse (get_rule U DLDS) )
                           (pre_collapse (get_rule V DLDS) ) ) →
    ( type1_collapse (get_rule U DLDS) ) →
    ( type2_elimination (get_rule V DLDS) ) →
    ---------------------------
    ( type3_collapse (collapse_nodes U V DLDS) ) := by
  intro prop_check_nodes prop_typeᵤ prop_typeᵥ;
  have Prop_Typeᵤ := T1_Of_T1.Col_Of_PreCollapse_Col prop_typeᵤ;
  have Prop_Typeᵥ := T3_Of_T2.PreCol_Of_PreCollapse_Elim prop_typeᵥ;
  exact T3_Of_T3.NODES.Col_Of_Collapse_Col_Pre ( prop_check_nodes ) ( T3_Of_T1.Col_Of_Col Prop_Typeᵤ ) ( Prop_Typeᵥ );
  -----------------------------------------------------------------------------------------------------------------------------------------
  /- R1X2I: Type1 Collapsed Node = Type2 ⊇-Introduction -/
  theorem Coverage_R1X2I {U V : Vertex} {DLDS : Graph} :
    ( check_collapse_nodes (pre_collapse (get_rule U DLDS) )
                           (pre_collapse (get_rule V DLDS) ) ) →
    ( type1_collapse (get_rule U DLDS) ) →
    ( type2_introduction (get_rule V DLDS) ) →
    ---------------------------
    ( type3_collapse (collapse_nodes U V DLDS) ) := by
  intro prop_check_nodes prop_typeᵤ prop_typeᵥ;
  have Prop_Typeᵤ := T1_Of_T1.Col_Of_PreCollapse_Col prop_typeᵤ;
  have Prop_Typeᵥ := T3_Of_T2.PreCol_Of_PreCollapse_Intro prop_typeᵥ;
  exact T3_Of_T3.NODES.Col_Of_Collapse_Col_Pre ( prop_check_nodes ) ( T3_Of_T1.Col_Of_Col Prop_Typeᵤ ) ( Prop_Typeᵥ );
  -----------------------------------------------------------------------------------------------------------------------------------------
  /- R1X2H: Type1 Collapsed Node = Type2 Hypothesis (Top Formula) -/
  theorem Coverage_R1X2H {U V : Vertex} {DLDS : Graph} :
    ( check_collapse_nodes (pre_collapse (get_rule U DLDS) )
                           (pre_collapse (get_rule V DLDS) ) ) →
    ( type1_collapse (get_rule U DLDS) ) →
    ( type2_hypothesis (get_rule V DLDS) ) →
    ---------------------------
    ( type3_collapse (collapse_nodes U V DLDS) ) := by
  intro prop_check_nodes prop_typeᵤ prop_typeᵥ;
  have Prop_Typeᵤ := T1_Of_T1.Col_Of_PreCollapse_Col prop_typeᵤ;
  have Prop_Typeᵥ := T3_Of_T2.PreCol_Of_PreCollapse_Top prop_typeᵥ;
  exact T3_Of_T3.NODES.Col_Of_Collapse_Col_Pre ( prop_check_nodes ) ( T3_Of_T1.Col_Of_Col Prop_Typeᵤ ) ( Prop_Typeᵥ );
  -----------------------------------------------------------------------------------------------------------------------------------------
end COVERAGE.R12.NODES

namespace COVERAGE.R30.NODES
  /- R3X0E: Type3 Collapsed Node = Type0 ⊇-Elimination -/
  theorem Coverage_R3X0E {U V : Vertex} {DLDS : Graph} :
    ( check_collapse_nodes (pre_collapse (get_rule U DLDS) )
                           (pre_collapse (get_rule V DLDS) ) ) →
    ( type3_collapse (get_rule U DLDS) ) →
    ( type0_elimination (get_rule V DLDS) ) →
    ---------------------------
    ( type3_collapse (collapse_nodes U V DLDS) ) := by
  intro prop_check_nodes prop_typeᵤ prop_typeᵥ;
  have Prop_Typeᵤ := T3_Of_T3.Col_Of_PreCollapse_Col prop_typeᵤ;
  have Prop_Typeᵥ := T1_Of_T0.PreCol_Of_PreCollapse_Elim prop_typeᵥ;
  exact T3_Of_T3.NODES.Col_Of_Collapse_Col_Pre ( prop_check_nodes ) ( Prop_Typeᵤ ) ( T3_Of_T1.PreCol_Of_Pre Prop_Typeᵥ );
  -----------------------------------------------------------------------------------------------------------------------------------------
  /- R3X0I: Type3 Collapsed Node = Type0 ⊇-Introduction -/
  theorem Coverage_R3X0I {U V : Vertex} {DLDS : Graph} :
    ( check_collapse_nodes (pre_collapse (get_rule U DLDS) )
                           (pre_collapse (get_rule V DLDS) ) ) →
    ( type3_collapse (get_rule U DLDS) ) →
    ( type0_introduction (get_rule V DLDS) ) →
    ---------------------------
    ( type3_collapse (collapse_nodes U V DLDS) ) := by
  intro prop_check_nodes prop_typeᵤ prop_typeᵥ;
  have Prop_Typeᵤ := T3_Of_T3.Col_Of_PreCollapse_Col prop_typeᵤ;
  have Prop_Typeᵥ := T1_Of_T0.PreCol_Of_PreCollapse_Intro prop_typeᵥ;
  exact T3_Of_T3.NODES.Col_Of_Collapse_Col_Pre ( prop_check_nodes ) ( Prop_Typeᵤ ) ( T3_Of_T1.PreCol_Of_Pre Prop_Typeᵥ );
  -----------------------------------------------------------------------------------------------------------------------------------------
  /- R3X0H: Type3 Collapsed Node = Type0 Hypothesis (Top Formula) -/
  theorem Coverage_R3X0H {U V : Vertex} {DLDS : Graph} :
    ( check_collapse_nodes (pre_collapse (get_rule U DLDS) )
                           (pre_collapse (get_rule V DLDS) ) ) →
    ( type3_collapse (get_rule U DLDS) ) →
    ( type0_hypothesis (get_rule V DLDS) ) →
    ---------------------------
    ( type3_collapse (collapse_nodes U V DLDS) ) := by
  intro prop_check_nodes prop_typeᵤ prop_typeᵥ;
  have Prop_Typeᵤ := T3_Of_T3.Col_Of_PreCollapse_Col prop_typeᵤ;
  have Prop_Typeᵥ := T1_Of_T0.PreCol_Of_PreCollapse_Top prop_typeᵥ;
  exact T3_Of_T3.NODES.Col_Of_Collapse_Col_Pre ( prop_check_nodes ) ( Prop_Typeᵤ ) ( T3_Of_T1.PreCol_Of_Pre Prop_Typeᵥ );
  -----------------------------------------------------------------------------------------------------------------------------------------
end COVERAGE.R30.NODES

namespace COVERAGE.R32.NODES
  /- R3X2E: Type3 Collapsed Node = Type2 ⊇-Elimination -/
  theorem Coverage_R3X2E {U V : Vertex} {DLDS : Graph} :
    ( check_collapse_nodes (pre_collapse (get_rule U DLDS) )
                           (pre_collapse (get_rule V DLDS) ) ) →
    ( type3_collapse (get_rule U DLDS) ) →
    ( type2_elimination (get_rule V DLDS) ) →
    ---------------------------
    ( type3_collapse (collapse_nodes U V DLDS) ) := by
  intro prop_check_nodes prop_typeᵤ prop_typeᵥ;
  have Prop_Typeᵤ := T3_Of_T3.Col_Of_PreCollapse_Col prop_typeᵤ;
  have Prop_Typeᵥ := T3_Of_T2.PreCol_Of_PreCollapse_Elim prop_typeᵥ;
  exact T3_Of_T3.NODES.Col_Of_Collapse_Col_Pre ( prop_check_nodes ) ( Prop_Typeᵤ ) ( Prop_Typeᵥ );
  -----------------------------------------------------------------------------------------------------------------------------------------
  /- R3X2I: Type3 Collapsed Node = Type2 ⊇-Introduction -/
  theorem Coverage_R3X2I {U V : Vertex} {DLDS : Graph} :
    ( check_collapse_nodes (pre_collapse (get_rule U DLDS) )
                           (pre_collapse (get_rule V DLDS) ) ) →
    ( type3_collapse (get_rule U DLDS) ) →
    ( type2_introduction (get_rule V DLDS) ) →
    ---------------------------
    ( type3_collapse (collapse_nodes U V DLDS) ) := by
  intro prop_check_nodes prop_typeᵤ prop_typeᵥ;
  have Prop_Typeᵤ := T3_Of_T3.Col_Of_PreCollapse_Col prop_typeᵤ;
  have Prop_Typeᵥ := T3_Of_T2.PreCol_Of_PreCollapse_Intro prop_typeᵥ;
  exact T3_Of_T3.NODES.Col_Of_Collapse_Col_Pre ( prop_check_nodes ) ( Prop_Typeᵤ ) ( Prop_Typeᵥ );
  -----------------------------------------------------------------------------------------------------------------------------------------
  /- R3X2H: Type3 Collapsed Node = Type2 Hypothesis (Top Formula) -/
  theorem Coverage_R3X2H {U V : Vertex} {DLDS : Graph} :
    ( check_collapse_nodes (pre_collapse (get_rule U DLDS) )
                           (pre_collapse (get_rule V DLDS) ) ) →
    ( type3_collapse (get_rule U DLDS) ) →
    ( type2_hypothesis (get_rule V DLDS) ) →
    ---------------------------
    ( type3_collapse (collapse_nodes U V DLDS) ) := by
  intro prop_check_nodes prop_typeᵤ prop_typeᵥ;
  have Prop_Typeᵤ := T3_Of_T3.Col_Of_PreCollapse_Col prop_typeᵤ;
  have Prop_Typeᵥ := T3_Of_T2.PreCol_Of_PreCollapse_Top prop_typeᵥ;
  exact T3_Of_T3.NODES.Col_Of_Collapse_Col_Pre ( prop_check_nodes ) ( Prop_Typeᵤ ) ( Prop_Typeᵥ );
  -----------------------------------------------------------------------------------------------------------------------------------------
end COVERAGE.R32.NODES


namespace COVERAGE.R22.EDGES
  -----------------------------------------------------------------------------------------------------------------------------------------
  /- R2E2E: Type2 ⊇-Elimination = Type2 ⊇-Elimination -/
  theorem Coverage_R2E2E {U V : Vertex} {DLDS : Graph} :
    ( check_collapse_edges (pre_collapse (get_rule U DLDS) )
                           (pre_collapse (get_rule V DLDS) ) ) →
    ( type2_elimination (get_rule U DLDS) ) →
    ( type2_elimination (get_rule V DLDS) ) →
    ---------------------------
    ( type3_collapse (collapse_nodes U V DLDS) ) := by
  intro prop_check_edges prop_typeᵤ prop_typeᵥ;
  have Prop_Typeᵤ := T3_Of_T2.PreCol_Of_PreCollapse_Elim prop_typeᵤ;
  have Prop_Typeᵥ := T3_Of_T2.PreCol_Of_PreCollapse_Elim prop_typeᵥ;
  exact T3_Of_T3.EDGES.Col_Of_Collapse_Pre_Pre ( prop_check_edges ) ( Prop_Typeᵤ ) ( Prop_Typeᵥ );
  -----------------------------------------------------------------------------------------------------------------------------------------
  /- R2I2E: Type2 ⊇-Introduction = Type2 ⊇-Elimination -/
  theorem Coverage_R2I2E {U V : Vertex} {DLDS : Graph} :
    ( check_collapse_edges (pre_collapse (get_rule U DLDS) )
                           (pre_collapse (get_rule V DLDS) ) ) →
    ( type2_introduction (get_rule U DLDS) ) →
    ( type2_elimination (get_rule V DLDS) ) →
    ---------------------------
    ( type3_collapse (collapse_nodes U V DLDS) ) := by
  intro prop_check_edges prop_typeᵤ prop_typeᵥ;
  have Prop_Typeᵤ := T3_Of_T2.PreCol_Of_PreCollapse_Intro prop_typeᵤ;
  have Prop_Typeᵥ := T3_Of_T2.PreCol_Of_PreCollapse_Elim prop_typeᵥ;
  exact T3_Of_T3.EDGES.Col_Of_Collapse_Pre_Pre ( prop_check_edges ) ( Prop_Typeᵤ ) ( Prop_Typeᵥ );
  -----------------------------------------------------------------------------------------------------------------------------------------
  /- R2H2E: Type2 ⊇-Hypothesis = Type2 ⊇-Elimination -/
  theorem Coverage_R2H2E {U V : Vertex} {DLDS : Graph} :
    ( check_collapse_edges (pre_collapse (get_rule U DLDS) )
                           (pre_collapse (get_rule V DLDS) ) ) →
    ( type2_hypothesis (get_rule U DLDS) ) →
    ( type2_elimination (get_rule V DLDS) ) →
    ---------------------------
    ( type3_collapse (collapse_nodes U V DLDS) ) := by
  intro prop_check_edges prop_typeᵤ prop_typeᵥ;
  have Prop_Typeᵤ := T3_Of_T2.PreCol_Of_PreCollapse_Top prop_typeᵤ;
  have Prop_Typeᵥ := T3_Of_T2.PreCol_Of_PreCollapse_Elim prop_typeᵥ;
  exact T3_Of_T3.EDGES.Col_Of_Collapse_Pre_Pre ( prop_check_edges ) ( Prop_Typeᵤ ) ( Prop_Typeᵥ );
  -----------------------------------------------------------------------------------------------------------------------------------------
  /- R2E2I: Type2 ⊇-Elimination = Type2 ⊇-Introduction -/
  theorem Coverage_R2E2I {U V : Vertex} {DLDS : Graph} :
    ( check_collapse_edges (pre_collapse (get_rule U DLDS) )
                           (pre_collapse (get_rule V DLDS) ) ) →
    ( type2_elimination (get_rule U DLDS) ) →
    ( type2_introduction (get_rule V DLDS) ) →
    ---------------------------
    ( type3_collapse (collapse_nodes U V DLDS) ) := by
  intro prop_check_edges prop_typeᵤ prop_typeᵥ;
  have Prop_Typeᵤ := T3_Of_T2.PreCol_Of_PreCollapse_Elim prop_typeᵤ;
  have Prop_Typeᵥ := T3_Of_T2.PreCol_Of_PreCollapse_Intro prop_typeᵥ;
  exact T3_Of_T3.EDGES.Col_Of_Collapse_Pre_Pre ( prop_check_edges ) ( Prop_Typeᵤ ) ( Prop_Typeᵥ );
  -----------------------------------------------------------------------------------------------------------------------------------------
  /- R2I2I: Type2 ⊇-Introduction = Type2 ⊇-Introduction -/
  theorem Coverage_R2I2I {U V : Vertex} {DLDS : Graph} :
    ( check_collapse_edges (pre_collapse (get_rule U DLDS) )
                           (pre_collapse (get_rule V DLDS) ) ) →
    ( type2_introduction (get_rule U DLDS) ) →
    ( type2_introduction (get_rule V DLDS) ) →
    ---------------------------
    ( type3_collapse (collapse_nodes U V DLDS) ) := by
  intro prop_check_edges prop_typeᵤ prop_typeᵥ;
  have Prop_Typeᵤ := T3_Of_T2.PreCol_Of_PreCollapse_Intro prop_typeᵤ;
  have Prop_Typeᵥ := T3_Of_T2.PreCol_Of_PreCollapse_Intro prop_typeᵥ;
  exact T3_Of_T3.EDGES.Col_Of_Collapse_Pre_Pre ( prop_check_edges ) ( Prop_Typeᵤ ) ( Prop_Typeᵥ );
  -----------------------------------------------------------------------------------------------------------------------------------------
  /- R2H2I: Type2 ⊇-Hypothesis = Type2 Introduction -/
  theorem Coverage_R2H2I {U V : Vertex} {DLDS : Graph} :
    ( check_collapse_edges (pre_collapse (get_rule U DLDS) )
                           (pre_collapse (get_rule V DLDS) ) ) →
    ( type2_hypothesis (get_rule U DLDS) ) →
    ( type2_introduction (get_rule V DLDS) ) →
    ---------------------------
    ( type3_collapse (collapse_nodes U V DLDS) ) := by
  intro prop_check_edges prop_typeᵤ prop_typeᵥ;
  have Prop_Typeᵤ := T3_Of_T2.PreCol_Of_PreCollapse_Top prop_typeᵤ;
  have Prop_Typeᵥ := T3_Of_T2.PreCol_Of_PreCollapse_Intro prop_typeᵥ;
  exact T3_Of_T3.EDGES.Col_Of_Collapse_Pre_Pre ( prop_check_edges ) ( Prop_Typeᵤ ) ( Prop_Typeᵥ );
  -----------------------------------------------------------------------------------------------------------------------------------------
  /- R2E2H: Type2 ⊇-Elimination = Type2 ⊇-Hypothesis (Top Formula) -/
  theorem Coverage_R2E2H {U V : Vertex} {DLDS : Graph} :
    ( check_collapse_edges (pre_collapse (get_rule U DLDS) )
                           (pre_collapse (get_rule V DLDS) ) ) →
    ( type2_elimination (get_rule U DLDS) ) →
    ( type2_hypothesis (get_rule V DLDS) ) →
    ---------------------------
    ( type3_collapse (collapse_nodes U V DLDS) ) := by
  intro prop_check_edges prop_typeᵤ prop_typeᵥ;
  have Prop_Typeᵤ := T3_Of_T2.PreCol_Of_PreCollapse_Elim prop_typeᵤ;
  have Prop_Typeᵥ := T3_Of_T2.PreCol_Of_PreCollapse_Top prop_typeᵥ;
  exact T3_Of_T3.EDGES.Col_Of_Collapse_Pre_Pre ( prop_check_edges ) ( Prop_Typeᵤ ) ( Prop_Typeᵥ );
  -----------------------------------------------------------------------------------------------------------------------------------------
  /- R2I2H: Type2 ⊇-Introduction = Type2 ⊇-Hypothesis (Top Formula) -/
  theorem Coverage_R2I2H {U V : Vertex} {DLDS : Graph} :
    ( check_collapse_edges (pre_collapse (get_rule U DLDS) )
                           (pre_collapse (get_rule V DLDS) ) ) →
    ( type2_introduction (get_rule U DLDS) ) →
    ( type2_hypothesis (get_rule V DLDS) ) →
    ---------------------------
    ( type3_collapse (collapse_nodes U V DLDS) ) := by
  intro prop_check_edges prop_typeᵤ prop_typeᵥ;
  have Prop_Typeᵤ := T3_Of_T2.PreCol_Of_PreCollapse_Intro prop_typeᵤ;
  have Prop_Typeᵥ := T3_Of_T2.PreCol_Of_PreCollapse_Top prop_typeᵥ;
  exact T3_Of_T3.EDGES.Col_Of_Collapse_Pre_Pre ( prop_check_edges ) ( Prop_Typeᵤ ) ( Prop_Typeᵥ );
  -----------------------------------------------------------------------------------------------------------------------------------------
  /- R2H2H: Type2 Hypothesis = Type2 Hypothesis (Top Formula) -/
  theorem Coverage_R2H2H {U V : Vertex} {DLDS : Graph} :
    ( check_collapse_edges (pre_collapse (get_rule U DLDS) )
                           (pre_collapse (get_rule V DLDS) ) ) →
    ( type2_hypothesis (get_rule U DLDS) ) →
    ( type2_hypothesis (get_rule V DLDS) ) →
    ---------------------------
    ( type3_collapse (collapse_nodes U V DLDS) ) := by
  intro prop_check_edges prop_typeᵤ prop_typeᵥ;
  have Prop_Typeᵤ := T3_Of_T2.PreCol_Of_PreCollapse_Top prop_typeᵤ;
  have Prop_Typeᵥ := T3_Of_T2.PreCol_Of_PreCollapse_Top prop_typeᵥ;
  exact T3_Of_T3.EDGES.Col_Of_Collapse_Pre_Pre ( prop_check_edges ) ( Prop_Typeᵤ ) ( Prop_Typeᵥ );
  -----------------------------------------------------------------------------------------------------------------------------------------
end COVERAGE.R22.EDGES

namespace COVERAGE.R32.EDGES
  /- R3X2E: Type3 Collapsed Node = Type2 ⊇-Elimination -/
  theorem Coverage_R3X2E {U V : Vertex} {DLDS : Graph} :
    ( check_collapse_edges (pre_collapse (get_rule U DLDS) )
                           (pre_collapse (get_rule V DLDS) ) ) →
    ( type3_collapse (get_rule U DLDS) ) →
    ( type2_elimination (get_rule V DLDS) ) →
    ---------------------------
    ( type3_collapse (collapse_nodes U V DLDS) ) := by
  intro prop_check_edges prop_typeᵤ prop_typeᵥ;
  have Prop_Typeᵤ := T3_Of_T3.Col_Of_PreCollapse_Col prop_typeᵤ;
  have Prop_Typeᵥ := T3_Of_T2.PreCol_Of_PreCollapse_Elim prop_typeᵥ;
  exact T3_Of_T3.EDGES.Col_Of_Collapse_Col_Pre ( prop_check_edges ) ( Prop_Typeᵤ ) ( Prop_Typeᵥ );
  -----------------------------------------------------------------------------------------------------------------------------------------
  /- R3X2I: Type3 Collapsed Node = Type2 ⊇-Introduction -/
  theorem Coverage_R3X2I {U V : Vertex} {DLDS : Graph} :
    ( check_collapse_edges (pre_collapse (get_rule U DLDS) )
                           (pre_collapse (get_rule V DLDS) ) ) →
    ( type3_collapse (get_rule U DLDS) ) →
    ( type2_introduction (get_rule V DLDS) ) →
    ---------------------------
    ( type3_collapse (collapse_nodes U V DLDS) ) := by
  intro prop_check_edges prop_typeᵤ prop_typeᵥ;
  have Prop_Typeᵤ := T3_Of_T3.Col_Of_PreCollapse_Col prop_typeᵤ;
  have Prop_Typeᵥ := T3_Of_T2.PreCol_Of_PreCollapse_Intro prop_typeᵥ;
  exact T3_Of_T3.EDGES.Col_Of_Collapse_Col_Pre ( prop_check_edges ) ( Prop_Typeᵤ ) ( Prop_Typeᵥ );
  -----------------------------------------------------------------------------------------------------------------------------------------
  /- R3X2H: Type3 Collapsed Node = Type2 Hypothesis (Top Formula) -/
  theorem Coverage_R3X2H {U V : Vertex} {DLDS : Graph} :
    ( check_collapse_edges (pre_collapse (get_rule U DLDS) )
                           (pre_collapse (get_rule V DLDS) ) ) →
    ( type3_collapse (get_rule U DLDS) ) →
    ( type2_hypothesis (get_rule V DLDS) ) →
    ---------------------------
    ( type3_collapse (collapse_nodes U V DLDS) ) := by
  intro prop_check_edges prop_typeᵤ prop_typeᵥ;
  have Prop_Typeᵤ := T3_Of_T3.Col_Of_PreCollapse_Col prop_typeᵤ;
  have Prop_Typeᵥ := T3_Of_T2.PreCol_Of_PreCollapse_Top prop_typeᵥ;
  exact T3_Of_T3.EDGES.Col_Of_Collapse_Col_Pre ( prop_check_edges ) ( Prop_Typeᵤ ) ( Prop_Typeᵥ );
  -----------------------------------------------------------------------------------------------------------------------------------------
end COVERAGE.R32.EDGES


/- Theorem: Coverage Theorem (Collapse Nodes) -/
namespace COVERAGE.MAIN.NODES
  --333 set_option trace.Meta.Tactic.simp true
  /- Coverage Theorem: Type1 of Type0 & Type0 -/
  theorem T1CoverageT0T0 {U V : Vertex} {DLDS : Graph} :
    ( check_collapse_nodes (pre_collapse (get_rule U DLDS) )
                           (pre_collapse (get_rule V DLDS) ) ) →
    /- Left-Side Node (U) -/
    ( ( type0_elimination (get_rule U DLDS) )
    ∨ ( type0_introduction (get_rule U DLDS) )
    ∨ ( type0_hypothesis (get_rule U DLDS) ) ) →
    /- Right-Side Node (V) -/
    ( ( type0_elimination (get_rule V DLDS) )
    ∨ ( type0_introduction (get_rule V DLDS) )
    ∨ ( type0_hypothesis (get_rule V DLDS) ) ) →
    ---------------------------
    ( type1_collapse (collapse_nodes U V DLDS) ) := by
  intro prop_check_nodes prop_typeᵤ prop_typeᵥ;
  cases prop_typeᵤ with | inl prop_type0Eᵤ => cases prop_typeᵥ with | inl prop_type0Eᵥ => exact R00.NODES.Coverage_R0E0E prop_check_nodes prop_type0Eᵤ prop_type0Eᵥ;
                                                                    | inr prop_typeᵥ =>
                                              cases prop_typeᵥ with | inl prop_type0Iᵥ => exact R00.NODES.Coverage_R0E0I prop_check_nodes prop_type0Eᵤ prop_type0Iᵥ;
                                                                    | inr prop_type0Hᵥ => exact R00.NODES.Coverage_R0E0H prop_check_nodes prop_type0Eᵤ prop_type0Hᵥ;
                        | inr prop_typeᵤ =>
  cases prop_typeᵤ with | inl prop_type0Iᵤ => cases prop_typeᵥ with | inl prop_type0Eᵥ => exact R00.NODES.Coverage_R0I0E prop_check_nodes prop_type0Iᵤ prop_type0Eᵥ;
                                                                    | inr prop_typeᵥ =>
                                              cases prop_typeᵥ with | inl prop_type0Iᵥ => exact R00.NODES.Coverage_R0I0I prop_check_nodes prop_type0Iᵤ prop_type0Iᵥ;
                                                                    | inr prop_type0Hᵥ => exact R00.NODES.Coverage_R0I0H prop_check_nodes prop_type0Iᵤ prop_type0Hᵥ;
                        | inr prop_type0Hᵤ => cases prop_typeᵥ with | inl prop_type0Eᵥ => exact R00.NODES.Coverage_R0H0E prop_check_nodes prop_type0Hᵤ prop_type0Eᵥ;
                                                                    | inr prop_typeᵥ =>
                                              cases prop_typeᵥ with | inl prop_type0Iᵥ => exact R00.NODES.Coverage_R0H0I prop_check_nodes prop_type0Hᵤ prop_type0Iᵥ;
                                                                    | inr prop_type0Hᵥ => exact R00.NODES.Coverage_R0H0H prop_check_nodes prop_type0Hᵤ prop_type0Hᵥ;
  -----------------------------------------------------------------------------------------------------------------------------------------

  /- Coverage Theorem: Type1 of Type1 & Type0 -/
  theorem T1CoverageT1T0 {U V : Vertex} {DLDS : Graph} :
    ( check_collapse_nodes (pre_collapse (get_rule U DLDS) )
                           (pre_collapse (get_rule V DLDS) ) ) →
    /- Left-Side Node (U) -/
    ( ( type1_collapse (get_rule U DLDS) ) ) →
    /- Right-Side Node (V) -/
    ( ( type0_elimination (get_rule V DLDS) )
    ∨ ( type0_introduction (get_rule V DLDS) )
    ∨ ( type0_hypothesis (get_rule V DLDS) ) ) →
    ---------------------------
    ( type1_collapse (collapse_nodes U V DLDS) ) := by
  intro prop_check_nodes prop_type1Xᵤ prop_typeᵥ;
  cases prop_typeᵥ with | inl prop_type0Eᵥ => exact R10.NODES.Coverage_R1X0E prop_check_nodes prop_type1Xᵤ prop_type0Eᵥ;
                        | inr prop_typeᵥ =>
  cases prop_typeᵥ with | inl prop_type0Iᵥ => exact R10.NODES.Coverage_R1X0I prop_check_nodes prop_type1Xᵤ prop_type0Iᵥ;
                        | inr prop_type0Hᵥ => exact R10.NODES.Coverage_R1X0H prop_check_nodes prop_type1Xᵤ prop_type0Hᵥ;
  -----------------------------------------------------------------------------------------------------------------------------------------

  /- Coverage Theorem: Type3 of Type0 & Type2 -/
  theorem T3CoverageT0T2 {U V : Vertex} {DLDS : Graph} :
    ( check_collapse_nodes (pre_collapse (get_rule U DLDS) )
                           (pre_collapse (get_rule V DLDS) ) ) →
    /- Left-Side Node (U) -/
    ( ( type0_elimination (get_rule U DLDS) )
    ∨ ( type0_introduction (get_rule U DLDS) )
    ∨ ( type0_hypothesis (get_rule U DLDS) ) ) →
    /- Right-Side Node (V) -/
    ( ( type2_elimination (get_rule V DLDS) )
    ∨ ( type2_introduction (get_rule V DLDS) )
    ∨ ( type2_hypothesis (get_rule V DLDS) ) ) →
    ---------------------------
    ( type3_collapse (collapse_nodes U V DLDS) ) := by
  intro prop_check_nodes prop_typeᵤ prop_typeᵥ;
  cases prop_typeᵤ with | inl prop_type0Eᵤ => cases prop_typeᵥ with | inl prop_type2Eᵥ => exact R02.NODES.Coverage_R0E2E prop_check_nodes prop_type0Eᵤ prop_type2Eᵥ;
                                                                    | inr prop_typeᵥ =>
                                              cases prop_typeᵥ with | inl prop_type2Iᵥ => exact R02.NODES.Coverage_R0E2I prop_check_nodes prop_type0Eᵤ prop_type2Iᵥ;
                                                                    | inr prop_type2Hᵥ => exact R02.NODES.Coverage_R0E2H prop_check_nodes prop_type0Eᵤ prop_type2Hᵥ;
                        | inr prop_typeᵤ =>
  cases prop_typeᵤ with | inl prop_type0Iᵤ => cases prop_typeᵥ with | inl prop_type2Eᵥ => exact R02.NODES.Coverage_R0I2E prop_check_nodes prop_type0Iᵤ prop_type2Eᵥ;
                                                                    | inr prop_typeᵥ =>
                                              cases prop_typeᵥ with | inl prop_type2Iᵥ => exact R02.NODES.Coverage_R0I2I prop_check_nodes prop_type0Iᵤ prop_type2Iᵥ;
                                                                    | inr prop_type2Hᵥ => exact R02.NODES.Coverage_R0I2H prop_check_nodes prop_type0Iᵤ prop_type2Hᵥ;
                        | inr prop_type0Hᵤ => cases prop_typeᵥ with | inl prop_type2Eᵥ => exact R02.NODES.Coverage_R0H2E prop_check_nodes prop_type0Hᵤ prop_type2Eᵥ;
                                                                    | inr prop_typeᵥ =>
                                              cases prop_typeᵥ with | inl prop_type2Iᵥ => exact R02.NODES.Coverage_R0H2I prop_check_nodes prop_type0Hᵤ prop_type2Iᵥ;
                                                                    | inr prop_type2Hᵥ => exact R02.NODES.Coverage_R0H2H prop_check_nodes prop_type0Hᵤ prop_type2Hᵥ;
  -----------------------------------------------------------------------------------------------------------------------------------------
  /- Coverage Theorem: Type3 of Type2 & Type0 -/
  theorem T3CoverageT2T0 {U V : Vertex} {DLDS : Graph} :
    ( check_collapse_nodes (pre_collapse (get_rule U DLDS) )
                           (pre_collapse (get_rule V DLDS) ) ) →
    /- Left-Side Node (U) -/
    ( ( type2_elimination (get_rule U DLDS) )
    ∨ ( type2_introduction (get_rule U DLDS) )
    ∨ ( type2_hypothesis (get_rule U DLDS) ) ) →
    /- Right-Side Node (V) -/
    ( ( type0_elimination (get_rule V DLDS) )
    ∨ ( type0_introduction (get_rule V DLDS) )
    ∨ ( type0_hypothesis (get_rule V DLDS) ) ) →
    ---------------------------
    ( type3_collapse (collapse_nodes U V DLDS) ) := by
  intro prop_check_nodes prop_typeᵤ prop_typeᵥ;
  cases prop_typeᵤ with | inl prop_type2Eᵤ => cases prop_typeᵥ with | inl prop_type0Eᵥ => exact R20.NODES.Coverage_R2E0E prop_check_nodes prop_type2Eᵤ prop_type0Eᵥ;
                                                                    | inr prop_typeᵥ =>
                                              cases prop_typeᵥ with | inl prop_type0Iᵥ => exact R20.NODES.Coverage_R2E0I prop_check_nodes prop_type2Eᵤ prop_type0Iᵥ;
                                                                    | inr prop_type0Hᵥ => exact R20.NODES.Coverage_R2E0H prop_check_nodes prop_type2Eᵤ prop_type0Hᵥ;
                        | inr prop_typeᵤ =>
  cases prop_typeᵤ with | inl prop_type2Iᵤ => cases prop_typeᵥ with | inl prop_type0Eᵥ => exact R20.NODES.Coverage_R2I0E prop_check_nodes prop_type2Iᵤ prop_type0Eᵥ;
                                                                    | inr prop_typeᵥ =>
                                              cases prop_typeᵥ with | inl prop_type0Iᵥ => exact R20.NODES.Coverage_R2I0I prop_check_nodes prop_type2Iᵤ prop_type0Iᵥ;
                                                                    | inr prop_type0Hᵥ => exact R20.NODES.Coverage_R2I0H prop_check_nodes prop_type2Iᵤ prop_type0Hᵥ;
                        | inr prop_type2Hᵤ => cases prop_typeᵥ with | inl prop_type0Eᵥ => exact R20.NODES.Coverage_R2H0E prop_check_nodes prop_type2Hᵤ prop_type0Eᵥ;
                                                                    | inr prop_typeᵥ =>
                                              cases prop_typeᵥ with | inl prop_type0Iᵥ => exact R20.NODES.Coverage_R2H0I prop_check_nodes prop_type2Hᵤ prop_type0Iᵥ;
                                                                    | inr prop_type0Hᵥ => exact R20.NODES.Coverage_R2H0H prop_check_nodes prop_type2Hᵤ prop_type0Hᵥ;
  -----------------------------------------------------------------------------------------------------------------------------------------
  /- Coverage Theorem: Type3 of Type2 & Type2 -/
  theorem T3CoverageT2T2 {U V : Vertex} {DLDS : Graph} :
    ( check_collapse_nodes (pre_collapse (get_rule U DLDS) )
                           (pre_collapse (get_rule V DLDS) ) ) →
    /- Left-Side Node (U) -/
    ( ( type2_elimination (get_rule U DLDS) )
    ∨ ( type2_introduction (get_rule U DLDS) )
    ∨ ( type2_hypothesis (get_rule U DLDS) ) ) →
    /- Right-Side Node (V) -/
    ( ( type2_elimination (get_rule V DLDS) )
    ∨ ( type2_introduction (get_rule V DLDS) )
    ∨ ( type2_hypothesis (get_rule V DLDS) ) ) →
    ---------------------------
    ( type3_collapse (collapse_nodes U V DLDS) ) := by
  intro prop_check_nodes prop_typeᵤ prop_typeᵥ;
  cases prop_typeᵤ with | inl prop_type2Eᵤ => cases prop_typeᵥ with | inl prop_type2Eᵥ => exact R22.NODES.Coverage_R2E2E prop_check_nodes prop_type2Eᵤ prop_type2Eᵥ;
                                                                    | inr prop_typeᵥ =>
                                              cases prop_typeᵥ with | inl prop_type2Iᵥ => exact R22.NODES.Coverage_R2E2I prop_check_nodes prop_type2Eᵤ prop_type2Iᵥ;
                                                                    | inr prop_type2Hᵥ => exact R22.NODES.Coverage_R2E2H prop_check_nodes prop_type2Eᵤ prop_type2Hᵥ;
                        | inr prop_typeᵤ =>
  cases prop_typeᵤ with | inl prop_type2Iᵤ => cases prop_typeᵥ with | inl prop_type2Eᵥ => exact R22.NODES.Coverage_R2I2E prop_check_nodes prop_type2Iᵤ prop_type2Eᵥ;
                                                                    | inr prop_typeᵥ =>
                                              cases prop_typeᵥ with | inl prop_type2Iᵥ => exact R22.NODES.Coverage_R2I2I prop_check_nodes prop_type2Iᵤ prop_type2Iᵥ;
                                                                    | inr prop_type2Hᵥ => exact R22.NODES.Coverage_R2I2H prop_check_nodes prop_type2Iᵤ prop_type2Hᵥ;
                        | inr prop_type2Hᵤ => cases prop_typeᵥ with | inl prop_type2Eᵥ => exact R22.NODES.Coverage_R2H2E prop_check_nodes prop_type2Hᵤ prop_type2Eᵥ;
                                                                    | inr prop_typeᵥ =>
                                              cases prop_typeᵥ with | inl prop_type2Iᵥ => exact R22.NODES.Coverage_R2H2I prop_check_nodes prop_type2Hᵤ prop_type2Iᵥ;
                                                                    | inr prop_type2Hᵥ => exact R22.NODES.Coverage_R2H2H prop_check_nodes prop_type2Hᵤ prop_type2Hᵥ;
  -----------------------------------------------------------------------------------------------------------------------------------------

  /- Coverage Theorem: Type3 of Type1 & Type2 -/
  theorem T3CoverageT1T2 {U V : Vertex} {DLDS : Graph} :
    ( check_collapse_nodes (pre_collapse (get_rule U DLDS) )
                           (pre_collapse (get_rule V DLDS) ) ) →
    /- Left-Side Node (U) -/
    ( ( type1_collapse (get_rule U DLDS) ) ) →
    /- Right-Side Node (V) -/
    ( ( type2_elimination (get_rule V DLDS) )
    ∨ ( type2_introduction (get_rule V DLDS) )
    ∨ ( type2_hypothesis (get_rule V DLDS) ) ) →
    ---------------------------
    ( type3_collapse (collapse_nodes U V DLDS) ) := by
  intro prop_check_nodes prop_type1Xᵤ prop_typeᵥ;
  cases prop_typeᵥ with | inl prop_type2Eᵥ => exact R12.NODES.Coverage_R1X2E prop_check_nodes prop_type1Xᵤ prop_type2Eᵥ;
                        | inr prop_typeᵥ =>
  cases prop_typeᵥ with | inl prop_type2Iᵥ => exact R12.NODES.Coverage_R1X2I prop_check_nodes prop_type1Xᵤ prop_type2Iᵥ;
                        | inr prop_type2Hᵥ => exact R12.NODES.Coverage_R1X2H prop_check_nodes prop_type1Xᵤ prop_type2Hᵥ;
  -----------------------------------------------------------------------------------------------------------------------------------------
  /- Coverage Theorem: Type3 of Type3 & Type0 -/
  theorem T3CoverageT3T0 {U V : Vertex} {DLDS : Graph} :
    ( check_collapse_nodes (pre_collapse (get_rule U DLDS) )
                           (pre_collapse (get_rule V DLDS) ) ) →
    /- Left-Side Node (U) -/
    ( ( type3_collapse (get_rule U DLDS) ) ) →
    /- Right-Side Node (V) -/
    ( ( type0_elimination (get_rule V DLDS) )
    ∨ ( type0_introduction (get_rule V DLDS) )
    ∨ ( type0_hypothesis (get_rule V DLDS) ) ) →
    ---------------------------
    ( type3_collapse (collapse_nodes U V DLDS) ) := by
  intro prop_check_nodes prop_type3Xᵤ prop_typeᵥ;
  cases prop_typeᵥ with | inl prop_type0Eᵥ => exact R30.NODES.Coverage_R3X0E prop_check_nodes prop_type3Xᵤ prop_type0Eᵥ;
                        | inr prop_typeᵥ =>
  cases prop_typeᵥ with | inl prop_type0Iᵥ => exact R30.NODES.Coverage_R3X0I prop_check_nodes prop_type3Xᵤ prop_type0Iᵥ;
                        | inr prop_type0Hᵥ => exact R30.NODES.Coverage_R3X0H prop_check_nodes prop_type3Xᵤ prop_type0Hᵥ;
  -----------------------------------------------------------------------------------------------------------------------------------------
  /- Coverage Theorem: Type3 of Type3 & Type2 -/
  theorem T3CoverageT3T2 {U V : Vertex} {DLDS : Graph} :
    ( check_collapse_nodes (pre_collapse (get_rule U DLDS) )
                           (pre_collapse (get_rule V DLDS) ) ) →
    /- Left-Side Node (U) -/
    ( ( type3_collapse (get_rule U DLDS) ) ) →
    /- Right-Side Node (V) -/
    ( ( type2_elimination (get_rule V DLDS) )
    ∨ ( type2_introduction (get_rule V DLDS) )
    ∨ ( type2_hypothesis (get_rule V DLDS) ) ) →
    ---------------------------
    ( type3_collapse (collapse_nodes U V DLDS) ) := by
  intro prop_check_nodes prop_type3Xᵤ prop_typeᵥ;
  cases prop_typeᵥ with | inl prop_type2Eᵥ => exact R32.NODES.Coverage_R3X2E prop_check_nodes prop_type3Xᵤ prop_type2Eᵥ;
                        | inr prop_typeᵥ =>
  cases prop_typeᵥ with | inl prop_type2Iᵥ => exact R32.NODES.Coverage_R3X2I prop_check_nodes prop_type3Xᵤ prop_type2Iᵥ;
                        | inr prop_type2Hᵥ => exact R32.NODES.Coverage_R3X2H prop_check_nodes prop_type3Xᵤ prop_type2Hᵥ;
  -----------------------------------------------------------------------------------------------------------------------------------------
end COVERAGE.MAIN.NODES


/- Theorem: Coverage Theorem (Collapse Nodes & Edges) -/
namespace COVERAGE.MAIN.EDGES
  --333 set_option trace.Meta.Tactic.simp true
  /- Coverage Theorem: Type3 of Type2 & Type2 -/
  theorem T3CoverageT2T2 {U V : Vertex} {DLDS : Graph} :
    ( check_collapse_edges (pre_collapse (get_rule U DLDS) )
                           (pre_collapse (get_rule V DLDS) ) ) →
    /- Left-Side Node (U) -/
    ( ( type2_elimination (get_rule U DLDS) )
    ∨ ( type2_introduction (get_rule U DLDS) )
    ∨ ( type2_hypothesis (get_rule U DLDS) ) ) →
    /- Right-Side Node (V) -/
    ( ( type2_elimination (get_rule V DLDS) )
    ∨ ( type2_introduction (get_rule V DLDS) )
    ∨ ( type2_hypothesis (get_rule V DLDS) ) ) →
    ---------------------------
    ( type3_collapse (collapse_nodes U V DLDS) ) := by
  intro prop_check_edges prop_typeᵤ prop_typeᵥ;
  cases prop_typeᵤ with | inl prop_type2Eᵤ => cases prop_typeᵥ with | inl prop_type2Eᵥ => exact R22.EDGES.Coverage_R2E2E prop_check_edges prop_type2Eᵤ prop_type2Eᵥ;
                                                                    | inr prop_typeᵥ =>
                                              cases prop_typeᵥ with | inl prop_type2Iᵥ => exact R22.EDGES.Coverage_R2E2I prop_check_edges prop_type2Eᵤ prop_type2Iᵥ;
                                                                    | inr prop_type2Hᵥ => exact R22.EDGES.Coverage_R2E2H prop_check_edges prop_type2Eᵤ prop_type2Hᵥ;
                        | inr prop_typeᵤ =>
  cases prop_typeᵤ with | inl prop_type2Iᵤ => cases prop_typeᵥ with | inl prop_type2Eᵥ => exact R22.EDGES.Coverage_R2I2E prop_check_edges prop_type2Iᵤ prop_type2Eᵥ;
                                                                    | inr prop_typeᵥ =>
                                              cases prop_typeᵥ with | inl prop_type2Iᵥ => exact R22.EDGES.Coverage_R2I2I prop_check_edges prop_type2Iᵤ prop_type2Iᵥ;
                                                                    | inr prop_type2Hᵥ => exact R22.EDGES.Coverage_R2I2H prop_check_edges prop_type2Iᵤ prop_type2Hᵥ;
                        | inr prop_type2Hᵤ => cases prop_typeᵥ with | inl prop_type2Eᵥ => exact R22.EDGES.Coverage_R2H2E prop_check_edges prop_type2Hᵤ prop_type2Eᵥ;
                                                                    | inr prop_typeᵥ =>
                                              cases prop_typeᵥ with | inl prop_type2Iᵥ => exact R22.EDGES.Coverage_R2H2I prop_check_edges prop_type2Hᵤ prop_type2Iᵥ;
                                                                    | inr prop_type2Hᵥ => exact R22.EDGES.Coverage_R2H2H prop_check_edges prop_type2Hᵤ prop_type2Hᵥ;
  -----------------------------------------------------------------------------------------------------------------------------------------

  /- Coverage Theorem: Type3 of Type3 & Type2 -/
  theorem T3CoverageT3T2 {U V : Vertex} {DLDS : Graph} :
    ( check_collapse_edges (pre_collapse (get_rule U DLDS) )
                           (pre_collapse (get_rule V DLDS) ) ) →
    /- Left-Side Node (U) -/
    ( ( type3_collapse (get_rule U DLDS) ) ) →
    /- Right-Side Node (V) -/
    ( ( type2_elimination (get_rule V DLDS) )
    ∨ ( type2_introduction (get_rule V DLDS) )
    ∨ ( type2_hypothesis (get_rule V DLDS) ) ) →
    ---------------------------
    ( type3_collapse (collapse_nodes U V DLDS) ) := by
  intro prop_check_edges prop_type3Xᵤ prop_typeᵥ;
  cases prop_typeᵥ with | inl prop_type2Eᵥ => exact R32.EDGES.Coverage_R3X2E prop_check_edges prop_type3Xᵤ prop_type2Eᵥ;
                        | inr prop_typeᵥ =>
  cases prop_typeᵥ with | inl prop_type2Iᵥ => exact R32.EDGES.Coverage_R3X2I prop_check_edges prop_type3Xᵤ prop_type2Iᵥ;
                        | inr prop_type2Hᵥ => exact R32.EDGES.Coverage_R3X2H prop_check_edges prop_type3Xᵤ prop_type2Hᵥ;
  -----------------------------------------------------------------------------------------------------------------------------------------
end COVERAGE.MAIN.EDGES

/- End -/
namespace COVERAGE.UP.T0H
  /- Lemma: Collapse stops at the Top Formulas -/
  theorem Not_Above_T0H {NODE : Vertex} {DLDS : Graph} :
    ( type0_hypothesis (get_rule NODE DLDS) ) →
    ---------------------------
    ( get_rule.incoming NODE DLDS = [] ) := by
  intro prop_type;
  simp only [get_rule] at prop_type;
  simp only [type0_hypothesis] at prop_type;
  cases prop_type with | intro _ prop_type =>
  cases prop_type with | intro _ prop_type =>
  cases prop_type with | intro _ prop_type =>
  cases prop_type with | intro _ prop_type =>
  cases prop_type with | intro _ prop_type =>
  cases prop_type with | intro _ prop_type =>
  cases prop_type with | intro _ prop_type =>
  cases prop_type with | intro _ prop_type =>
  cases prop_type with | intro prop_incoming _ =>
  exact prop_incoming;
end COVERAGE.UP.T0H

namespace COVERAGE.UP.T0E
  /- Lemma: Restrictions on Upper Nodes -/
  theorem Not_Above_T0E {U0 U1 : Vertex} {DLDS : Graph} :
    ( type0_elimination (get_rule U0 DLDS) ) →
    ( ∃(edge : Deduction), ( edge ∈ get_rule.outgoing U1 DLDS )
                         ∧ ( edge ∈ get_rule.incoming U0 DLDS ) ) →
    ------------------------------------------------------
    ( ¬type2_elimination (get_rule U1 DLDS) )
  ∧ ( ¬type2_introduction (get_rule U1 DLDS) )
  ∧ ( ¬type2_hypothesis (get_rule U1 DLDS) ) := by
  intro prop_typeᵤ₀;
  simp only [get_rule] at prop_typeᵤ₀;
  simp only [type0_elimination] at prop_typeᵤ₀;
  cases prop_typeᵤ₀ with | intro prop_nbrᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_lvlᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_hptᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_colᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_pstᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro inc_nbrᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro out_nbrᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro antecedentᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro out_fmlᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro major_hptᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro minor_hptᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro major_depᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro minor_depᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_inc_nbrᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_out_nbrᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_incomingᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_outgoingᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_directᵤ₀ prop_indirectᵤ₀ =>
  --
  intro prop_incomingᵤ₀;
  cases prop_incomingᵤ₀ with | intro edge prop_incomingᵤ₀ =>
  cases prop_incomingᵤ₀ with | intro prop_mem_outgoingᵤ₁ prop_mem_incomingᵤ₀ =>
  have Prop_Edge_Startᵤ : edge.START = U1 := COLLAPSE.Simp_Start_Outgoing prop_mem_outgoingᵤ₁;
  --
  have Prop_Directᵤ₁ := COLLAPSE.Simp_Direct_Indirect₀₂ prop_mem_incomingᵤ₀ prop_indirectᵤ₀;
  rewrite [Prop_Edge_Startᵤ] at Prop_Directᵤ₁;
  /- ¬type2_elimination U1 -/
  apply And.intro ( by rewrite [←imp_false];
                       intro prop_typeᵤ₁;
                       apply absurd Prop_Directᵤ₁;
                       simp only [get_rule] at prop_typeᵤ₁;
                       simp only [type2_elimination] at prop_typeᵤ₁;
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_directᵤ₁ _ =>
                       rewrite [prop_directᵤ₁];
                       simp only [List.cons.injEq];
                       trivial; );
  /- ¬type2_hypothesis U1 -/
  /- ¬type2_introduction U1 -/
  apply And.intro ( by rewrite [←imp_false];
                       intro prop_typeᵤ₁;
                       apply absurd Prop_Directᵤ₁;
                       simp only [get_rule] at prop_typeᵤ₁;
                       simp only [type2_introduction] at prop_typeᵤ₁;
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_directᵤ₁ _ =>
                       rewrite [prop_directᵤ₁];
                       simp only [List.cons.injEq];
                       trivial; );
  /- ¬type2_hypothesis U1 -/
  rewrite [←imp_false];
  intro prop_typeᵤ₁;
  apply absurd Prop_Directᵤ₁;
  simp only [get_rule] at prop_typeᵤ₁;
  simp only [type2_hypothesis] at prop_typeᵤ₁;
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro prop_directᵤ₁ _ =>
  rewrite [prop_directᵤ₁];
  simp only [List.cons.injEq];
  trivial;

  /- Lemma: Collapse Moves Towards Minor & Major Premises -/
  theorem Above_Left_T0E {U0 V0 U1 : Vertex} {DLDS : Graph} :
    ( CLPS.is_collapse U0 V0 DLDS ) →
    ( type0_elimination (get_rule U0 DLDS) ) →
    ( V0.NUMBER > 0 ) →
    ( ∃(edge : Deduction), ( edge ∈ get_rule.outgoing U1 DLDS )
                         ∧ ( edge ∈ get_rule.incoming U0 DLDS ) ) →
    ------------------------------------------------------
    ( U1.LEVEL = U0.LEVEL + 1 )
  ∧ ( type0_elimination (get_rule U1 DLDS) → type2_elimination (get_rule U1 CLPS) )
  ∧ ( type0_introduction (get_rule U1 DLDS) → type2_introduction (get_rule U1 CLPS) )
  ∧ ( type0_hypothesis (get_rule U1 DLDS) → type2_hypothesis (get_rule U1 CLPS) ) := by
  intro prop_collapse;
  --
  intro prop_typeᵤ₀;
  simp only [get_rule] at prop_typeᵤ₀;
  simp only [type0_elimination] at prop_typeᵤ₀;
  cases prop_typeᵤ₀ with | intro prop_nbrᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_lvlᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_hptᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_colᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_pstᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro inc_nbrᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro out_nbrᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro antecedentᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro out_fmlᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro major_hptᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro minor_hptᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro major_depᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro minor_depᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_inc_nbrᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_out_nbrᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_incomingᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_outgoingᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_directᵤ₀ prop_indirectᵤ₀ =>
  --
  intro  prop_nbrᵥ₀;
  --
  intro prop_incomingᵤ₀;
  cases prop_incomingᵤ₀ with | intro edge prop_incomingᵤ₀ =>
  cases prop_incomingᵤ₀ with | intro prop_mem_outgoingᵤ₁ prop_mem_incomingᵤ₀ =>
  /- U1.LEVEL = U0.LEVEL + 1 -/
  have Prop_Edge_Startᵤ : edge.START = U1 := COLLAPSE.Simp_Start_Outgoing prop_mem_outgoingᵤ₁;
  have Prop_Edge_Endᵤ : edge.END = U0 := COLLAPSE.Simp_End_Incoming prop_mem_incomingᵤ₀;
  have Prop_Upper_LVLᵤ : U1.LEVEL = U0.LEVEL + 1 := by rewrite [←Prop_Edge_Startᵤ, ←Prop_Edge_Endᵤ];
                                                       rewrite [prop_incomingᵤ₀] at prop_mem_incomingᵤ₀;
                                                       cases prop_mem_incomingᵤ₀ with | head _ => trivial;
                                                                                      | tail _ mem_cases => cases mem_cases with
                                                                                                            | head _ => trivial;
                                                                                                            | tail _ mem_cases => trivial;
  apply And.intro ( by exact Prop_Upper_LVLᵤ; );
  /- Unfold "get_rule U1 CLPS" -/
  rewrite [←Prop_Edge_Startᵤ];
  rewrite [COLLAPSE.Simp_Rule_Above_Left prop_colᵤ₀ prop_collapse prop_mem_incomingᵤ₀];
  rewrite [Prop_Edge_Startᵤ];
  /- type0_elimination U1 → type2_elimination U1 -/
  apply And.intro ( by intro prop_typeᵤ₁;
                       simp only [get_rule] at prop_typeᵤ₁;
                       simp only [type0_elimination] at prop_typeᵤ₁;
                       cases prop_typeᵤ₁ with | intro prop_nbrᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_lvlᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_hptᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_colᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_pstᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro inc_nbrᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro out_nbrᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro antecedentᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro out_fmlᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro major_hptᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro minor_hptᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro major_depᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro minor_depᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_inc_nbrᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_out_nbrᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_incomingᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_outgoingᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_directᵤ₁ prop_indirectᵤ₁ =>
                       --
                       simp only [type2_elimination];
                       apply And.intro ( by exact prop_nbrᵤ₁; );              /- := RULE.CENTER.NUMBER > 0 -/
                       apply And.intro ( by exact prop_lvlᵤ₁; );              /- := RULE.CENTER.LEVEL > 0 -/
                       apply And.intro ( by exact prop_hptᵤ₁; );              /- := RULE.CENTER.HYPOTHESIS = false -/
                       apply And.intro ( by exact prop_colᵤ₁; );              /- := RULE.CENTER.COLLAPSED = false -/
                       apply And.intro ( by exact prop_pstᵤ₁; );              /- := RULE.CENTER.PAST = [] -/
                       apply Exists.intro inc_nbrᵤ₁;                          /- := inc_nbr -/
                       apply Exists.intro U0.NUMBER;                          /- := out_nbr -/
                       apply Exists.intro out_nbrᵤ₀;                          /- := anc_nbr -/
                       apply Exists.intro (U0.LEVEL - 1);                     /- := anc_lvl -/
                       apply Exists.intro antecedentᵤ₁;                       /- := antecedent -/
                       apply Exists.intro U0.FORMULA;                         /- := out_fml -/
                       apply Exists.intro out_fmlᵤ₀;                          /- := anc_fml -/
                       apply Exists.intro major_hptᵤ₁;                        /- := major_hpt -/
                       apply Exists.intro minor_hptᵤ₁;                        /- := minor_hpt -/
                       apply Exists.intro (U0.HYPOTHESIS || V0.HYPOTHESIS);   /- := out_hpt -/
                       apply Exists.intro major_depᵤ₁;                        /- := major_dep -/
                       apply Exists.intro minor_depᵤ₁;                        /- := minor_dep -/
                       apply Exists.intro V0.NUMBER;                          /- := past -/
                       apply Exists.intro U0.NUMBER;                          /- := colour -/
                       apply Exists.intro U0.PAST;                            /- := pasts -/
                       apply Exists.intro [];                                 /- := colours -/
                       apply And.intro ( by exact prop_inc_nbrᵤ₁; );                           /- := inc_nbr > 0 -/
                       apply And.intro ( by exact prop_nbrᵤ₀; );                               /- := out_nbr > 0 -/
                       apply And.intro ( by exact prop_out_nbrᵤ₀; );                           /- := anc_nbr > 0 -/
                       apply And.intro ( by rewrite [Prop_Upper_LVLᵤ];                         /- := anc_lvl + List.length (0::colour::colours) = RULE.CENTER.LEVEL -/
                                            simp only [List.length];
                                            simp only [Nat.zero_add, ←Nat.add_assoc];
                                            simp only [Nat.sub_add_cancel prop_lvlᵤ₀]; );
                       apply And.intro ( by exact List.Mem.head (V0.NUMBER :: U0.PAST); );     /- := colour ∈ (out_nbr::past::pasts) -/
                       apply And.intro ( by rewrite [prop_pstᵤ₀];                              /- := check_numbers (past::pasts) -/
                                            exact COLLAPSE.Check_Numbers_Unit prop_nbrᵥ₀; );
                       apply And.intro ( by exact COLLAPSE.Check_Numbers_Unit prop_nbrᵤ₀; );   /- := check_numbers (colour::colours) -/
                       /- Incoming Edges -/------------------------------------------------------------------------------------------------------------------------------
                       apply And.intro ( by exact prop_incomingᵤ₁; );
                       /- Outgoing Edges -/------------------------------------------------------------------------------------------------------------------------------
                       apply And.intro ( by simp only [prop_outgoingᵤ₁];
                                            simp only [is_collapse.update_edges_end];
                                            simp only [is_collapse.update_edges_end.loop];
                                            simp only [collapse.center];
                                            rewrite [←Prop_Edge_Startᵤ, ←Prop_Edge_Endᵤ];
                                            rewrite [prop_outgoingᵤ₁] at prop_mem_outgoingᵤ₁;
                                            cases prop_mem_outgoingᵤ₁ with | head _ => simp only [List.cons.injEq, ite_true];
                                                                           | tail _ mem_cases => trivial; );
                       /- Direct Edges -/--------------------------------------------------------------------------------------------------------------------------------
                       apply And.intro ( by simp only [prop_incomingᵤ₀, prop_outgoingᵤ₀, prop_directᵤ₀];
                                            simp only [pre_collapse.indirect, prop_hptᵤ₀];
                                            simp only [pre_collapse.indirect.create];
                                            rewrite [←Prop_Edge_Startᵤ, ←Prop_Edge_Endᵤ];
                                            rewrite [prop_incomingᵤ₀] at prop_mem_incomingᵤ₀;
                                            cases prop_mem_incomingᵤ₀ with | head _ => simp only [get_rule.direct.loop];
                                                                                       simp_arith;
                                                                           | tail _ mem_cases => cases mem_cases with
                                                                                                 | head _ => simp only [get_rule.direct.loop];
                                                                                                             simp_arith;
                                                                                                 | tail _ mem_cases => trivial; );
                       /- Indirect Edges -/------------------------------------------------------------------------------------------------------------------------------
                       exact prop_indirectᵤ₁; );
  /- type0_introduction U1 → type2_introduction U1 -/
  apply And.intro ( by intro prop_typeᵤ₁;
                       simp only [get_rule] at prop_typeᵤ₁;
                       simp only [type0_introduction] at prop_typeᵤ₁;
                       cases prop_typeᵤ₁ with | intro prop_nbrᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_lvlᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_hptᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_colᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_pstᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro inc_nbrᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro out_nbrᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro antecedentᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro consequentᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro out_fmlᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro inc_depᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_fmlᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_inc_nbrᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_out_nbrᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_incomingᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_outgoingᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_directᵤ₁ prop_indirectᵤ₁ =>
                       --
                       simp only [type2_introduction];
                       apply And.intro ( by exact prop_nbrᵤ₁; );
                       apply And.intro ( by exact prop_lvlᵤ₁; );
                       apply And.intro ( by exact prop_hptᵤ₁; );
                       apply And.intro ( by exact prop_colᵤ₁; );
                       apply And.intro ( by exact prop_pstᵤ₁; );
                       apply Exists.intro inc_nbrᵤ₁;                          /- := inc_nbr -/
                       apply Exists.intro U0.NUMBER;                          /- := out_nbr -/
                       apply Exists.intro out_nbrᵤ₀;                          /- := anc_nbr -/
                       apply Exists.intro (U0.LEVEL - 1);                     /- := anc_lvl -/
                       apply Exists.intro antecedentᵤ₁;                       /- := antecedent -/
                       apply Exists.intro consequentᵤ₁;                       /- := consequent -/
                       apply Exists.intro U0.FORMULA;                         /- := out_fml -/
                       apply Exists.intro out_fmlᵤ₀;                          /- := anc_fml -/
                       apply Exists.intro (U0.HYPOTHESIS || V0.HYPOTHESIS);   /- := out_hpt -/
                       apply Exists.intro inc_depᵤ₁;                          /- := inc_dep -/
                       apply Exists.intro V0.NUMBER;                          /- := past -/
                       apply Exists.intro U0.NUMBER;                          /- := colour -/
                       apply Exists.intro U0.PAST;                            /- := pasts -/
                       apply Exists.intro [];                                 /- := colours -/
                       apply And.intro ( by exact prop_fmlᵤ₁; );                               /- := RULE.CENTER.FORMULA = antecedent>>consequent -/
                       apply And.intro ( by exact prop_inc_nbrᵤ₁; );                           /- := inc_nbr > 0 -/
                       apply And.intro ( by exact prop_nbrᵤ₀; );                               /- := out_nbr > 0 -/
                       apply And.intro ( by exact prop_out_nbrᵤ₀; );                           /- := anc_nbr > 0 -/
                       apply And.intro ( by rewrite [Prop_Upper_LVLᵤ];                         /- := anc_lvl + List.length (0::colour::colours) = RULE.CENTER.LEVEL -/
                                            simp only [List.length];
                                            simp only [Nat.zero_add, ←Nat.add_assoc];
                                            simp only [Nat.sub_add_cancel prop_lvlᵤ₀]; );
                       apply And.intro ( by exact List.Mem.head (V0.NUMBER :: U0.PAST); );     /- := colour ∈ (out_nbr::past::pasts) -/
                       apply And.intro ( by rewrite [prop_pstᵤ₀];                              /- := check_numbers (past::pasts) -/
                                            exact COLLAPSE.Check_Numbers_Unit prop_nbrᵥ₀; );
                       apply And.intro ( by exact COLLAPSE.Check_Numbers_Unit prop_nbrᵤ₀; );   /- := check_numbers (colour::colours) -/
                       /- Incoming Edges -/------------------------------------------------------------------------------------------------------------------------------
                       apply And.intro ( by exact prop_incomingᵤ₁; );
                       /- Outgoing Edges -/------------------------------------------------------------------------------------------------------------------------------
                       apply And.intro ( by simp only [prop_outgoingᵤ₁];
                                            simp only [is_collapse.update_edges_end];
                                            simp only [is_collapse.update_edges_end.loop];
                                            simp only [collapse.center];
                                            rewrite [←Prop_Edge_Startᵤ, ←Prop_Edge_Endᵤ];
                                            rewrite [prop_outgoingᵤ₁] at prop_mem_outgoingᵤ₁;
                                            cases prop_mem_outgoingᵤ₁ with | head _ => simp only [List.cons.injEq, ite_true];
                                                                           | tail _ mem_cases => trivial; );
                       /- Direct Edges -/--------------------------------------------------------------------------------------------------------------------------------
                       apply And.intro ( by simp only [prop_incomingᵤ₀, prop_outgoingᵤ₀, prop_directᵤ₀];
                                            simp only [pre_collapse.indirect, prop_hptᵤ₀];
                                            simp only [pre_collapse.indirect.create];
                                            rewrite [←Prop_Edge_Startᵤ, ←Prop_Edge_Endᵤ];
                                            rewrite [prop_incomingᵤ₀] at prop_mem_incomingᵤ₀;
                                            cases prop_mem_incomingᵤ₀ with | head _ => simp only [get_rule.direct.loop];
                                                                                       simp_arith;
                                                                           | tail _ mem_cases => cases mem_cases with
                                                                                                 | head _ => simp only [get_rule.direct.loop];
                                                                                                             simp_arith;
                                                                                                 | tail _ mem_cases => trivial; );
                       /- Indirect Edges -/------------------------------------------------------------------------------------------------------------------------------
                       exact prop_indirectᵤ₁; );
  /- type0_hypothesis U1 → type2_hypothesis U1 -/
  intro prop_typeᵤ₁;
  simp only [get_rule] at prop_typeᵤ₁;
  simp only [type0_hypothesis] at prop_typeᵤ₁;
  cases prop_typeᵤ₁ with | intro prop_nbrᵤ₁ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro prop_lvlᵤ₁ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro prop_hptᵤ₁ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro prop_colᵤ₁ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro prop_pstᵤ₁ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro out_nbrᵤ₁ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro out_fmlᵤ₁ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro prop_out_nbrᵤ₁ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro prop_incomingᵤ₁ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro prop_outgoingᵤ₁ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro prop_directᵤ₁ prop_indirectᵤ₁ =>
  --
  simp only [type2_hypothesis];
  apply And.intro ( by exact prop_nbrᵤ₁; );
  apply And.intro ( by exact prop_lvlᵤ₁; );
  apply And.intro ( by exact prop_hptᵤ₁; );
  apply And.intro ( by exact prop_colᵤ₁; );
  apply And.intro ( by exact prop_pstᵤ₁; );
  apply Exists.intro U0.NUMBER;                          /- := out_nbr -/
  apply Exists.intro out_nbrᵤ₀;                          /- := anc_nbr -/
  apply Exists.intro (U0.LEVEL - 1);                     /- := anc_lvl -/
  apply Exists.intro U0.FORMULA;                         /- := out_fml -/
  apply Exists.intro out_fmlᵤ₀;                          /- := anc_fml -/
  apply Exists.intro (U0.HYPOTHESIS || V0.HYPOTHESIS);   /- := out_hpt -/
  apply Exists.intro V0.NUMBER;                          /- := past -/
  apply Exists.intro U0.NUMBER;                          /- := colour -/
  apply Exists.intro U0.PAST;                            /- := pasts -/
  apply Exists.intro [];                                 /- := colours -/
  apply And.intro ( by exact prop_nbrᵤ₀; );                               /- := out_nbr > 0 -/
  apply And.intro ( by exact prop_out_nbrᵤ₀; );                           /- := anc_nbr > 0 -/
  apply And.intro ( by rewrite [Prop_Upper_LVLᵤ];                         /- := anc_lvl + List.length (0::colour::colours) = RULE.CENTER.LEVEL -/
                       simp only [List.length];
                       simp only [Nat.zero_add, ←Nat.add_assoc];
                       simp only [Nat.sub_add_cancel prop_lvlᵤ₀]; );
  apply And.intro ( by exact List.Mem.head (V0.NUMBER :: U0.PAST); );     /- := colour ∈ (out_nbr::past::pasts) -/
  apply And.intro ( by rewrite [prop_pstᵤ₀];                              /- := check_numbers (past::pasts) -/
                       exact COLLAPSE.Check_Numbers_Unit prop_nbrᵥ₀; );
  apply And.intro ( by exact COLLAPSE.Check_Numbers_Unit prop_nbrᵤ₀; );   /- := check_numbers (colour::colours) -/
  /- Incoming Edges -/------------------------------------------------------------------------------------------------------------------------------
  apply And.intro ( by exact prop_incomingᵤ₁; );
  /- Outgoing Edges -/------------------------------------------------------------------------------------------------------------------------------
  apply And.intro ( by simp only [prop_outgoingᵤ₁];
                       simp only [is_collapse.update_edges_end];
                       simp only [is_collapse.update_edges_end.loop];
                       simp only [collapse.center];
                       rewrite [←Prop_Edge_Startᵤ, ←Prop_Edge_Endᵤ];
                       rewrite [prop_outgoingᵤ₁] at prop_mem_outgoingᵤ₁;
                       cases prop_mem_outgoingᵤ₁ with | head _ => simp only [List.cons.injEq, ite_true];
                                                      | tail _ mem_cases => trivial; );
  /- Direct Edges -/--------------------------------------------------------------------------------------------------------------------------------
  apply And.intro ( by simp only [prop_incomingᵤ₀, prop_outgoingᵤ₀, prop_directᵤ₀];
                       simp only [pre_collapse.indirect, prop_hptᵤ₀];
                       simp only [pre_collapse.indirect.create];
                       rewrite [←Prop_Edge_Startᵤ, ←Prop_Edge_Endᵤ];
                       rewrite [prop_incomingᵤ₀] at prop_mem_incomingᵤ₀;
                       cases prop_mem_incomingᵤ₀ with | head _ => simp only [get_rule.direct.loop];
                                                                  simp_arith;
                                                      | tail _ mem_cases => cases mem_cases with
                                                                            | head _ => simp only [get_rule.direct.loop];
                                                                                        simp_arith;
                                                                            | tail _ mem_cases => trivial; );
  /- Indirect Edges -/------------------------------------------------------------------------------------------------------------------------------
  exact prop_indirectᵤ₁;

  /- Lemma: Collapse Moves Towards Minor & Major Premises -/
  theorem Above_Right_T0E {U0 V0 V1 : Vertex} {DLDS : Graph} :
    ( CLPS.is_collapse U0 V0 DLDS ) →
    ( U0.LEVEL = V0.LEVEL ) → ( U0.FORMULA = V0.FORMULA ) →
    ( U0.NUMBER > 0 ) → ( check_numbers (U0.NUMBER::U0.PAST) ) →
    ( type0_elimination (get_rule V0 DLDS) ) →
    ( ∃(edge : Deduction), ( edge ∈ get_rule.outgoing V1 DLDS )
                         ∧ ( edge ∈ get_rule.incoming V0 DLDS ) ) →
    ------------------------------------------------------
    ( V1.LEVEL = V0.LEVEL + 1 )
  ∧ ( type0_elimination (get_rule V1 DLDS) → type2_elimination (get_rule V1 CLPS) )
  ∧ ( type0_introduction (get_rule V1 DLDS) → type2_introduction (get_rule V1 CLPS) )
  ∧ ( type0_hypothesis (get_rule V1 DLDS) → type2_hypothesis (get_rule V1 CLPS) ) := by
  intro prop_collapse;
  --
  intro prop_eq_lvl prop_eq_fml;
  --
  intro prop_nbrᵤ₀ prop_pstᵤ₀;
  --
  intro prop_typeᵥ₀;
  simp only [get_rule] at prop_typeᵥ₀;
  simp only [type0_elimination] at prop_typeᵥ₀;
  cases prop_typeᵥ₀ with | intro prop_nbrᵥ₀ prop_typeᵥ₀ =>
  cases prop_typeᵥ₀ with | intro prop_lvlᵥ₀ prop_typeᵥ₀ =>
  cases prop_typeᵥ₀ with | intro prop_hptᵥ₀ prop_typeᵥ₀ =>
  cases prop_typeᵥ₀ with | intro prop_colᵥ₀ prop_typeᵥ₀ =>
  cases prop_typeᵥ₀ with | intro prop_pstᵥ₀ prop_typeᵥ₀ =>
  cases prop_typeᵥ₀ with | intro inc_nbrᵥ₀ prop_typeᵥ₀ =>
  cases prop_typeᵥ₀ with | intro out_nbrᵥ₀ prop_typeᵥ₀ =>
  cases prop_typeᵥ₀ with | intro antecedentᵥ₀ prop_typeᵥ₀ =>
  cases prop_typeᵥ₀ with | intro out_fmlᵥ₀ prop_typeᵥ₀ =>
  cases prop_typeᵥ₀ with | intro major_hptᵥ₀ prop_typeᵥ₀ =>
  cases prop_typeᵥ₀ with | intro minor_hptᵥ₀ prop_typeᵥ₀ =>
  cases prop_typeᵥ₀ with | intro major_depᵥ₀ prop_typeᵥ₀ =>
  cases prop_typeᵥ₀ with | intro minor_depᵥ₀ prop_typeᵥ₀ =>
  cases prop_typeᵥ₀ with | intro prop_inc_nbrᵥ₀ prop_typeᵥ₀ =>
  cases prop_typeᵥ₀ with | intro prop_out_nbrᵥ₀ prop_typeᵥ₀ =>
  cases prop_typeᵥ₀ with | intro prop_incomingᵥ₀ prop_typeᵥ₀ =>
  cases prop_typeᵥ₀ with | intro prop_outgoingᵥ₀ prop_typeᵥ₀ =>
  cases prop_typeᵥ₀ with | intro prop_directᵥ₀ prop_indirectᵥ₀ =>
  --
  intro prop_incomingᵥ₀;
  cases prop_incomingᵥ₀ with | intro edge prop_incomingᵥ₀ =>
  cases prop_incomingᵥ₀ with | intro prop_mem_outgoingᵥ₁ prop_mem_incomingᵥ₀ =>
  /- U1.LEVEL = U0.LEVEL + 1 -/
  have Prop_Edge_Startᵥ : edge.START = V1 := COLLAPSE.Simp_Start_Outgoing prop_mem_outgoingᵥ₁;
  have Prop_Edge_Endᵥ : edge.END = V0 := COLLAPSE.Simp_End_Incoming prop_mem_incomingᵥ₀;
  have Prop_Upper_LVLᵥ : V1.LEVEL = V0.LEVEL + 1 := by rewrite [←Prop_Edge_Startᵥ, ←Prop_Edge_Endᵥ];
                                                       rewrite [prop_incomingᵥ₀] at prop_mem_incomingᵥ₀;
                                                       cases prop_mem_incomingᵥ₀ with | head _ => trivial;
                                                                                      | tail _ mem_cases => cases mem_cases with
                                                                                                            | head _ => trivial;
                                                                                                            | tail _ mem_cases => trivial;
  apply And.intro ( by exact Prop_Upper_LVLᵥ; );
  /- Unfold "get_rule U1 CLPS" -/
  rewrite [←Prop_Edge_Startᵥ];
  rewrite [COLLAPSE.Simp_Rule_Above_Right prop_collapse prop_mem_incomingᵥ₀];
  rewrite [Prop_Edge_Startᵥ];
  /- type0_elimination V1 → type2_elimination V1 -/
  apply And.intro ( by intro prop_typeᵥ₁;
                       simp only [get_rule] at prop_typeᵥ₁;
                       simp only [type0_elimination] at prop_typeᵥ₁;
                       cases prop_typeᵥ₁ with | intro prop_nbrᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro prop_lvlᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro prop_hptᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro prop_colᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro prop_pstᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro inc_nbrᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro out_nbrᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro antecedentᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro out_fmlᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro major_hptᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro minor_hptᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro major_depᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro minor_depᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro prop_inc_nbrᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro prop_out_nbrᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro prop_incomingᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro prop_outgoingᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro prop_directᵥ₁ prop_indirectᵥ₁ =>
                       --
                       simp only [type2_elimination];
                       apply And.intro ( by exact prop_nbrᵥ₁; );
                       apply And.intro ( by exact prop_lvlᵥ₁; );
                       apply And.intro ( by exact prop_hptᵥ₁; );
                       apply And.intro ( by exact prop_colᵥ₁; );
                       apply And.intro ( by exact prop_pstᵥ₁; );
                       apply Exists.intro inc_nbrᵥ₁;                          /- := inc_nbr -/
                       apply Exists.intro U0.NUMBER;                          /- := out_nbr -/
                       apply Exists.intro out_nbrᵥ₀;                          /- := anc_nbr -/
                       apply Exists.intro (V0.LEVEL - 1);                     /- := anc_lvl -/
                       apply Exists.intro antecedentᵥ₁;                       /- := antecedent -/
                       apply Exists.intro V0.FORMULA;                         /- := out_fml -/
                       apply Exists.intro out_fmlᵥ₀;                          /- := anc_fml -/
                       apply Exists.intro major_hptᵥ₁;                        /- := major_hpt -/
                       apply Exists.intro minor_hptᵥ₁;                        /- := minor_hpt -/
                       apply Exists.intro (U0.HYPOTHESIS || V0.HYPOTHESIS);   /- := out_hpt -/
                       apply Exists.intro major_depᵥ₁;                        /- := major_dep -/
                       apply Exists.intro minor_depᵥ₁;                        /- := minor_dep -/
                       apply Exists.intro V0.NUMBER;                          /- := past -/
                       apply Exists.intro V0.NUMBER;                          /- := colour -/
                       apply Exists.intro U0.PAST;                            /- := pasts -/
                       apply Exists.intro [];                                 /- := colours -/
                       apply And.intro ( by exact prop_inc_nbrᵥ₁; );                                    /- := inc_nbr > 0 -/
                       apply And.intro ( by exact prop_nbrᵤ₀; );                                        /- := out_nbr > 0 -/
                       apply And.intro ( by exact prop_out_nbrᵥ₀; );                                    /- := anc_nbr > 0 -/
                       apply And.intro ( by rewrite [Prop_Upper_LVLᵥ];                                  /- := anc_lvl + List.length (0::colour::colours) = RULE.CENTER.LEVEL -/
                                            simp only [List.length];
                                            simp only [Nat.zero_add, ←Nat.add_assoc];
                                            simp only [Nat.sub_add_cancel prop_lvlᵥ₀]; );
                       apply And.intro ( by exact List.Mem.tail U0.NUMBER (List.Mem.head U0.PAST); );   /- := colour ∈ (out_nbr::past::pasts) -/
                       apply And.intro ( by simp only [check_numbers] at prop_pstᵤ₀ ⊢;                  /- := check_numbers (past::pasts) -/
                                            apply And.intro ( by simp only [ne_eq, List.cons.injEq]; trivial; );
                                            cases prop_pstᵤ₀ with | intro _ prop_pstᵤ₀ =>
                                            intro nbr mem_cases;
                                            cases mem_cases with
                                            | head => exact prop_nbrᵥ₀;
                                            | tail _ mem_cases => exact prop_pstᵤ₀ (List.Mem.tail U0.NUMBER mem_cases); );
                       apply And.intro ( by exact COLLAPSE.Check_Numbers_Unit prop_nbrᵥ₀; );            /- := check_numbers (colour::colours) -/
                       /- Incoming Edges -/------------------------------------------------------------------------------------------------------------------------------
                       apply And.intro ( by exact prop_incomingᵥ₁; );
                       /- Outgoing Edges -/------------------------------------------------------------------------------------------------------------------------------
                       apply And.intro ( by simp only [prop_outgoingᵥ₁];
                                            simp only [is_collapse.update_edges_end];
                                            simp only [is_collapse.update_edges_end.loop];
                                            simp only [collapse.center];
                                            rewrite [prop_eq_lvl, prop_eq_fml];
                                            rewrite [←Prop_Edge_Startᵥ, ←Prop_Edge_Endᵥ];
                                            rewrite [prop_outgoingᵥ₁] at prop_mem_outgoingᵥ₁;
                                            cases prop_mem_outgoingᵥ₁ with | head _ => simp only [List.cons.injEq, ite_true];
                                                                           | tail _ mem_cases => trivial; );
                       /- Direct Paths -/--------------------------------------------------------------------------------------------------------------------------------
                       apply And.intro ( by simp only [prop_incomingᵥ₀, prop_outgoingᵥ₀, prop_directᵥ₀];
                                            simp only [pre_collapse.indirect, prop_hptᵥ₀];
                                            simp only [pre_collapse.indirect.create];
                                            rewrite [←Prop_Edge_Startᵥ, ←Prop_Edge_Endᵥ];
                                            rewrite [prop_incomingᵥ₀] at prop_mem_incomingᵥ₀;
                                            cases prop_mem_incomingᵥ₀ with | head _ => simp only [get_rule.direct.loop];
                                                                                       simp_arith;
                                                                           | tail _ mem_cases => cases mem_cases with
                                                                                                 | head _ => simp only [get_rule.direct.loop];
                                                                                                             simp_arith;
                                                                                                 | tail _ mem_cases => trivial; );
                       /- Indirect Paths -/------------------------------------------------------------------------------------------------------------------------------
                       exact prop_indirectᵥ₁; );
  /- type0_introduction V1 → type2_introduction V1 -/
  apply And.intro ( by intro prop_typeᵥ₁;
                       simp only [get_rule] at prop_typeᵥ₁;
                       simp only [type0_introduction] at prop_typeᵥ₁;
                       cases prop_typeᵥ₁ with | intro prop_nbrᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro prop_lvlᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro prop_hptᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro prop_colᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro prop_pstᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro inc_nbrᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro out_nbrᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro antecedentᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro consequentᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro out_fmlᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro inc_depᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro prop_fmlᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro prop_inc_nbrᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro prop_out_nbrᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro prop_incomingᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro prop_outgoingᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro prop_directᵥ₁ prop_indirectᵥ₁ =>
                       --
                       simp only [type2_introduction];
                       apply And.intro ( by exact prop_nbrᵥ₁; );
                       apply And.intro ( by exact prop_lvlᵥ₁; );
                       apply And.intro ( by exact prop_hptᵥ₁; );
                       apply And.intro ( by exact prop_colᵥ₁; );
                       apply And.intro ( by exact prop_pstᵥ₁; );
                       apply Exists.intro inc_nbrᵥ₁;                          /- := inc_nbr -/
                       apply Exists.intro U0.NUMBER;                          /- := out_nbr -/
                       apply Exists.intro out_nbrᵥ₀;                          /- := anc_nbr -/
                       apply Exists.intro (V0.LEVEL - 1);                     /- := anc_lvl -/
                       apply Exists.intro antecedentᵥ₁;                       /- := antecedent -/
                       apply Exists.intro consequentᵥ₁;                       /- := consequent -/
                       apply Exists.intro V0.FORMULA;                         /- := out_fml -/
                       apply Exists.intro out_fmlᵥ₀;                          /- := anc_fml -/
                       apply Exists.intro (U0.HYPOTHESIS || V0.HYPOTHESIS);   /- := out_hpt -/
                       apply Exists.intro inc_depᵥ₁;                          /- := inc_dep -/
                       apply Exists.intro V0.NUMBER;                          /- := past -/
                       apply Exists.intro V0.NUMBER;                          /- := colour -/
                       apply Exists.intro U0.PAST;                            /- := pasts -/
                       apply Exists.intro [];                                 /- := colours -/
                       apply And.intro ( by exact prop_fmlᵥ₁; );                                        /- := RULE.CENTER.FORMULA = antecedent>>consequent -/
                       apply And.intro ( by exact prop_inc_nbrᵥ₁; );                                    /- := inc_nbr > 0 -/
                       apply And.intro ( by exact prop_nbrᵤ₀; );                                        /- := out_nbr > 0 -/
                       apply And.intro ( by exact prop_out_nbrᵥ₀; );                                    /- := anc_nbr > 0 -/
                       apply And.intro ( by rewrite [Prop_Upper_LVLᵥ];                                  /- := anc_lvl + List.length (0::colour::colours) = RULE.CENTER.LEVEL -/
                                            simp only [List.length];
                                            simp only [Nat.zero_add, ←Nat.add_assoc];
                                            simp only [Nat.sub_add_cancel prop_lvlᵥ₀]; );
                       apply And.intro ( by exact List.Mem.tail U0.NUMBER (List.Mem.head U0.PAST); );   /- := colour ∈ (out_nbr::past::pasts) -/
                       apply And.intro ( by simp only [check_numbers] at prop_pstᵤ₀ ⊢;                  /- := check_numbers (past::pasts) -/
                                            apply And.intro ( by simp only [ne_eq, List.cons.injEq]; trivial; );
                                            cases prop_pstᵤ₀ with | intro _ prop_pstᵤ₀ =>
                                            intro nbr mem_cases;
                                            cases mem_cases with
                                            | head => exact prop_nbrᵥ₀;
                                            | tail _ mem_cases => exact prop_pstᵤ₀ (List.Mem.tail U0.NUMBER mem_cases); );
                       apply And.intro ( by exact COLLAPSE.Check_Numbers_Unit prop_nbrᵥ₀; );            /- := check_numbers (colour::colours) -/
                       /- Incoming Edges -/------------------------------------------------------------------------------------------------------------------------------
                       apply And.intro ( by exact prop_incomingᵥ₁; );
                       /- Outgoing Edges -/------------------------------------------------------------------------------------------------------------------------------
                       apply And.intro ( by simp only [prop_outgoingᵥ₁];
                                            simp only [is_collapse.update_edges_end];
                                            simp only [is_collapse.update_edges_end.loop];
                                            simp only [collapse.center];
                                            rewrite [prop_eq_lvl, prop_eq_fml];
                                            rewrite [←Prop_Edge_Startᵥ, ←Prop_Edge_Endᵥ];
                                            rewrite [prop_outgoingᵥ₁] at prop_mem_outgoingᵥ₁;
                                            cases prop_mem_outgoingᵥ₁ with | head _ => simp only [List.cons.injEq, ite_true];
                                                                           | tail _ mem_cases => trivial; );
                       /- Direct Paths -/--------------------------------------------------------------------------------------------------------------------------------
                       apply And.intro ( by simp only [prop_incomingᵥ₀, prop_outgoingᵥ₀, prop_directᵥ₀];
                                            simp only [pre_collapse.indirect, prop_hptᵥ₀];
                                            simp only [pre_collapse.indirect.create];
                                            rewrite [←Prop_Edge_Startᵥ, ←Prop_Edge_Endᵥ];
                                            rewrite [prop_incomingᵥ₀] at prop_mem_incomingᵥ₀;
                                            cases prop_mem_incomingᵥ₀ with | head _ => simp only [get_rule.direct.loop];
                                                                                       simp_arith;
                                                                           | tail _ mem_cases => cases mem_cases with
                                                                                                 | head _ => simp only [get_rule.direct.loop];
                                                                                                             simp_arith;
                                                                                                 | tail _ mem_cases => trivial; );
                       /- Indirect Paths -/------------------------------------------------------------------------------------------------------------------------------
                       exact prop_indirectᵥ₁; );
  /- type0_hypothesis V1 → type2_hypothesis V1 -/
  intro prop_typeᵥ₁;
  simp only [get_rule] at prop_typeᵥ₁;
  simp only [type0_hypothesis] at prop_typeᵥ₁;
  cases prop_typeᵥ₁ with | intro prop_nbrᵥ₁ prop_typeᵥ₁ =>
  cases prop_typeᵥ₁ with | intro prop_lvlᵥ₁ prop_typeᵥ₁ =>
  cases prop_typeᵥ₁ with | intro prop_hptᵥ₁ prop_typeᵥ₁ =>
  cases prop_typeᵥ₁ with | intro prop_colᵥ₁ prop_typeᵥ₁ =>
  cases prop_typeᵥ₁ with | intro prop_pstᵥ₁ prop_typeᵥ₁ =>
  cases prop_typeᵥ₁ with | intro out_nbrᵥ₁ prop_typeᵥ₁ =>
  cases prop_typeᵥ₁ with | intro out_fmlᵥ₁ prop_typeᵥ₁ =>
  cases prop_typeᵥ₁ with | intro prop_out_nbrᵥ₁ prop_typeᵥ₁ =>
  cases prop_typeᵥ₁ with | intro prop_incomingᵥ₁ prop_typeᵥ₁ =>
  cases prop_typeᵥ₁ with | intro prop_outgoingᵥ₁ prop_typeᵥ₁ =>
  cases prop_typeᵥ₁ with | intro prop_directᵥ₁ prop_indirectᵥ₁ =>
  --
  simp only [type2_hypothesis];
  apply And.intro ( by exact prop_nbrᵥ₁; );
  apply And.intro ( by exact prop_lvlᵥ₁; );
  apply And.intro ( by exact prop_hptᵥ₁; );
  apply And.intro ( by exact prop_colᵥ₁; );
  apply And.intro ( by exact prop_pstᵥ₁; );
  apply Exists.intro U0.NUMBER;                          /- := out_nbr -/
  apply Exists.intro out_nbrᵥ₀;                          /- := anc_nbr -/
  apply Exists.intro (V0.LEVEL - 1);                     /- := anc_lvl -/
  apply Exists.intro V0.FORMULA;                         /- := out_fml -/
  apply Exists.intro out_fmlᵥ₀;                          /- := anc_fml -/
  apply Exists.intro (U0.HYPOTHESIS || V0.HYPOTHESIS);   /- := out_hpt -/
  apply Exists.intro V0.NUMBER;                          /- := past -/
  apply Exists.intro V0.NUMBER;                          /- := colour -/
  apply Exists.intro U0.PAST;                            /- := pasts -/
  apply Exists.intro [];                                 /- := colours -/
  apply And.intro ( by exact prop_nbrᵤ₀; );                                        /- := out_nbr > 0 -/
  apply And.intro ( by exact prop_out_nbrᵥ₀; );                                    /- := anc_nbr > 0 -/
  apply And.intro ( by rewrite [Prop_Upper_LVLᵥ];                                  /- := anc_lvl + List.length (0::colour::colours) = RULE.CENTER.LEVEL -/
                       simp only [List.length];
                       simp only [Nat.zero_add, ←Nat.add_assoc];
                       simp only [Nat.sub_add_cancel prop_lvlᵥ₀]; );
  apply And.intro ( by exact List.Mem.tail U0.NUMBER (List.Mem.head U0.PAST); );   /- := colour ∈ (out_nbr::past::pasts) -/
  apply And.intro ( by simp only [check_numbers] at prop_pstᵤ₀ ⊢;                  /- := check_numbers (past::pasts) -/
                       apply And.intro ( by simp only [ne_eq, List.cons.injEq]; trivial; );
                       cases prop_pstᵤ₀ with | intro _ prop_pstᵤ₀ =>
                       intro nbr mem_cases;
                       cases mem_cases with
                       | head => exact prop_nbrᵥ₀;
                       | tail _ mem_cases => exact prop_pstᵤ₀ (List.Mem.tail U0.NUMBER mem_cases); );
  apply And.intro ( by exact COLLAPSE.Check_Numbers_Unit prop_nbrᵥ₀; );            /- := check_numbers (colour::colours) -/
  /- Incoming Edges -/------------------------------------------------------------------------------------------------------------------------------
  apply And.intro ( by exact prop_incomingᵥ₁; );
  /- Outgoing Edges -/------------------------------------------------------------------------------------------------------------------------------
  apply And.intro ( by simp only [prop_outgoingᵥ₁];
                       simp only [is_collapse.update_edges_end];
                       simp only [is_collapse.update_edges_end.loop];
                       simp only [collapse.center];
                                            rewrite [prop_eq_lvl, prop_eq_fml];
                       rewrite [←Prop_Edge_Startᵥ, ←Prop_Edge_Endᵥ];
                       rewrite [prop_outgoingᵥ₁] at prop_mem_outgoingᵥ₁;
                       cases prop_mem_outgoingᵥ₁ with | head _ => simp only [List.cons.injEq, ite_true];
                                                      | tail _ mem_cases => trivial; );
  /- Direct Paths -/--------------------------------------------------------------------------------------------------------------------------------
  apply And.intro ( by simp only [prop_incomingᵥ₀, prop_outgoingᵥ₀, prop_directᵥ₀];
                       simp only [pre_collapse.indirect, prop_hptᵥ₀];
                       simp only [pre_collapse.indirect.create];
                       rewrite [←Prop_Edge_Startᵥ, ←Prop_Edge_Endᵥ];
                       rewrite [prop_incomingᵥ₀] at prop_mem_incomingᵥ₀;
                       cases prop_mem_incomingᵥ₀ with | head _ => simp only [get_rule.direct.loop];
                                                                  simp_arith;
                                                      | tail _ mem_cases => cases mem_cases with
                                                                            | head _ => simp only [get_rule.direct.loop];
                                                                                        simp_arith;
                                                                            | tail _ mem_cases => trivial; );
  /- Indirect Paths -/------------------------------------------------------------------------------------------------------------------------------
  exact prop_indirectᵥ₁;
end COVERAGE.UP.T0E

namespace COVERAGE.UP.T0I
  /- Lemma: Restrictions on Upper Nodes -/
  theorem Not_Above_T0I {U0 U1 : Vertex} {DLDS : Graph} :
    ( type0_introduction (get_rule U0 DLDS) ) →
    ( ∃(edge : Deduction), ( edge ∈ get_rule.outgoing U1 DLDS )
                         ∧ ( edge ∈ get_rule.incoming U0 DLDS ) ) →
    ------------------------------------------------------
    ( ¬type2_elimination (get_rule U1 DLDS) )
  ∧ ( ¬type2_introduction (get_rule U1 DLDS) )
  ∧ ( ¬type2_hypothesis (get_rule U1 DLDS) ) := by
  intro prop_typeᵤ₀;
  simp only [get_rule] at prop_typeᵤ₀;
  simp only [type0_introduction] at prop_typeᵤ₀;
  cases prop_typeᵤ₀ with | intro prop_nbrᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_lvlᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_hptᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_colᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_pstᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro inc_nbrᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro out_nbrᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro antecedentᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro consequentᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro out_fmlᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro inc_depᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_fmlᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_inc_nbrᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_out_nbrᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_incomingᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_outgoingᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_directᵤ₀ prop_indirectᵤ₀ =>
  --
  intro prop_incomingᵤ₀;
  cases prop_incomingᵤ₀ with | intro edge prop_incomingᵤ₀ =>
  cases prop_incomingᵤ₀ with | intro prop_mem_outgoingᵤ₁ prop_mem_incomingᵤ₀ =>
  have Prop_Edge_Startᵤ : edge.START = U1 := COLLAPSE.Simp_Start_Outgoing prop_mem_outgoingᵤ₁;
  --
  have Prop_Directᵤ₁ := COLLAPSE.Simp_Direct_Indirect₀₂ prop_mem_incomingᵤ₀ prop_indirectᵤ₀;
  rewrite [Prop_Edge_Startᵤ] at Prop_Directᵤ₁;
  /- ¬type2_elimination U1 -/
  apply And.intro ( by rewrite [←imp_false];
                       intro prop_typeᵤ₁;
                       apply absurd Prop_Directᵤ₁;
                       simp only [get_rule] at prop_typeᵤ₁;
                       simp only [type2_elimination] at prop_typeᵤ₁;
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_directᵤ₁ _ =>
                       rewrite [prop_directᵤ₁];
                       simp only [List.cons.injEq];
                       trivial; );
  /- ¬type2_hypothesis U1 -/
  /- ¬type2_introduction U1 -/
  apply And.intro ( by rewrite [←imp_false];
                       intro prop_typeᵤ₁;
                       apply absurd Prop_Directᵤ₁;
                       simp only [get_rule] at prop_typeᵤ₁;
                       simp only [type2_introduction] at prop_typeᵤ₁;
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_directᵤ₁ _ =>
                       rewrite [prop_directᵤ₁];
                       simp only [List.cons.injEq];
                       trivial; );
  /- ¬type2_hypothesis U1 -/
  rewrite [←imp_false];
  intro prop_typeᵤ₁;
  apply absurd Prop_Directᵤ₁;
  simp only [get_rule] at prop_typeᵤ₁;
  simp only [type2_hypothesis] at prop_typeᵤ₁;
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro prop_directᵤ₁ _ =>
  rewrite [prop_directᵤ₁];
  simp only [List.cons.injEq];
  trivial;

  /- Lemma: Collapse Moves Towards Unique Premise -/
  theorem Above_Left_T0I {U0 V0 U1 : Vertex} {DLDS : Graph} :
    ( CLPS.is_collapse U0 V0 DLDS ) →
    ( type0_introduction (get_rule U0 DLDS) ) →
    ( V0.NUMBER > 0 ) →
    ( ∃(edge : Deduction), ( edge ∈ get_rule.outgoing U1 DLDS )
                         ∧ ( edge ∈ get_rule.incoming U0 DLDS ) ) →
    ------------------------------------------------------
    ( U1.LEVEL = U0.LEVEL + 1 )
  ∧ ( type0_elimination (get_rule U1 DLDS) → type2_elimination (get_rule U1 CLPS) )
  ∧ ( type0_introduction (get_rule U1 DLDS) → type2_introduction (get_rule U1 CLPS) )
  ∧ ( type0_hypothesis (get_rule U1 DLDS) → type2_hypothesis (get_rule U1 CLPS) ) := by
  intro prop_collapse;
  --
  intro prop_typeᵤ₀;
  simp only [get_rule] at prop_typeᵤ₀;
  simp only [type0_introduction] at prop_typeᵤ₀;
  cases prop_typeᵤ₀ with | intro prop_nbrᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_lvlᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_hptᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_colᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_pstᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro inc_nbrᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro out_nbrᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro antecedentᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro consequentᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro out_fmlᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro inc_depᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_fmlᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_inc_nbrᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_out_nbrᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_incomingᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_outgoingᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_directᵤ₀ prop_indirectᵤ₀ =>
  --
  intro  prop_nbrᵥ₀;
  --
  intro prop_incomingᵤ₀;
  cases prop_incomingᵤ₀ with | intro edge prop_incomingᵤ₀ =>
  cases prop_incomingᵤ₀ with | intro prop_mem_outgoingᵤ₁ prop_mem_incomingᵤ₀ =>
  /- U1.LEVEL = U0.LEVEL + 1 -/
  have Prop_Edge_Startᵤ : edge.START = U1 := COLLAPSE.Simp_Start_Outgoing prop_mem_outgoingᵤ₁;
  have Prop_Edge_Endᵤ : edge.END = U0 := COLLAPSE.Simp_End_Incoming prop_mem_incomingᵤ₀;
  have Prop_Upper_LVLᵤ : U1.LEVEL = U0.LEVEL + 1 := by rewrite [←Prop_Edge_Startᵤ, ←Prop_Edge_Endᵤ];
                                                       rewrite [prop_incomingᵤ₀] at prop_mem_incomingᵤ₀;
                                                       cases prop_mem_incomingᵤ₀ with | head _ => trivial;
                                                                                      | tail _ mem_cases => trivial;
  apply And.intro ( by exact Prop_Upper_LVLᵤ; );
  /- Unfold "get_rule U1 CLPS" -/
  rewrite [←Prop_Edge_Startᵤ];
  rewrite [COLLAPSE.Simp_Rule_Above_Left prop_colᵤ₀ prop_collapse prop_mem_incomingᵤ₀];
  rewrite [Prop_Edge_Startᵤ];
  /- type0_elimination U1 → type2_elimination U1 -/
  apply And.intro ( by intro prop_typeᵤ₁;
                       simp only [get_rule] at prop_typeᵤ₁;
                       simp only [type0_elimination] at prop_typeᵤ₁;
                       cases prop_typeᵤ₁ with | intro prop_nbrᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_lvlᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_hptᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_colᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_pstᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro inc_nbrᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro out_nbrᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro antecedentᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro out_fmlᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro major_hptᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro minor_hptᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro major_depᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro minor_depᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_inc_nbrᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_out_nbrᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_incomingᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_outgoingᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_directᵤ₁ prop_indirectᵤ₁ =>
                       --
                       simp only [type2_elimination];
                       apply And.intro ( by exact prop_nbrᵤ₁; );              /- := RULE.CENTER.NUMBER > 0 -/
                       apply And.intro ( by exact prop_lvlᵤ₁; );              /- := RULE.CENTER.LEVEL > 0 -/
                       apply And.intro ( by exact prop_hptᵤ₁; );              /- := RULE.CENTER.HYPOTHESIS = false -/
                       apply And.intro ( by exact prop_colᵤ₁; );              /- := RULE.CENTER.COLLAPSED = false -/
                       apply And.intro ( by exact prop_pstᵤ₁; );              /- := RULE.CENTER.PAST = [] -/
                       apply Exists.intro inc_nbrᵤ₁;                          /- := inc_nbr -/
                       apply Exists.intro U0.NUMBER;                          /- := out_nbr -/
                       apply Exists.intro out_nbrᵤ₀;                          /- := anc_nbr -/
                       apply Exists.intro (U0.LEVEL - 1);                     /- := anc_lvl -/
                       apply Exists.intro antecedentᵤ₁;                       /- := antecedent -/
                       apply Exists.intro U0.FORMULA;                         /- := out_fml -/
                       apply Exists.intro out_fmlᵤ₀;                          /- := anc_fml -/
                       apply Exists.intro major_hptᵤ₁;                        /- := major_hpt -/
                       apply Exists.intro minor_hptᵤ₁;                        /- := minor_hpt -/
                       apply Exists.intro (U0.HYPOTHESIS || V0.HYPOTHESIS);   /- := out_hpt -/
                       apply Exists.intro major_depᵤ₁;                        /- := major_dep -/
                       apply Exists.intro minor_depᵤ₁;                        /- := minor_dep -/
                       apply Exists.intro V0.NUMBER;                          /- := past -/
                       apply Exists.intro U0.NUMBER;                          /- := colour -/
                       apply Exists.intro U0.PAST;                            /- := pasts -/
                       apply Exists.intro [];                                 /- := colours -/
                       apply And.intro ( by exact prop_inc_nbrᵤ₁; );                           /- := inc_nbr > 0 -/
                       apply And.intro ( by exact prop_nbrᵤ₀; );                               /- := out_nbr > 0 -/
                       apply And.intro ( by exact prop_out_nbrᵤ₀; );                           /- := anc_nbr > 0 -/
                       apply And.intro ( by rewrite [Prop_Upper_LVLᵤ];                         /- := anc_lvl + List.length (0::colour::colours) = RULE.CENTER.LEVEL -/
                                            simp only [List.length];
                                            simp only [Nat.zero_add, ←Nat.add_assoc];
                                            simp only [Nat.sub_add_cancel prop_lvlᵤ₀]; );
                       apply And.intro ( by exact List.Mem.head (V0.NUMBER :: U0.PAST); );     /- := colour ∈ (out_nbr::past::pasts) -/
                       apply And.intro ( by rewrite [prop_pstᵤ₀];                              /- := check_numbers (past::pasts) -/
                                            exact COLLAPSE.Check_Numbers_Unit prop_nbrᵥ₀; );
                       apply And.intro ( by exact COLLAPSE.Check_Numbers_Unit prop_nbrᵤ₀; );   /- := check_numbers (colour::colours) -/
                       /- Incoming Edges -/------------------------------------------------------------------------------------------------------------------------------
                       apply And.intro ( by exact prop_incomingᵤ₁; );
                       /- Outgoing Edges -/------------------------------------------------------------------------------------------------------------------------------
                       apply And.intro ( by simp only [prop_outgoingᵤ₁];
                                            simp only [is_collapse.update_edges_end];
                                            simp only [is_collapse.update_edges_end.loop];
                                            simp only [collapse.center];
                                            rewrite [←Prop_Edge_Startᵤ, ←Prop_Edge_Endᵤ];
                                            rewrite [prop_outgoingᵤ₁] at prop_mem_outgoingᵤ₁;
                                            cases prop_mem_outgoingᵤ₁ with | head _ => simp only [List.cons.injEq, ite_true];
                                                                           | tail _ mem_cases => trivial; );
                       /- Direct Edges -/--------------------------------------------------------------------------------------------------------------------------------
                       apply And.intro ( by simp only [prop_incomingᵤ₀, prop_outgoingᵤ₀, prop_directᵤ₀];
                                            simp only [pre_collapse.indirect, prop_hptᵤ₀];
                                            simp only [pre_collapse.indirect.create];
                                            rewrite [←Prop_Edge_Startᵤ, ←Prop_Edge_Endᵤ];
                                            rewrite [prop_incomingᵤ₀] at prop_mem_incomingᵤ₀;
                                            cases prop_mem_incomingᵤ₀ with | head _ => simp only [get_rule.direct.loop];
                                                                                       simp_arith;
                                                                           | tail _ mem_cases => trivial; );
                       /- Indirect Edges -/------------------------------------------------------------------------------------------------------------------------------
                       exact prop_indirectᵤ₁; );
  /- type0_introduction U1 → type2_introduction U1 -/
  apply And.intro ( by intro prop_typeᵤ₁;
                       simp only [get_rule] at prop_typeᵤ₁;
                       simp only [type0_introduction] at prop_typeᵤ₁;
                       cases prop_typeᵤ₁ with | intro prop_nbrᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_lvlᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_hptᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_colᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_pstᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro inc_nbrᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro out_nbrᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro antecedentᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro consequentᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro out_fmlᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro inc_depᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_fmlᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_inc_nbrᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_out_nbrᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_incomingᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_outgoingᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_directᵤ₁ prop_indirectᵤ₁ =>
                       --
                       simp only [type2_introduction];
                       apply And.intro ( by exact prop_nbrᵤ₁; );
                       apply And.intro ( by exact prop_lvlᵤ₁; );
                       apply And.intro ( by exact prop_hptᵤ₁; );
                       apply And.intro ( by exact prop_colᵤ₁; );
                       apply And.intro ( by exact prop_pstᵤ₁; );
                       apply Exists.intro inc_nbrᵤ₁;                          /- := inc_nbr -/
                       apply Exists.intro U0.NUMBER;                          /- := out_nbr -/
                       apply Exists.intro out_nbrᵤ₀;                          /- := anc_nbr -/
                       apply Exists.intro (U0.LEVEL - 1);                     /- := anc_lvl -/
                       apply Exists.intro antecedentᵤ₁;                       /- := antecedent -/
                       apply Exists.intro consequentᵤ₁;                       /- := consequent -/
                       apply Exists.intro U0.FORMULA;                         /- := out_fml -/
                       apply Exists.intro out_fmlᵤ₀;                          /- := anc_fml -/
                       apply Exists.intro (U0.HYPOTHESIS || V0.HYPOTHESIS);   /- := out_hpt -/
                       apply Exists.intro inc_depᵤ₁;                          /- := inc_dep -/
                       apply Exists.intro V0.NUMBER;                          /- := past -/
                       apply Exists.intro U0.NUMBER;                          /- := colour -/
                       apply Exists.intro U0.PAST;                            /- := pasts -/
                       apply Exists.intro [];                                 /- := colours -/
                       apply And.intro ( by exact prop_fmlᵤ₁; );                               /- := RULE.CENTER.FORMULA = antecedent>>consequent -/
                       apply And.intro ( by exact prop_inc_nbrᵤ₁; );                           /- := inc_nbr > 0 -/
                       apply And.intro ( by exact prop_nbrᵤ₀; );                               /- := out_nbr > 0 -/
                       apply And.intro ( by exact prop_out_nbrᵤ₀; );                           /- := anc_nbr > 0 -/
                       apply And.intro ( by rewrite [Prop_Upper_LVLᵤ];                         /- := anc_lvl + List.length (0::colour::colours) = RULE.CENTER.LEVEL -/
                                            simp only [List.length];
                                            simp only [Nat.zero_add, ←Nat.add_assoc];
                                            simp only [Nat.sub_add_cancel prop_lvlᵤ₀]; );
                       apply And.intro ( by exact List.Mem.head (V0.NUMBER :: U0.PAST); );     /- := colour ∈ (out_nbr::past::pasts) -/
                       apply And.intro ( by rewrite [prop_pstᵤ₀];                              /- := check_numbers (past::pasts) -/
                                            exact COLLAPSE.Check_Numbers_Unit prop_nbrᵥ₀; );
                       apply And.intro ( by exact COLLAPSE.Check_Numbers_Unit prop_nbrᵤ₀; );   /- := check_numbers (colour::colours) -/
                       /- Incoming Edges -/------------------------------------------------------------------------------------------------------------------------------
                       apply And.intro ( by exact prop_incomingᵤ₁; );
                       /- Outgoing Edges -/------------------------------------------------------------------------------------------------------------------------------
                       apply And.intro ( by simp only [prop_outgoingᵤ₁];
                                            simp only [is_collapse.update_edges_end];
                                            simp only [is_collapse.update_edges_end.loop];
                                            simp only [collapse.center];
                                            rewrite [←Prop_Edge_Startᵤ, ←Prop_Edge_Endᵤ];
                                            rewrite [prop_outgoingᵤ₁] at prop_mem_outgoingᵤ₁;
                                            cases prop_mem_outgoingᵤ₁ with | head _ => simp only [List.cons.injEq, ite_true];
                                                                           | tail _ mem_cases => trivial; );
                       /- Direct Edges -/--------------------------------------------------------------------------------------------------------------------------------
                       apply And.intro ( by simp only [prop_incomingᵤ₀, prop_outgoingᵤ₀, prop_directᵤ₀];
                                            simp only [pre_collapse.indirect, prop_hptᵤ₀];
                                            simp only [pre_collapse.indirect.create];
                                            rewrite [←Prop_Edge_Startᵤ, ←Prop_Edge_Endᵤ];
                                            rewrite [prop_incomingᵤ₀] at prop_mem_incomingᵤ₀;
                                            cases prop_mem_incomingᵤ₀ with | head _ => simp only [get_rule.direct.loop];
                                                                                       simp_arith;
                                                                           | tail _ mem_cases => trivial; );
                       /- Indirect Edges -/------------------------------------------------------------------------------------------------------------------------------
                       exact prop_indirectᵤ₁; );
  /- type0_hypothesis U1 → type2_hypothesis U1 -/
  intro prop_typeᵤ₁;
  simp only [get_rule] at prop_typeᵤ₁;
  simp only [type0_hypothesis] at prop_typeᵤ₁;
  cases prop_typeᵤ₁ with | intro prop_nbrᵤ₁ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro prop_lvlᵤ₁ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro prop_hptᵤ₁ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro prop_colᵤ₁ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro prop_pstᵤ₁ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro out_nbrᵤ₁ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro out_fmlᵤ₁ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro prop_out_nbrᵤ₁ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro prop_incomingᵤ₁ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro prop_outgoingᵤ₁ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro prop_directᵤ₁ prop_indirectᵤ₁ =>
  --
  simp only [type2_hypothesis];
  apply And.intro ( by exact prop_nbrᵤ₁; );
  apply And.intro ( by exact prop_lvlᵤ₁; );
  apply And.intro ( by exact prop_hptᵤ₁; );
  apply And.intro ( by exact prop_colᵤ₁; );
  apply And.intro ( by exact prop_pstᵤ₁; );
  apply Exists.intro U0.NUMBER;                          /- := out_nbr -/
  apply Exists.intro out_nbrᵤ₀;                          /- := anc_nbr -/
  apply Exists.intro (U0.LEVEL - 1);                     /- := anc_lvl -/
  apply Exists.intro U0.FORMULA;                         /- := out_fml -/
  apply Exists.intro out_fmlᵤ₀;                          /- := anc_fml -/
  apply Exists.intro (U0.HYPOTHESIS || V0.HYPOTHESIS);   /- := out_hpt -/
  apply Exists.intro V0.NUMBER;                          /- := past -/
  apply Exists.intro U0.NUMBER;                          /- := colour -/
  apply Exists.intro U0.PAST;                            /- := pasts -/
  apply Exists.intro [];                                 /- := colours -/
  apply And.intro ( by exact prop_nbrᵤ₀; );                               /- := out_nbr > 0 -/
  apply And.intro ( by exact prop_out_nbrᵤ₀; );                           /- := anc_nbr > 0 -/
  apply And.intro ( by rewrite [Prop_Upper_LVLᵤ];                         /- := anc_lvl + List.length (0::colour::colours) = RULE.CENTER.LEVEL -/
                       simp only [List.length];
                       simp only [Nat.zero_add, ←Nat.add_assoc];
                       simp only [Nat.sub_add_cancel prop_lvlᵤ₀]; );
  apply And.intro ( by exact List.Mem.head (V0.NUMBER :: U0.PAST); );     /- := colour ∈ (out_nbr::past::pasts) -/
  apply And.intro ( by rewrite [prop_pstᵤ₀];                              /- := check_numbers (past::pasts) -/
                       exact COLLAPSE.Check_Numbers_Unit prop_nbrᵥ₀; );
  apply And.intro ( by exact COLLAPSE.Check_Numbers_Unit prop_nbrᵤ₀; );   /- := check_numbers (colour::colours) -/
  /- Incoming Edges -/------------------------------------------------------------------------------------------------------------------------------
  apply And.intro ( by exact prop_incomingᵤ₁; );
  /- Outgoing Edges -/------------------------------------------------------------------------------------------------------------------------------
  apply And.intro ( by simp only [prop_outgoingᵤ₁];
                       simp only [is_collapse.update_edges_end];
                       simp only [is_collapse.update_edges_end.loop];
                       simp only [collapse.center];
                       rewrite [←Prop_Edge_Startᵤ, ←Prop_Edge_Endᵤ];
                       rewrite [prop_outgoingᵤ₁] at prop_mem_outgoingᵤ₁;
                       cases prop_mem_outgoingᵤ₁ with | head _ => simp only [List.cons.injEq, ite_true];
                                                      | tail _ mem_cases => trivial; );
  /- Direct Edges -/--------------------------------------------------------------------------------------------------------------------------------
  apply And.intro ( by simp only [prop_incomingᵤ₀, prop_outgoingᵤ₀, prop_directᵤ₀];
                       simp only [pre_collapse.indirect, prop_hptᵤ₀];
                       simp only [pre_collapse.indirect.create];
                       rewrite [←Prop_Edge_Startᵤ, ←Prop_Edge_Endᵤ];
                       rewrite [prop_incomingᵤ₀] at prop_mem_incomingᵤ₀;
                       cases prop_mem_incomingᵤ₀ with | head _ => simp only [get_rule.direct.loop];
                                                                  simp_arith;
                                                      | tail _ mem_cases => trivial; );
  /- Indirect Edges -/------------------------------------------------------------------------------------------------------------------------------
  exact prop_indirectᵤ₁;

  /- Lemma: Collapse Moves Towards Unique Premise -/
  theorem Above_Right_T0I {U0 V0 V1 : Vertex} {DLDS : Graph} :
    ( CLPS.is_collapse U0 V0 DLDS ) →
    ( U0.LEVEL = V0.LEVEL ) → ( U0.FORMULA = V0.FORMULA ) →
    ( U0.NUMBER > 0 ) → ( check_numbers (U0.NUMBER::U0.PAST) ) →
    ( type0_introduction (get_rule V0 DLDS) ) →
    ( ∃(edge : Deduction), ( edge ∈ get_rule.outgoing V1 DLDS )
                         ∧ ( edge ∈ get_rule.incoming V0 DLDS ) ) →
    ------------------------------------------------------
    ( V1.LEVEL = V0.LEVEL + 1 )
  ∧ ( type0_elimination (get_rule V1 DLDS) → type2_elimination (get_rule V1 CLPS) )
  ∧ ( type0_introduction (get_rule V1 DLDS) → type2_introduction (get_rule V1 CLPS) )
  ∧ ( type0_hypothesis (get_rule V1 DLDS) → type2_hypothesis (get_rule V1 CLPS) ) := by
  intro prop_collapse;
  --
  intro prop_eq_lvl prop_eq_fml;
  --
  intro prop_nbrᵤ₀ prop_pstᵤ₀;
  --
  intro prop_typeᵥ₀;
  simp only [get_rule] at prop_typeᵥ₀;
  simp only [type0_introduction] at prop_typeᵥ₀;
  cases prop_typeᵥ₀ with | intro prop_nbrᵥ₀ prop_typeᵥ₀ =>
  cases prop_typeᵥ₀ with | intro prop_lvlᵥ₀ prop_typeᵥ₀ =>
  cases prop_typeᵥ₀ with | intro prop_hptᵥ₀ prop_typeᵥ₀ =>
  cases prop_typeᵥ₀ with | intro prop_colᵥ₀ prop_typeᵥ₀ =>
  cases prop_typeᵥ₀ with | intro prop_pstᵥ₀ prop_typeᵥ₀ =>
  cases prop_typeᵥ₀ with | intro inc_nbrᵥ₀ prop_typeᵥ₀ =>
  cases prop_typeᵥ₀ with | intro out_nbrᵥ₀ prop_typeᵥ₀ =>
  cases prop_typeᵥ₀ with | intro antecedentᵥ₀ prop_typeᵥ₀ =>
  cases prop_typeᵥ₀ with | intro consequentᵥ₀ prop_typeᵥ₀ =>
  cases prop_typeᵥ₀ with | intro out_fmlᵥ₀ prop_typeᵥ₀ =>
  cases prop_typeᵥ₀ with | intro inc_depᵥ₀ prop_typeᵥ₀ =>
  cases prop_typeᵥ₀ with | intro prop_fmlᵥ₀ prop_typeᵥ₀ =>
  cases prop_typeᵥ₀ with | intro prop_inc_nbrᵥ₀ prop_typeᵥ₀ =>
  cases prop_typeᵥ₀ with | intro prop_out_nbrᵥ₀ prop_typeᵥ₀ =>
  cases prop_typeᵥ₀ with | intro prop_incomingᵥ₀ prop_typeᵥ₀ =>
  cases prop_typeᵥ₀ with | intro prop_outgoingᵥ₀ prop_typeᵥ₀ =>
  cases prop_typeᵥ₀ with | intro prop_directᵥ₀ prop_indirectᵥ₀ =>
  --
  intro prop_incomingᵥ₀;
  cases prop_incomingᵥ₀ with | intro edge prop_incomingᵥ₀ =>
  cases prop_incomingᵥ₀ with | intro prop_mem_outgoingᵥ₁ prop_mem_incomingᵥ₀ =>
  /- U1.LEVEL = U0.LEVEL + 1 -/
  have Prop_Edge_Startᵥ : edge.START = V1 := COLLAPSE.Simp_Start_Outgoing prop_mem_outgoingᵥ₁;
  have Prop_Edge_Endᵥ : edge.END = V0 := COLLAPSE.Simp_End_Incoming prop_mem_incomingᵥ₀;
  have Prop_Upper_LVLᵥ : V1.LEVEL = V0.LEVEL + 1 := by rewrite [←Prop_Edge_Startᵥ, ←Prop_Edge_Endᵥ];
                                                       rewrite [prop_incomingᵥ₀] at prop_mem_incomingᵥ₀;
                                                       cases prop_mem_incomingᵥ₀ with | head _ => trivial;
                                                                                      | tail _ mem_cases => trivial;
  apply And.intro ( by exact Prop_Upper_LVLᵥ; );
  /- Unfold "get_rule U1 CLPS" -/
  rewrite [←Prop_Edge_Startᵥ];
  rewrite [COLLAPSE.Simp_Rule_Above_Right prop_collapse prop_mem_incomingᵥ₀];
  rewrite [Prop_Edge_Startᵥ];
  /- type0_elimination V1 → type2_elimination V1 -/
  apply And.intro ( by intro prop_typeᵥ₁;
                       simp only [get_rule] at prop_typeᵥ₁;
                       simp only [type0_elimination] at prop_typeᵥ₁;
                       cases prop_typeᵥ₁ with | intro prop_nbrᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro prop_lvlᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro prop_hptᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro prop_colᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro prop_pstᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro inc_nbrᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro out_nbrᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro antecedentᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro out_fmlᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro major_hptᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro minor_hptᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro major_depᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro minor_depᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro prop_inc_nbrᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro prop_out_nbrᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro prop_incomingᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro prop_outgoingᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro prop_directᵥ₁ prop_indirectᵥ₁ =>
                       --
                       simp only [type2_elimination];
                       apply And.intro ( by exact prop_nbrᵥ₁; );
                       apply And.intro ( by exact prop_lvlᵥ₁; );
                       apply And.intro ( by exact prop_hptᵥ₁; );
                       apply And.intro ( by exact prop_colᵥ₁; );
                       apply And.intro ( by exact prop_pstᵥ₁; );
                       apply Exists.intro inc_nbrᵥ₁;                          /- := inc_nbr -/
                       apply Exists.intro U0.NUMBER;                          /- := out_nbr -/
                       apply Exists.intro out_nbrᵥ₀;                          /- := anc_nbr -/
                       apply Exists.intro (V0.LEVEL - 1);                     /- := anc_lvl -/
                       apply Exists.intro antecedentᵥ₁;                       /- := antecedent -/
                       apply Exists.intro V0.FORMULA;                         /- := out_fml -/
                       apply Exists.intro out_fmlᵥ₀;                          /- := anc_fml -/
                       apply Exists.intro major_hptᵥ₁;                        /- := major_hpt -/
                       apply Exists.intro minor_hptᵥ₁;                        /- := minor_hpt -/
                       apply Exists.intro (U0.HYPOTHESIS || V0.HYPOTHESIS);   /- := out_hpt -/
                       apply Exists.intro major_depᵥ₁;                        /- := major_dep -/
                       apply Exists.intro minor_depᵥ₁;                        /- := minor_dep -/
                       apply Exists.intro V0.NUMBER;                          /- := past -/
                       apply Exists.intro V0.NUMBER;                          /- := colour -/
                       apply Exists.intro U0.PAST;                            /- := pasts -/
                       apply Exists.intro [];                                 /- := colours -/
                       apply And.intro ( by exact prop_inc_nbrᵥ₁; );                                    /- := inc_nbr > 0 -/
                       apply And.intro ( by exact prop_nbrᵤ₀; );                                        /- := out_nbr > 0 -/
                       apply And.intro ( by exact prop_out_nbrᵥ₀; );                                    /- := anc_nbr > 0 -/
                       apply And.intro ( by rewrite [Prop_Upper_LVLᵥ];                                  /- := anc_lvl + List.length (0::colour::colours) = RULE.CENTER.LEVEL -/
                                            simp only [List.length];
                                            simp only [Nat.zero_add, ←Nat.add_assoc];
                                            simp only [Nat.sub_add_cancel prop_lvlᵥ₀]; );
                       apply And.intro ( by exact List.Mem.tail U0.NUMBER (List.Mem.head U0.PAST); );   /- := colour ∈ (out_nbr::past::pasts) -/
                       apply And.intro ( by simp only [check_numbers] at prop_pstᵤ₀ ⊢;                  /- := check_numbers (past::pasts) -/
                                            apply And.intro ( by simp only [ne_eq, List.cons.injEq]; trivial; );
                                            cases prop_pstᵤ₀ with | intro _ prop_pstᵤ₀ =>
                                            intro nbr mem_cases;
                                            cases mem_cases with
                                            | head => exact prop_nbrᵥ₀;
                                            | tail _ mem_cases => exact prop_pstᵤ₀ (List.Mem.tail U0.NUMBER mem_cases); );
                       apply And.intro ( by exact COLLAPSE.Check_Numbers_Unit prop_nbrᵥ₀; );            /- := check_numbers (colour::colours) -/
                       /- Incoming Edges -/------------------------------------------------------------------------------------------------------------------------------
                       apply And.intro ( by exact prop_incomingᵥ₁; );
                       /- Outgoing Edges -/------------------------------------------------------------------------------------------------------------------------------
                       apply And.intro ( by simp only [prop_outgoingᵥ₁];
                                            simp only [is_collapse.update_edges_end];
                                            simp only [is_collapse.update_edges_end.loop];
                                            simp only [collapse.center];
                                            rewrite [prop_eq_lvl, prop_eq_fml];
                                            rewrite [←Prop_Edge_Startᵥ, ←Prop_Edge_Endᵥ];
                                            rewrite [prop_outgoingᵥ₁] at prop_mem_outgoingᵥ₁;
                                            cases prop_mem_outgoingᵥ₁ with | head _ => simp only [List.cons.injEq, ite_true];
                                                                           | tail _ mem_cases => trivial; );
                       /- Direct Paths -/--------------------------------------------------------------------------------------------------------------------------------
                       apply And.intro ( by simp only [prop_incomingᵥ₀, prop_outgoingᵥ₀, prop_directᵥ₀];
                                            simp only [pre_collapse.indirect, prop_hptᵥ₀];
                                            simp only [pre_collapse.indirect.create];
                                            rewrite [←Prop_Edge_Startᵥ, ←Prop_Edge_Endᵥ];
                                            rewrite [prop_incomingᵥ₀] at prop_mem_incomingᵥ₀;
                                            cases prop_mem_incomingᵥ₀ with | head _ => simp only [get_rule.direct.loop];
                                                                                       simp_arith;
                                                                           | tail _ mem_cases => trivial; );
                       /- Indirect Paths -/------------------------------------------------------------------------------------------------------------------------------
                       exact prop_indirectᵥ₁; );
  /- type0_introduction V1 → type2_introduction V1 -/
  apply And.intro ( by intro prop_typeᵥ₁;
                       simp only [get_rule] at prop_typeᵥ₁;
                       simp only [type0_introduction] at prop_typeᵥ₁;
                       cases prop_typeᵥ₁ with | intro prop_nbrᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro prop_lvlᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro prop_hptᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro prop_colᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro prop_pstᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro inc_nbrᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro out_nbrᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro antecedentᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro consequentᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro out_fmlᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro inc_depᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro prop_fmlᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro prop_inc_nbrᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro prop_out_nbrᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro prop_incomingᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro prop_outgoingᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro prop_directᵥ₁ prop_indirectᵥ₁ =>
                       --
                       simp only [type2_introduction];
                       apply And.intro ( by exact prop_nbrᵥ₁; );
                       apply And.intro ( by exact prop_lvlᵥ₁; );
                       apply And.intro ( by exact prop_hptᵥ₁; );
                       apply And.intro ( by exact prop_colᵥ₁; );
                       apply And.intro ( by exact prop_pstᵥ₁; );
                       apply Exists.intro inc_nbrᵥ₁;                          /- := inc_nbr -/
                       apply Exists.intro U0.NUMBER;                          /- := out_nbr -/
                       apply Exists.intro out_nbrᵥ₀;                          /- := anc_nbr -/
                       apply Exists.intro (V0.LEVEL - 1);                     /- := anc_lvl -/
                       apply Exists.intro antecedentᵥ₁;                       /- := antecedent -/
                       apply Exists.intro consequentᵥ₁;                       /- := consequent -/
                       apply Exists.intro V0.FORMULA;                         /- := out_fml -/
                       apply Exists.intro out_fmlᵥ₀;                          /- := anc_fml -/
                       apply Exists.intro (U0.HYPOTHESIS || V0.HYPOTHESIS);   /- := out_hpt -/
                       apply Exists.intro inc_depᵥ₁;                          /- := inc_dep -/
                       apply Exists.intro V0.NUMBER;                          /- := past -/
                       apply Exists.intro V0.NUMBER;                          /- := colour -/
                       apply Exists.intro U0.PAST;                            /- := pasts -/
                       apply Exists.intro [];                                 /- := colours -/
                       apply And.intro ( by exact prop_fmlᵥ₁; );                                        /- := RULE.CENTER.FORMULA = antecedent>>consequent -/
                       apply And.intro ( by exact prop_inc_nbrᵥ₁; );                                    /- := inc_nbr > 0 -/
                       apply And.intro ( by exact prop_nbrᵤ₀; );                                        /- := out_nbr > 0 -/
                       apply And.intro ( by exact prop_out_nbrᵥ₀; );                                    /- := anc_nbr > 0 -/
                       apply And.intro ( by rewrite [Prop_Upper_LVLᵥ];                                  /- := anc_lvl + List.length (0::colour::colours) = RULE.CENTER.LEVEL -/
                                            simp only [List.length];
                                            simp only [Nat.zero_add, ←Nat.add_assoc];
                                            simp only [Nat.sub_add_cancel prop_lvlᵥ₀]; );
                       apply And.intro ( by exact List.Mem.tail U0.NUMBER (List.Mem.head U0.PAST); );   /- := colour ∈ (out_nbr::past::pasts) -/
                       apply And.intro ( by simp only [check_numbers] at prop_pstᵤ₀ ⊢;                  /- := check_numbers (past::pasts) -/
                                            apply And.intro ( by simp only [ne_eq, List.cons.injEq]; trivial; );
                                            cases prop_pstᵤ₀ with | intro _ prop_pstᵤ₀ =>
                                            intro nbr mem_cases;
                                            cases mem_cases with
                                            | head => exact prop_nbrᵥ₀;
                                            | tail _ mem_cases => exact prop_pstᵤ₀ (List.Mem.tail U0.NUMBER mem_cases); );
                       apply And.intro ( by exact COLLAPSE.Check_Numbers_Unit prop_nbrᵥ₀; );            /- := check_numbers (colour::colours) -/
                       /- Incoming Edges -/------------------------------------------------------------------------------------------------------------------------------
                       apply And.intro ( by exact prop_incomingᵥ₁; );
                       /- Outgoing Edges -/------------------------------------------------------------------------------------------------------------------------------
                       apply And.intro ( by simp only [prop_outgoingᵥ₁];
                                            simp only [is_collapse.update_edges_end];
                                            simp only [is_collapse.update_edges_end.loop];
                                            simp only [collapse.center];
                                            rewrite [prop_eq_lvl, prop_eq_fml];
                                            rewrite [←Prop_Edge_Startᵥ, ←Prop_Edge_Endᵥ];
                                            rewrite [prop_outgoingᵥ₁] at prop_mem_outgoingᵥ₁;
                                            cases prop_mem_outgoingᵥ₁ with | head _ => simp only [List.cons.injEq, ite_true];
                                                                           | tail _ mem_cases => trivial; );
                       /- Direct Paths -/--------------------------------------------------------------------------------------------------------------------------------
                       apply And.intro ( by simp only [prop_incomingᵥ₀, prop_outgoingᵥ₀, prop_directᵥ₀];
                                            simp only [pre_collapse.indirect, prop_hptᵥ₀];
                                            simp only [pre_collapse.indirect.create];
                                            rewrite [←Prop_Edge_Startᵥ, ←Prop_Edge_Endᵥ];
                                            rewrite [prop_incomingᵥ₀] at prop_mem_incomingᵥ₀;
                                            cases prop_mem_incomingᵥ₀ with | head _ => simp only [get_rule.direct.loop];
                                                                                       simp_arith;
                                                                           | tail _ mem_cases => trivial; );
                       /- Indirect Paths -/------------------------------------------------------------------------------------------------------------------------------
                       exact prop_indirectᵥ₁; );
  /- type0_hypothesis V1 → type2_hypothesis V1 -/
  intro prop_typeᵥ₁;
  simp only [get_rule] at prop_typeᵥ₁;
  simp only [type0_hypothesis] at prop_typeᵥ₁;
  cases prop_typeᵥ₁ with | intro prop_nbrᵥ₁ prop_typeᵥ₁ =>
  cases prop_typeᵥ₁ with | intro prop_lvlᵥ₁ prop_typeᵥ₁ =>
  cases prop_typeᵥ₁ with | intro prop_hptᵥ₁ prop_typeᵥ₁ =>
  cases prop_typeᵥ₁ with | intro prop_colᵥ₁ prop_typeᵥ₁ =>
  cases prop_typeᵥ₁ with | intro prop_pstᵥ₁ prop_typeᵥ₁ =>
  cases prop_typeᵥ₁ with | intro out_nbrᵥ₁ prop_typeᵥ₁ =>
  cases prop_typeᵥ₁ with | intro out_fmlᵥ₁ prop_typeᵥ₁ =>
  cases prop_typeᵥ₁ with | intro prop_out_nbrᵥ₁ prop_typeᵥ₁ =>
  cases prop_typeᵥ₁ with | intro prop_incomingᵥ₁ prop_typeᵥ₁ =>
  cases prop_typeᵥ₁ with | intro prop_outgoingᵥ₁ prop_typeᵥ₁ =>
  cases prop_typeᵥ₁ with | intro prop_directᵥ₁ prop_indirectᵥ₁ =>
  --
  simp only [type2_hypothesis];
  apply And.intro ( by exact prop_nbrᵥ₁; );
  apply And.intro ( by exact prop_lvlᵥ₁; );
  apply And.intro ( by exact prop_hptᵥ₁; );
  apply And.intro ( by exact prop_colᵥ₁; );
  apply And.intro ( by exact prop_pstᵥ₁; );
  apply Exists.intro U0.NUMBER;                          /- := out_nbr -/
  apply Exists.intro out_nbrᵥ₀;                          /- := anc_nbr -/
  apply Exists.intro (V0.LEVEL - 1);                     /- := anc_lvl -/
  apply Exists.intro V0.FORMULA;                         /- := out_fml -/
  apply Exists.intro out_fmlᵥ₀;                          /- := anc_fml -/
  apply Exists.intro (U0.HYPOTHESIS || V0.HYPOTHESIS);   /- := out_hpt -/
  apply Exists.intro V0.NUMBER;                          /- := past -/
  apply Exists.intro V0.NUMBER;                          /- := colour -/
  apply Exists.intro U0.PAST;                            /- := pasts -/
  apply Exists.intro [];                                 /- := colours -/
  apply And.intro ( by exact prop_nbrᵤ₀; );                                        /- := out_nbr > 0 -/
  apply And.intro ( by exact prop_out_nbrᵥ₀; );                                    /- := anc_nbr > 0 -/
  apply And.intro ( by rewrite [Prop_Upper_LVLᵥ];                                  /- := anc_lvl + List.length (0::colour::colours) = RULE.CENTER.LEVEL -/
                       simp only [List.length];
                       simp only [Nat.zero_add, ←Nat.add_assoc];
                       simp only [Nat.sub_add_cancel prop_lvlᵥ₀]; );
  apply And.intro ( by exact List.Mem.tail U0.NUMBER (List.Mem.head U0.PAST); );   /- := colour ∈ (out_nbr::past::pasts) -/
  apply And.intro ( by simp only [check_numbers] at prop_pstᵤ₀ ⊢;                  /- := check_numbers (past::pasts) -/
                       apply And.intro ( by simp only [ne_eq, List.cons.injEq]; trivial; );
                       cases prop_pstᵤ₀ with | intro _ prop_pstᵤ₀ =>
                       intro nbr mem_cases;
                       cases mem_cases with
                       | head => exact prop_nbrᵥ₀;
                       | tail _ mem_cases => exact prop_pstᵤ₀ (List.Mem.tail U0.NUMBER mem_cases); );
  apply And.intro ( by exact COLLAPSE.Check_Numbers_Unit prop_nbrᵥ₀; );            /- := check_numbers (colour::colours) -/
  /- Incoming Edges -/------------------------------------------------------------------------------------------------------------------------------
  apply And.intro ( by exact prop_incomingᵥ₁; );
  /- Outgoing Edges -/------------------------------------------------------------------------------------------------------------------------------
  apply And.intro ( by simp only [prop_outgoingᵥ₁];
                       simp only [is_collapse.update_edges_end];
                       simp only [is_collapse.update_edges_end.loop];
                       simp only [collapse.center];
                                            rewrite [prop_eq_lvl, prop_eq_fml];
                       rewrite [←Prop_Edge_Startᵥ, ←Prop_Edge_Endᵥ];
                       rewrite [prop_outgoingᵥ₁] at prop_mem_outgoingᵥ₁;
                       cases prop_mem_outgoingᵥ₁ with | head _ => simp only [List.cons.injEq, ite_true];
                                                      | tail _ mem_cases => trivial; );
  /- Direct Paths -/--------------------------------------------------------------------------------------------------------------------------------
  apply And.intro ( by simp only [prop_incomingᵥ₀, prop_outgoingᵥ₀, prop_directᵥ₀];
                       simp only [pre_collapse.indirect, prop_hptᵥ₀];
                       simp only [pre_collapse.indirect.create];
                       rewrite [←Prop_Edge_Startᵥ, ←Prop_Edge_Endᵥ];
                       rewrite [prop_incomingᵥ₀] at prop_mem_incomingᵥ₀;
                       cases prop_mem_incomingᵥ₀ with | head _ => simp only [get_rule.direct.loop];
                                                                  simp_arith;
                                                      | tail _ mem_cases => trivial; );
  /- Indirect Paths -/------------------------------------------------------------------------------------------------------------------------------
  exact prop_indirectᵥ₁;
end COVERAGE.UP.T0I


namespace COVERAGE.UP.T2H
  /- Lemma: Collapse stops at the Top Formulas -/
  theorem Not_Above_T2H {NODE : Vertex} {DLDS : Graph} :
    ( type2_hypothesis (get_rule NODE DLDS) ) →
    ---------------------------
    ( get_rule.incoming NODE DLDS = [] ) := by
  intro prop_type;
  simp only [get_rule] at prop_type;
  simp only [type2_hypothesis] at prop_type;
  cases prop_type with | intro _ prop_type =>
  cases prop_type with | intro _ prop_type =>
  cases prop_type with | intro _ prop_type =>
  cases prop_type with | intro _ prop_type =>
  cases prop_type with | intro _ prop_type =>
  cases prop_type with | intro _ prop_type =>
  cases prop_type with | intro _ prop_type =>
  cases prop_type with | intro _ prop_type =>
  cases prop_type with | intro _ prop_type =>
  cases prop_type with | intro _ prop_type =>
  cases prop_type with | intro _ prop_type =>
  cases prop_type with | intro _ prop_type =>
  cases prop_type with | intro _ prop_type =>
  cases prop_type with | intro _ prop_type =>
  cases prop_type with | intro _ prop_type =>
  cases prop_type with | intro _ prop_type =>
  cases prop_type with | intro _ prop_type =>
  cases prop_type with | intro _ prop_type =>
  cases prop_type with | intro _ prop_type =>
  cases prop_type with | intro _ prop_type =>
  cases prop_type with | intro _ prop_type =>
  cases prop_type with | intro prop_incoming _ =>
  exact prop_incoming;
end COVERAGE.UP.T2H

namespace COVERAGE.UP.T2E
  /- Lemma: Restrictions on Upper Nodes -/
  theorem Not_Above_T2E {U0 U1 : Vertex} {DLDS : Graph} :
    ( type2_elimination (get_rule U0 DLDS) ) →
    ( ∃(edge : Deduction), ( edge ∈ get_rule.outgoing U1 DLDS )
                         ∧ ( edge ∈ get_rule.incoming U0 DLDS ) ) →
    ------------------------------------------------------
    ( ¬type2_elimination (get_rule U1 DLDS) )
  ∧ ( ¬type2_introduction (get_rule U1 DLDS) )
  ∧ ( ¬type2_hypothesis (get_rule U1 DLDS) ) := by
  intro prop_typeᵤ₀;
  simp only [get_rule] at prop_typeᵤ₀;
  simp only [type2_elimination] at prop_typeᵤ₀;
  cases prop_typeᵤ₀ with | intro prop_nbrᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_lvlᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_hptᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_colᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_pstᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro inc_nbrᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro out_nbrᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro anc_nbrᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro anc_lvlᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro antecedentᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro out_fmlᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro anc_fmlᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro major_hptᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro minor_hptᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro out_hptᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro major_depᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro minor_depᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro pastᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro colourᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro pastsᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro coloursᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_inc_nbrᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_out_nbrᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_anc_nbrᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_anc_lvlᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_colourᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_pastsᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_coloursᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_incomingᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_outgoingᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_directᵤ₀ prop_indirectᵤ₀ =>
  --
  intro prop_incomingᵤ₀;
  cases prop_incomingᵤ₀ with | intro edge prop_incomingᵤ₀ =>
  cases prop_incomingᵤ₀ with | intro prop_mem_outgoingᵤ₁ prop_mem_incomingᵤ₀ =>
  have Prop_Edge_Startᵤ : edge.START = U1 := COLLAPSE.Simp_Start_Outgoing prop_mem_outgoingᵤ₁;
  --
  have Prop_Directᵤ₁ := COLLAPSE.Simp_Direct_Indirect₀₂ prop_mem_incomingᵤ₀ prop_indirectᵤ₀;
  rewrite [Prop_Edge_Startᵤ] at Prop_Directᵤ₁;
  /- ¬type2_elimination U1 -/
  apply And.intro ( by rewrite [←imp_false];
                       intro prop_typeᵤ₁;
                       apply absurd Prop_Directᵤ₁;
                       simp only [get_rule] at prop_typeᵤ₁;
                       simp only [type2_elimination] at prop_typeᵤ₁;
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_directᵤ₁ _ =>
                       rewrite [prop_directᵤ₁];
                       simp only [List.cons.injEq];
                       trivial; );
  /- ¬type2_hypothesis U1 -/
  /- ¬type2_introduction U1 -/
  apply And.intro ( by rewrite [←imp_false];
                       intro prop_typeᵤ₁;
                       apply absurd Prop_Directᵤ₁;
                       simp only [get_rule] at prop_typeᵤ₁;
                       simp only [type2_introduction] at prop_typeᵤ₁;
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_directᵤ₁ _ =>
                       rewrite [prop_directᵤ₁];
                       simp only [List.cons.injEq];
                       trivial; );
  /- ¬type2_hypothesis U1 -/
  rewrite [←imp_false];
  intro prop_typeᵤ₁;
  apply absurd Prop_Directᵤ₁;
  simp only [get_rule] at prop_typeᵤ₁;
  simp only [type2_hypothesis] at prop_typeᵤ₁;
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro prop_directᵤ₁ _ =>
  rewrite [prop_directᵤ₁];
  simp only [List.cons.injEq];
  trivial;

  /- Lemma: Collapse Moves Towards Minor & Major Premises -/
  theorem Above_Left_T2E {U0 V0 U1 : Vertex} {DLDS : Graph} :
    ( CLPS.is_collapse U0 V0 DLDS ) →
    ( type2_elimination (get_rule U0 DLDS) ) →
    ( V0.NUMBER > 0 ) →
    ( ∃(edge : Deduction), ( edge ∈ get_rule.outgoing U1 DLDS )
                         ∧ ( edge ∈ get_rule.incoming U0 DLDS ) ) →
    ------------------------------------------------------
    ( U1.LEVEL = U0.LEVEL + 1 )
  ∧ ( type0_elimination (get_rule U1 DLDS) → type2_elimination (get_rule U1 CLPS) )
  ∧ ( type0_introduction (get_rule U1 DLDS) → type2_introduction (get_rule U1 CLPS) )
  ∧ ( type0_hypothesis (get_rule U1 DLDS) → type2_hypothesis (get_rule U1 CLPS) ) := by
  intro prop_collapse;
  --
  intro prop_typeᵤ₀;
  simp only [get_rule] at prop_typeᵤ₀;
  simp only [type2_elimination] at prop_typeᵤ₀;
  cases prop_typeᵤ₀ with | intro prop_nbrᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_lvlᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_hptᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_colᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_pstᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro inc_nbrᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro out_nbrᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro anc_nbrᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro anc_lvlᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro antecedentᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro out_fmlᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro anc_fmlᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro major_hptᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro minor_hptᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro out_hptᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro major_depᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro minor_depᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro pastᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro colourᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro pastsᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro coloursᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_inc_nbrᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_out_nbrᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_anc_nbrᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_anc_lvlᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_colourᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_pastsᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_coloursᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_incomingᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_outgoingᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_directᵤ₀ prop_indirectᵤ₀ =>
  --
  intro  prop_nbrᵥ₀;
  --
  intro prop_incomingᵤ₀;
  cases prop_incomingᵤ₀ with | intro edge prop_incomingᵤ₀ =>
  cases prop_incomingᵤ₀ with | intro prop_mem_outgoingᵤ₁ prop_mem_incomingᵤ₀ =>
  /- U1.LEVEL = U0.LEVEL + 1 -/
  have Prop_Edge_Startᵤ : edge.START = U1 := COLLAPSE.Simp_Start_Outgoing prop_mem_outgoingᵤ₁;
  have Prop_Edge_Endᵤ : edge.END = U0 := COLLAPSE.Simp_End_Incoming prop_mem_incomingᵤ₀;
  have Prop_Upper_LVLᵤ : U1.LEVEL = U0.LEVEL + 1 := by rewrite [←Prop_Edge_Startᵤ, ←Prop_Edge_Endᵤ];
                                                       rewrite [prop_incomingᵤ₀] at prop_mem_incomingᵤ₀;
                                                       cases prop_mem_incomingᵤ₀ with | head _ => trivial;
                                                                                      | tail _ mem_cases => cases mem_cases with
                                                                                                            | head _ => trivial;
                                                                                                            | tail _ mem_cases => trivial;
  apply And.intro ( by exact Prop_Upper_LVLᵤ; );
  /- Unfold "get_rule U1 CLPS" -/
  rewrite [←Prop_Edge_Startᵤ];
  rewrite [COLLAPSE.Simp_Rule_Above_Left prop_colᵤ₀ prop_collapse prop_mem_incomingᵤ₀];
  rewrite [Prop_Edge_Startᵤ];
  /- type0_elimination U1 → type2_elimination U1 -/
  apply And.intro ( by intro prop_typeᵤ₁;
                       simp only [get_rule] at prop_typeᵤ₁;
                       simp only [type0_elimination] at prop_typeᵤ₁;
                       cases prop_typeᵤ₁ with | intro prop_nbrᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_lvlᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_hptᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_colᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_pstᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro inc_nbrᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro out_nbrᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro antecedentᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro out_fmlᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro major_hptᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro minor_hptᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro major_depᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro minor_depᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_inc_nbrᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_out_nbrᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_incomingᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_outgoingᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_directᵤ₁ prop_indirectᵤ₁ =>
                       --
                       simp only [type2_elimination];
                       apply And.intro ( by exact prop_nbrᵤ₁; );              /- := RULE.CENTER.NUMBER > 0 -/
                       apply And.intro ( by exact prop_lvlᵤ₁; );              /- := RULE.CENTER.LEVEL > 0 -/
                       apply And.intro ( by exact prop_hptᵤ₁; );              /- := RULE.CENTER.HYPOTHESIS = false -/
                       apply And.intro ( by exact prop_colᵤ₁; );              /- := RULE.CENTER.COLLAPSED = false -/
                       apply And.intro ( by exact prop_pstᵤ₁; );              /- := RULE.CENTER.PAST = [] -/
                       apply Exists.intro inc_nbrᵤ₁;                          /- := inc_nbr -/
                       apply Exists.intro U0.NUMBER;                          /- := out_nbr -/
                       apply Exists.intro anc_nbrᵤ₀;                          /- := anc_nbr -/
                       apply Exists.intro anc_lvlᵤ₀;                          /- := anc_lvl -/
                       apply Exists.intro antecedentᵤ₁;                       /- := antecedent -/
                       apply Exists.intro U0.FORMULA;                         /- := out_fml -/
                       apply Exists.intro anc_fmlᵤ₀;                          /- := anc_fml -/
                       apply Exists.intro major_hptᵤ₁;                        /- := major_hpt -/
                       apply Exists.intro minor_hptᵤ₁;                        /- := minor_hpt -/
                       apply Exists.intro (U0.HYPOTHESIS || V0.HYPOTHESIS);   /- := out_hpt -/
                       apply Exists.intro major_depᵤ₁;                        /- := major_dep -/
                       apply Exists.intro minor_depᵤ₁;                        /- := minor_dep -/
                       apply Exists.intro V0.NUMBER;                          /- := past -/
                       apply Exists.intro U0.NUMBER;                          /- := colour -/
                       apply Exists.intro U0.PAST;                            /- := pasts -/
                       apply Exists.intro (colourᵤ₀ :: coloursᵤ₀);            /- := colours -/
                       apply And.intro ( by exact prop_inc_nbrᵤ₁; );                           /- := inc_nbr > 0 -/
                       apply And.intro ( by exact prop_nbrᵤ₀; );                               /- := out_nbr > 0 -/
                       apply And.intro ( by exact prop_anc_nbrᵤ₀; );                           /- := anc_nbr > 0 -/
                       apply And.intro ( by rewrite [Prop_Upper_LVLᵤ];                         /- := anc_lvl + List.length (0::colour::colours) = RULE.CENTER.LEVEL -/
                                            rewrite [←prop_anc_lvlᵤ₀];
                                            simp only [List.length, Nat.add_assoc]; );
                       apply And.intro ( by exact List.Mem.head (V0.NUMBER :: U0.PAST); );                    /- := colour ∈ (out_nbr::past::pasts) -/
                       apply And.intro ( by rewrite [prop_pstᵤ₀];                                             /- := check_numbers (past::pasts) -/
                                            exact COLLAPSE.Check_Numbers_Unit prop_nbrᵥ₀; );
                       apply And.intro ( by exact COLLAPSE.Check_Numbers_Cons prop_nbrᵤ₀ prop_coloursᵤ₀; );   /- := check_numbers (colour::colours) -/
                       /- Incoming Edges -/------------------------------------------------------------------------------------------------------------------------------
                       apply And.intro ( by exact prop_incomingᵤ₁; );
                       /- Outgoing Edges -/------------------------------------------------------------------------------------------------------------------------------
                       apply And.intro ( by simp only [prop_outgoingᵤ₁];
                                            simp only [is_collapse.update_edges_end];
                                            simp only [is_collapse.update_edges_end.loop];
                                            simp only [collapse.center];
                                            rewrite [←Prop_Edge_Startᵤ, ←Prop_Edge_Endᵤ];
                                            rewrite [prop_outgoingᵤ₁] at prop_mem_outgoingᵤ₁;
                                            cases prop_mem_outgoingᵤ₁ with | head _ => simp only [List.cons.injEq, ite_true];
                                                                           | tail _ mem_cases => trivial; );
                       /- Direct Edges -/--------------------------------------------------------------------------------------------------------------------------------
                       apply And.intro ( by simp only [prop_incomingᵤ₀, prop_outgoingᵤ₀, prop_directᵤ₀];
                                            simp only [pre_collapse.indirect, prop_hptᵤ₀];
                                            simp only [pre_collapse.indirect.move_up];
                                            rewrite [←Prop_Edge_Startᵤ, ←Prop_Edge_Endᵤ];
                                            rewrite [prop_incomingᵤ₀] at prop_mem_incomingᵤ₀;
                                            cases prop_mem_incomingᵤ₀ with | head _ => simp only [get_rule.direct.loop];
                                                                                       simp_arith;
                                                                           | tail _ mem_cases => cases mem_cases with
                                                                                                 | head _ => simp only [get_rule.direct.loop];
                                                                                                             simp_arith;
                                                                                                 | tail _ mem_cases => trivial; );
                       /- Indirect Edges -/------------------------------------------------------------------------------------------------------------------------------
                       exact prop_indirectᵤ₁; );
  /- type0_introduction U1 → type2_introduction U1 -/
  apply And.intro ( by intro prop_typeᵤ₁;
                       simp only [get_rule] at prop_typeᵤ₁;
                       simp only [type0_introduction] at prop_typeᵤ₁;
                       cases prop_typeᵤ₁ with | intro prop_nbrᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_lvlᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_hptᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_colᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_pstᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro inc_nbrᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro out_nbrᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro antecedentᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro consequentᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro out_fmlᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro inc_depᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_fmlᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_inc_nbrᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_out_nbrᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_incomingᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_outgoingᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_directᵤ₁ prop_indirectᵤ₁ =>
                       --
                       simp only [type2_introduction];
                       apply And.intro ( by exact prop_nbrᵤ₁; );
                       apply And.intro ( by exact prop_lvlᵤ₁; );
                       apply And.intro ( by exact prop_hptᵤ₁; );
                       apply And.intro ( by exact prop_colᵤ₁; );
                       apply And.intro ( by exact prop_pstᵤ₁; );
                       apply Exists.intro inc_nbrᵤ₁;                          /- := inc_nbr -/
                       apply Exists.intro U0.NUMBER;                          /- := out_nbr -/
                       apply Exists.intro anc_nbrᵤ₀;                          /- := anc_nbr -/
                       apply Exists.intro anc_lvlᵤ₀;                          /- := anc_lvl -/
                       apply Exists.intro antecedentᵤ₁;                       /- := antecedent -/
                       apply Exists.intro consequentᵤ₁;                       /- := consequent -/
                       apply Exists.intro U0.FORMULA;                         /- := out_fml -/
                       apply Exists.intro anc_fmlᵤ₀;                          /- := anc_fml -/
                       apply Exists.intro (U0.HYPOTHESIS || V0.HYPOTHESIS);   /- := out_hpt -/
                       apply Exists.intro inc_depᵤ₁;                          /- := inc_dep -/
                       apply Exists.intro V0.NUMBER;                          /- := past -/
                       apply Exists.intro U0.NUMBER;                          /- := colour -/
                       apply Exists.intro U0.PAST;                            /- := pasts -/
                       apply Exists.intro (colourᵤ₀ :: coloursᵤ₀);            /- := colours -/
                       apply And.intro ( by exact prop_fmlᵤ₁; );                               /- := RULE.CENTER.FORMULA = antecedent>>consequent -/
                       apply And.intro ( by exact prop_inc_nbrᵤ₁; );                           /- := inc_nbr > 0 -/
                       apply And.intro ( by exact prop_nbrᵤ₀; );                               /- := out_nbr > 0 -/
                       apply And.intro ( by exact prop_anc_nbrᵤ₀; );                           /- := anc_nbr > 0 -/
                       apply And.intro ( by rewrite [Prop_Upper_LVLᵤ];                         /- := anc_lvl + List.length (0::colour::colours) = RULE.CENTER.LEVEL -/
                                            rewrite [←prop_anc_lvlᵤ₀];
                                            simp only [List.length, Nat.add_assoc]; );
                       apply And.intro ( by exact List.Mem.head (V0.NUMBER :: U0.PAST); );                    /- := colour ∈ (out_nbr::past::pasts) -/
                       apply And.intro ( by rewrite [prop_pstᵤ₀];                                             /- := check_numbers (past::pasts) -/
                                            exact COLLAPSE.Check_Numbers_Unit prop_nbrᵥ₀; );
                       apply And.intro ( by exact COLLAPSE.Check_Numbers_Cons prop_nbrᵤ₀ prop_coloursᵤ₀; );   /- := check_numbers (colour::colours) -/
                       /- Incoming Edges -/------------------------------------------------------------------------------------------------------------------------------
                       apply And.intro ( by exact prop_incomingᵤ₁; );
                       /- Outgoing Edges -/------------------------------------------------------------------------------------------------------------------------------
                       apply And.intro ( by simp only [prop_outgoingᵤ₁];
                                            simp only [is_collapse.update_edges_end];
                                            simp only [is_collapse.update_edges_end.loop];
                                            simp only [collapse.center];
                                            rewrite [←Prop_Edge_Startᵤ, ←Prop_Edge_Endᵤ];
                                            rewrite [prop_outgoingᵤ₁] at prop_mem_outgoingᵤ₁;
                                            cases prop_mem_outgoingᵤ₁ with | head _ => simp only [List.cons.injEq, ite_true];
                                                                           | tail _ mem_cases => trivial; );
                       /- Direct Edges -/--------------------------------------------------------------------------------------------------------------------------------
                       apply And.intro ( by simp only [prop_incomingᵤ₀, prop_outgoingᵤ₀, prop_directᵤ₀];
                                            simp only [pre_collapse.indirect, prop_hptᵤ₀];
                                            simp only [pre_collapse.indirect.move_up];
                                            rewrite [←Prop_Edge_Startᵤ, ←Prop_Edge_Endᵤ];
                                            rewrite [prop_incomingᵤ₀] at prop_mem_incomingᵤ₀;
                                            cases prop_mem_incomingᵤ₀ with | head _ => simp only [get_rule.direct.loop];
                                                                                       simp_arith;
                                                                           | tail _ mem_cases => cases mem_cases with
                                                                                                 | head _ => simp only [get_rule.direct.loop];
                                                                                                             simp_arith;
                                                                                                 | tail _ mem_cases => trivial; );
                       /- Indirect Edges -/------------------------------------------------------------------------------------------------------------------------------
                       exact prop_indirectᵤ₁; );
  /- type0_hypothesis U1 → type2_hypothesis U1 -/
  intro prop_typeᵤ₁;
  simp only [get_rule] at prop_typeᵤ₁;
  simp only [type0_hypothesis] at prop_typeᵤ₁;
  cases prop_typeᵤ₁ with | intro prop_nbrᵤ₁ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro prop_lvlᵤ₁ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro prop_hptᵤ₁ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro prop_colᵤ₁ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro prop_pstᵤ₁ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro out_nbrᵤ₁ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro out_fmlᵤ₁ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro prop_out_nbrᵤ₁ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro prop_incomingᵤ₁ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro prop_outgoingᵤ₁ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro prop_directᵤ₁ prop_indirectᵤ₁ =>
  --
  simp only [type2_hypothesis];
  apply And.intro ( by exact prop_nbrᵤ₁; );
  apply And.intro ( by exact prop_lvlᵤ₁; );
  apply And.intro ( by exact prop_hptᵤ₁; );
  apply And.intro ( by exact prop_colᵤ₁; );
  apply And.intro ( by exact prop_pstᵤ₁; );
  apply Exists.intro U0.NUMBER;                          /- := out_nbr -/
  apply Exists.intro anc_nbrᵤ₀;                          /- := anc_nbr -/
  apply Exists.intro anc_lvlᵤ₀;                          /- := anc_lvl -/
  apply Exists.intro U0.FORMULA;                         /- := out_fml -/
  apply Exists.intro anc_fmlᵤ₀;                          /- := anc_fml -/
  apply Exists.intro (U0.HYPOTHESIS || V0.HYPOTHESIS);   /- := out_hpt -/
  apply Exists.intro V0.NUMBER;                          /- := past -/
  apply Exists.intro U0.NUMBER;                          /- := colour -/
  apply Exists.intro U0.PAST;                            /- := pasts -/
  apply Exists.intro (colourᵤ₀ :: coloursᵤ₀);            /- := colours -/
  apply And.intro ( by exact prop_nbrᵤ₀; );                               /- := out_nbr > 0 -/
  apply And.intro ( by exact prop_anc_nbrᵤ₀; );                           /- := anc_nbr > 0 -/
  apply And.intro ( by rewrite [Prop_Upper_LVLᵤ];                         /- := anc_lvl + List.length (0::colour::colours) = RULE.CENTER.LEVEL -/
                       rewrite [←prop_anc_lvlᵤ₀];
                       simp only [List.length, Nat.add_assoc]; );
  apply And.intro ( by exact List.Mem.head (V0.NUMBER :: U0.PAST); );                    /- := colour ∈ (out_nbr::past::pasts) -/
  apply And.intro ( by rewrite [prop_pstᵤ₀];                                             /- := check_numbers (past::pasts) -/
                       exact COLLAPSE.Check_Numbers_Unit prop_nbrᵥ₀; );
  apply And.intro ( by exact COLLAPSE.Check_Numbers_Cons prop_nbrᵤ₀ prop_coloursᵤ₀; );   /- := check_numbers (colour::colours) -/
  /- Incoming Edges -/------------------------------------------------------------------------------------------------------------------------------
  apply And.intro ( by exact prop_incomingᵤ₁; );
  /- Outgoing Edges -/------------------------------------------------------------------------------------------------------------------------------
  apply And.intro ( by simp only [prop_outgoingᵤ₁];
                       simp only [is_collapse.update_edges_end];
                       simp only [is_collapse.update_edges_end.loop];
                       simp only [collapse.center];
                       rewrite [←Prop_Edge_Startᵤ, ←Prop_Edge_Endᵤ];
                       rewrite [prop_outgoingᵤ₁] at prop_mem_outgoingᵤ₁;
                       cases prop_mem_outgoingᵤ₁ with | head _ => simp only [List.cons.injEq, ite_true];
                                                      | tail _ mem_cases => trivial; );
  /- Direct Edges -/--------------------------------------------------------------------------------------------------------------------------------
  apply And.intro ( by simp only [prop_incomingᵤ₀, prop_outgoingᵤ₀, prop_directᵤ₀];
                       simp only [pre_collapse.indirect, prop_hptᵤ₀];
                       simp only [pre_collapse.indirect.move_up];
                       rewrite [←Prop_Edge_Startᵤ, ←Prop_Edge_Endᵤ];
                       rewrite [prop_incomingᵤ₀] at prop_mem_incomingᵤ₀;
                       cases prop_mem_incomingᵤ₀ with | head _ => simp only [get_rule.direct.loop];
                                                                  simp_arith;
                                                      | tail _ mem_cases => cases mem_cases with
                                                                            | head _ => simp only [get_rule.direct.loop];
                                                                                        simp_arith;
                                                                            | tail _ mem_cases => trivial; );
  /- Indirect Edges -/------------------------------------------------------------------------------------------------------------------------------
  exact prop_indirectᵤ₁;

  /- Lemma: Collapse Moves Towards Minor & Major Premises -/
  theorem Above_Right_T2E {U0 V0 V1 : Vertex} {DLDS : Graph} :
    ( CLPS.is_collapse U0 V0 DLDS ) →
    ( U0.LEVEL = V0.LEVEL ) → ( U0.FORMULA = V0.FORMULA ) →
    ( U0.NUMBER > 0 ) → ( check_numbers (U0.NUMBER::U0.PAST) ) →
    ( type2_elimination (get_rule V0 DLDS) ) →
    ( ∃(edge : Deduction), ( edge ∈ get_rule.outgoing V1 DLDS )
                         ∧ ( edge ∈ get_rule.incoming V0 DLDS ) ) →
    ------------------------------------------------------
    ( V1.LEVEL = V0.LEVEL + 1 )
  ∧ ( type0_elimination (get_rule V1 DLDS) → type2_elimination (get_rule V1 CLPS) )
  ∧ ( type0_introduction (get_rule V1 DLDS) → type2_introduction (get_rule V1 CLPS) )
  ∧ ( type0_hypothesis (get_rule V1 DLDS) → type2_hypothesis (get_rule V1 CLPS) ) := by
  intro prop_collapse;
  --
  intro prop_eq_lvl prop_eq_fml;
  --
  intro prop_nbrᵤ₀ prop_pstᵤ₀;
  --
  intro prop_typeᵥ₀;
  simp only [get_rule] at prop_typeᵥ₀;
  simp only [type2_elimination] at prop_typeᵥ₀;
  cases prop_typeᵥ₀ with | intro prop_nbrᵥ₀ prop_typeᵥ₀ =>
  cases prop_typeᵥ₀ with | intro prop_lvlᵥ₀ prop_typeᵥ₀ =>
  cases prop_typeᵥ₀ with | intro prop_hptᵥ₀ prop_typeᵥ₀ =>
  cases prop_typeᵥ₀ with | intro prop_colᵥ₀ prop_typeᵥ₀ =>
  cases prop_typeᵥ₀ with | intro prop_pstᵥ₀ prop_typeᵥ₀ =>
  cases prop_typeᵥ₀ with | intro inc_nbrᵥ₀ prop_typeᵥ₀ =>
  cases prop_typeᵥ₀ with | intro out_nbrᵥ₀ prop_typeᵥ₀ =>
  cases prop_typeᵥ₀ with | intro anc_nbrᵥ₀ prop_typeᵥ₀ =>
  cases prop_typeᵥ₀ with | intro anc_lvlᵥ₀ prop_typeᵥ₀ =>
  cases prop_typeᵥ₀ with | intro antecedentᵥ₀ prop_typeᵥ₀ =>
  cases prop_typeᵥ₀ with | intro out_fmlᵥ₀ prop_typeᵥ₀ =>
  cases prop_typeᵥ₀ with | intro anc_fmlᵥ₀ prop_typeᵥ₀ =>
  cases prop_typeᵥ₀ with | intro major_hptᵥ₀ prop_typeᵥ₀ =>
  cases prop_typeᵥ₀ with | intro minor_hptᵥ₀ prop_typeᵥ₀ =>
  cases prop_typeᵥ₀ with | intro out_hptᵥ₀ prop_typeᵥ₀ =>
  cases prop_typeᵥ₀ with | intro major_depᵥ₀ prop_typeᵥ₀ =>
  cases prop_typeᵥ₀ with | intro minor_depᵥ₀ prop_typeᵥ₀ =>
  cases prop_typeᵥ₀ with | intro pastᵥ₀ prop_typeᵥ₀ =>
  cases prop_typeᵥ₀ with | intro colourᵥ₀ prop_typeᵥ₀ =>
  cases prop_typeᵥ₀ with | intro pastsᵥ₀ prop_typeᵥ₀ =>
  cases prop_typeᵥ₀ with | intro coloursᵥ₀ prop_typeᵥ₀ =>
  cases prop_typeᵥ₀ with | intro prop_inc_nbrᵥ₀ prop_typeᵥ₀ =>
  cases prop_typeᵥ₀ with | intro prop_out_nbrᵥ₀ prop_typeᵥ₀ =>
  cases prop_typeᵥ₀ with | intro prop_anc_nbrᵥ₀ prop_typeᵥ₀ =>
  cases prop_typeᵥ₀ with | intro prop_anc_lvlᵥ₀ prop_typeᵥ₀ =>
  cases prop_typeᵥ₀ with | intro prop_colourᵥ₀ prop_typeᵥ₀ =>
  cases prop_typeᵥ₀ with | intro prop_pastsᵥ₀ prop_typeᵥ₀ =>
  cases prop_typeᵥ₀ with | intro prop_coloursᵥ₀ prop_typeᵥ₀ =>
  cases prop_typeᵥ₀ with | intro prop_incomingᵥ₀ prop_typeᵥ₀ =>
  cases prop_typeᵥ₀ with | intro prop_outgoingᵥ₀ prop_typeᵥ₀ =>
  cases prop_typeᵥ₀ with | intro prop_directᵥ₀ prop_indirectᵥ₀ =>
  --
  intro prop_incomingᵥ₀;
  cases prop_incomingᵥ₀ with | intro edge prop_incomingᵥ₀ =>
  cases prop_incomingᵥ₀ with | intro prop_mem_outgoingᵥ₁ prop_mem_incomingᵥ₀ =>
  /- U1.LEVEL = U0.LEVEL + 1 -/
  have Prop_Edge_Startᵥ : edge.START = V1 := COLLAPSE.Simp_Start_Outgoing prop_mem_outgoingᵥ₁;
  have Prop_Edge_Endᵥ : edge.END = V0 := COLLAPSE.Simp_End_Incoming prop_mem_incomingᵥ₀;
  have Prop_Upper_LVLᵥ : V1.LEVEL = V0.LEVEL + 1 := by rewrite [←Prop_Edge_Startᵥ, ←Prop_Edge_Endᵥ];
                                                       rewrite [prop_incomingᵥ₀] at prop_mem_incomingᵥ₀;
                                                       cases prop_mem_incomingᵥ₀ with | head _ => trivial;
                                                                                      | tail _ mem_cases => cases mem_cases with
                                                                                                            | head _ => trivial;
                                                                                                            | tail _ mem_cases => trivial;
  apply And.intro ( by exact Prop_Upper_LVLᵥ; );
  /- Unfold "get_rule U1 CLPS" -/
  rewrite [←Prop_Edge_Startᵥ];
  rewrite [COLLAPSE.Simp_Rule_Above_Right prop_collapse prop_mem_incomingᵥ₀];
  rewrite [Prop_Edge_Startᵥ];
  /- type0_elimination V1 → type2_elimination V1 -/
  apply And.intro ( by intro prop_typeᵥ₁;
                       simp only [get_rule] at prop_typeᵥ₁;
                       simp only [type0_elimination] at prop_typeᵥ₁;
                       cases prop_typeᵥ₁ with | intro prop_nbrᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro prop_lvlᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro prop_hptᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro prop_colᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro prop_pstᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro inc_nbrᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro out_nbrᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro antecedentᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro out_fmlᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro major_hptᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro minor_hptᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro major_depᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro minor_depᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro prop_inc_nbrᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro prop_out_nbrᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro prop_incomingᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro prop_outgoingᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro prop_directᵥ₁ prop_indirectᵥ₁ =>
                       --
                       simp only [type2_elimination];
                       apply And.intro ( by exact prop_nbrᵥ₁; );
                       apply And.intro ( by exact prop_lvlᵥ₁; );
                       apply And.intro ( by exact prop_hptᵥ₁; );
                       apply And.intro ( by exact prop_colᵥ₁; );
                       apply And.intro ( by exact prop_pstᵥ₁; );
                       apply Exists.intro inc_nbrᵥ₁;                          /- := inc_nbr -/
                       apply Exists.intro U0.NUMBER;                          /- := out_nbr -/
                       apply Exists.intro anc_nbrᵥ₀;                          /- := anc_nbr -/
                       apply Exists.intro anc_lvlᵥ₀;                          /- := anc_lvl -/
                       apply Exists.intro antecedentᵥ₁;                       /- := antecedent -/
                       apply Exists.intro V0.FORMULA;                         /- := out_fml -/
                       apply Exists.intro anc_fmlᵥ₀;                          /- := anc_fml -/
                       apply Exists.intro major_hptᵥ₁;                        /- := major_hpt -/
                       apply Exists.intro minor_hptᵥ₁;                        /- := minor_hpt -/
                       apply Exists.intro (U0.HYPOTHESIS || V0.HYPOTHESIS);   /- := out_hpt -/
                       apply Exists.intro major_depᵥ₁;                        /- := major_dep -/
                       apply Exists.intro minor_depᵥ₁;                        /- := minor_dep -/
                       apply Exists.intro V0.NUMBER;                          /- := past -/
                       apply Exists.intro V0.NUMBER;                          /- := colour -/
                       apply Exists.intro U0.PAST;                            /- := pasts -/
                       apply Exists.intro (colourᵥ₀ :: coloursᵥ₀);            /- := colours -/
                       apply And.intro ( by exact prop_inc_nbrᵥ₁; );                                    /- := inc_nbr > 0 -/
                       apply And.intro ( by exact prop_nbrᵤ₀; );                                        /- := out_nbr > 0 -/
                       apply And.intro ( by exact prop_anc_nbrᵥ₀; );                                    /- := anc_nbr > 0 -/
                       apply And.intro ( by rewrite [Prop_Upper_LVLᵥ];                                  /- := anc_lvl + List.length (0::colour::colours) = RULE.CENTER.LEVEL -/
                                            rewrite [←prop_anc_lvlᵥ₀];
                                            simp only [List.length, Nat.add_assoc]; );
                       apply And.intro ( by exact List.Mem.tail U0.NUMBER (List.Mem.head U0.PAST); );                  /- := colour ∈ (out_nbr::past::pasts) -/
                       apply And.intro ( by simp only [check_numbers] at prop_pstᵤ₀ ⊢;                                 /- := check_numbers (past::pasts) -/
                                            apply And.intro ( by simp only [ne_eq, List.cons.injEq]; trivial; );
                                            cases prop_pstᵤ₀ with | intro _ prop_pstᵤ₀ =>
                                            intro nbr mem_cases;
                                            cases mem_cases with
                                            | head => exact prop_nbrᵥ₀;
                                            | tail _ mem_cases => exact prop_pstᵤ₀ (List.Mem.tail U0.NUMBER mem_cases); );
                       apply And.intro ( by exact COLLAPSE.Check_Numbers_Cons prop_nbrᵥ₀ prop_coloursᵥ₀; );            /- := check_numbers (colour::colours) -/
                       /- Incoming Edges -/------------------------------------------------------------------------------------------------------------------------------
                       apply And.intro ( by exact prop_incomingᵥ₁; );
                       /- Outgoing Edges -/------------------------------------------------------------------------------------------------------------------------------
                       apply And.intro ( by simp only [prop_outgoingᵥ₁];
                                            simp only [is_collapse.update_edges_end];
                                            simp only [is_collapse.update_edges_end.loop];
                                            simp only [collapse.center];
                                            rewrite [prop_eq_lvl, prop_eq_fml];
                                            rewrite [←Prop_Edge_Startᵥ, ←Prop_Edge_Endᵥ];
                                            rewrite [prop_outgoingᵥ₁] at prop_mem_outgoingᵥ₁;
                                            cases prop_mem_outgoingᵥ₁ with | head _ => simp only [List.cons.injEq, ite_true];
                                                                           | tail _ mem_cases => trivial; );
                       /- Direct Paths -/--------------------------------------------------------------------------------------------------------------------------------
                       apply And.intro ( by simp only [prop_incomingᵥ₀, prop_outgoingᵥ₀, prop_directᵥ₀];
                                            simp only [pre_collapse.indirect, prop_hptᵥ₀];
                                            simp only [pre_collapse.indirect.move_up];
                                            rewrite [←Prop_Edge_Startᵥ, ←Prop_Edge_Endᵥ];
                                            rewrite [prop_incomingᵥ₀] at prop_mem_incomingᵥ₀;
                                            cases prop_mem_incomingᵥ₀ with | head _ => simp only [get_rule.direct.loop];
                                                                                       simp_arith;
                                                                           | tail _ mem_cases => cases mem_cases with
                                                                                                 | head _ => simp only [get_rule.direct.loop];
                                                                                                             simp_arith;
                                                                                                 | tail _ mem_cases => trivial; );
                       /- Indirect Paths -/------------------------------------------------------------------------------------------------------------------------------
                       exact prop_indirectᵥ₁; );
  /- type0_introduction V1 → type2_introduction V1 -/
  apply And.intro ( by intro prop_typeᵥ₁;
                       simp only [get_rule] at prop_typeᵥ₁;
                       simp only [type0_introduction] at prop_typeᵥ₁;
                       cases prop_typeᵥ₁ with | intro prop_nbrᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro prop_lvlᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro prop_hptᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro prop_colᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro prop_pstᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro inc_nbrᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro out_nbrᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro antecedentᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro consequentᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro out_fmlᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro inc_depᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro prop_fmlᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro prop_inc_nbrᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro prop_out_nbrᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro prop_incomingᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro prop_outgoingᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro prop_directᵥ₁ prop_indirectᵥ₁ =>
                       --
                       simp only [type2_introduction];
                       apply And.intro ( by exact prop_nbrᵥ₁; );
                       apply And.intro ( by exact prop_lvlᵥ₁; );
                       apply And.intro ( by exact prop_hptᵥ₁; );
                       apply And.intro ( by exact prop_colᵥ₁; );
                       apply And.intro ( by exact prop_pstᵥ₁; );
                       apply Exists.intro inc_nbrᵥ₁;                          /- := inc_nbr -/
                       apply Exists.intro U0.NUMBER;                          /- := out_nbr -/
                       apply Exists.intro anc_nbrᵥ₀;                          /- := anc_nbr -/
                       apply Exists.intro anc_lvlᵥ₀;                          /- := anc_lvl -/
                       apply Exists.intro antecedentᵥ₁;                       /- := antecedent -/
                       apply Exists.intro consequentᵥ₁;                       /- := consequent -/
                       apply Exists.intro V0.FORMULA;                         /- := out_fml -/
                       apply Exists.intro anc_fmlᵥ₀;                          /- := anc_fml -/
                       apply Exists.intro (U0.HYPOTHESIS || V0.HYPOTHESIS);   /- := out_hpt -/
                       apply Exists.intro inc_depᵥ₁;                          /- := inc_dep -/
                       apply Exists.intro V0.NUMBER;                          /- := past -/
                       apply Exists.intro V0.NUMBER;                          /- := colour -/
                       apply Exists.intro U0.PAST;                            /- := pasts -/
                       apply Exists.intro (colourᵥ₀ :: coloursᵥ₀);            /- := colours -/
                       apply And.intro ( by exact prop_fmlᵥ₁; );                                        /- := RULE.CENTER.FORMULA = antecedent>>consequent -/
                       apply And.intro ( by exact prop_inc_nbrᵥ₁; );                                    /- := inc_nbr > 0 -/
                       apply And.intro ( by exact prop_nbrᵤ₀; );                                        /- := out_nbr > 0 -/
                       apply And.intro ( by exact prop_anc_nbrᵥ₀; );                                    /- := anc_nbr > 0 -/
                       apply And.intro ( by rewrite [Prop_Upper_LVLᵥ];                                  /- := anc_lvl + List.length (0::colour::colours) = RULE.CENTER.LEVEL -/
                                            rewrite [←prop_anc_lvlᵥ₀];
                                            simp only [List.length, Nat.add_assoc]; );
                       apply And.intro ( by exact List.Mem.tail U0.NUMBER (List.Mem.head U0.PAST); );                  /- := colour ∈ (out_nbr::past::pasts) -/
                       apply And.intro ( by simp only [check_numbers] at prop_pstᵤ₀ ⊢;                                 /- := check_numbers (past::pasts) -/
                                            apply And.intro ( by simp only [ne_eq, List.cons.injEq]; trivial; );
                                            cases prop_pstᵤ₀ with | intro _ prop_pstᵤ₀ =>
                                            intro nbr mem_cases;
                                            cases mem_cases with
                                            | head => exact prop_nbrᵥ₀;
                                            | tail _ mem_cases => exact prop_pstᵤ₀ (List.Mem.tail U0.NUMBER mem_cases); );
                       apply And.intro ( by exact COLLAPSE.Check_Numbers_Cons prop_nbrᵥ₀ prop_coloursᵥ₀; );            /- := check_numbers (colour::colours) -/
                       /- Incoming Edges -/------------------------------------------------------------------------------------------------------------------------------
                       apply And.intro ( by exact prop_incomingᵥ₁; );
                       /- Outgoing Edges -/------------------------------------------------------------------------------------------------------------------------------
                       apply And.intro ( by simp only [prop_outgoingᵥ₁];
                                            simp only [is_collapse.update_edges_end];
                                            simp only [is_collapse.update_edges_end.loop];
                                            simp only [collapse.center];
                                            rewrite [prop_eq_lvl, prop_eq_fml];
                                            rewrite [←Prop_Edge_Startᵥ, ←Prop_Edge_Endᵥ];
                                            rewrite [prop_outgoingᵥ₁] at prop_mem_outgoingᵥ₁;
                                            cases prop_mem_outgoingᵥ₁ with | head _ => simp only [List.cons.injEq, ite_true];
                                                                           | tail _ mem_cases => trivial; );
                       /- Direct Paths -/--------------------------------------------------------------------------------------------------------------------------------
                       apply And.intro ( by simp only [prop_incomingᵥ₀, prop_outgoingᵥ₀, prop_directᵥ₀];
                                            simp only [pre_collapse.indirect, prop_hptᵥ₀];
                                            simp only [pre_collapse.indirect.move_up];
                                            rewrite [←Prop_Edge_Startᵥ, ←Prop_Edge_Endᵥ];
                                            rewrite [prop_incomingᵥ₀] at prop_mem_incomingᵥ₀;
                                            cases prop_mem_incomingᵥ₀ with | head _ => simp only [get_rule.direct.loop];
                                                                                       simp_arith;
                                                                           | tail _ mem_cases => cases mem_cases with
                                                                                                 | head _ => simp only [get_rule.direct.loop];
                                                                                                             simp_arith;
                                                                                                 | tail _ mem_cases => trivial; );
                       /- Indirect Paths -/------------------------------------------------------------------------------------------------------------------------------
                       exact prop_indirectᵥ₁; );
  /- type0_hypothesis V1 → type2_hypothesis V1 -/
  intro prop_typeᵥ₁;
  simp only [get_rule] at prop_typeᵥ₁;
  simp only [type0_hypothesis] at prop_typeᵥ₁;
  cases prop_typeᵥ₁ with | intro prop_nbrᵥ₁ prop_typeᵥ₁ =>
  cases prop_typeᵥ₁ with | intro prop_lvlᵥ₁ prop_typeᵥ₁ =>
  cases prop_typeᵥ₁ with | intro prop_hptᵥ₁ prop_typeᵥ₁ =>
  cases prop_typeᵥ₁ with | intro prop_colᵥ₁ prop_typeᵥ₁ =>
  cases prop_typeᵥ₁ with | intro prop_pstᵥ₁ prop_typeᵥ₁ =>
  cases prop_typeᵥ₁ with | intro out_nbrᵥ₁ prop_typeᵥ₁ =>
  cases prop_typeᵥ₁ with | intro out_fmlᵥ₁ prop_typeᵥ₁ =>
  cases prop_typeᵥ₁ with | intro prop_out_nbrᵥ₁ prop_typeᵥ₁ =>
  cases prop_typeᵥ₁ with | intro prop_incomingᵥ₁ prop_typeᵥ₁ =>
  cases prop_typeᵥ₁ with | intro prop_outgoingᵥ₁ prop_typeᵥ₁ =>
  cases prop_typeᵥ₁ with | intro prop_directᵥ₁ prop_indirectᵥ₁ =>
  --
  simp only [type2_hypothesis];
  apply And.intro ( by exact prop_nbrᵥ₁; );
  apply And.intro ( by exact prop_lvlᵥ₁; );
  apply And.intro ( by exact prop_hptᵥ₁; );
  apply And.intro ( by exact prop_colᵥ₁; );
  apply And.intro ( by exact prop_pstᵥ₁; );
  apply Exists.intro U0.NUMBER;                          /- := out_nbr -/
  apply Exists.intro anc_nbrᵥ₀;                          /- := anc_nbr -/
  apply Exists.intro anc_lvlᵥ₀;                          /- := anc_lvl -/
  apply Exists.intro V0.FORMULA;                         /- := out_fml -/
  apply Exists.intro anc_fmlᵥ₀;                          /- := anc_fml -/
  apply Exists.intro (U0.HYPOTHESIS || V0.HYPOTHESIS);   /- := out_hpt -/
  apply Exists.intro V0.NUMBER;                          /- := past -/
  apply Exists.intro V0.NUMBER;                          /- := colour -/
  apply Exists.intro U0.PAST;                            /- := pasts -/
  apply Exists.intro (colourᵥ₀ :: coloursᵥ₀);            /- := colours -/
  apply And.intro ( by exact prop_nbrᵤ₀; );                                        /- := out_nbr > 0 -/
  apply And.intro ( by exact prop_anc_nbrᵥ₀; );                                    /- := anc_nbr > 0 -/
  apply And.intro ( by rewrite [Prop_Upper_LVLᵥ];                                  /- := anc_lvl + List.length (0::colour::colours) = RULE.CENTER.LEVEL -/
                       rewrite [←prop_anc_lvlᵥ₀];
                       simp only [List.length, Nat.add_assoc]; );
  apply And.intro ( by exact List.Mem.tail U0.NUMBER (List.Mem.head U0.PAST); );                  /- := colour ∈ (out_nbr::past::pasts) -/
  apply And.intro ( by simp only [check_numbers] at prop_pstᵤ₀ ⊢;                                 /- := check_numbers (past::pasts) -/
                       apply And.intro ( by simp only [ne_eq, List.cons.injEq]; trivial; );
                       cases prop_pstᵤ₀ with | intro _ prop_pstᵤ₀ =>
                       intro nbr mem_cases;
                       cases mem_cases with
                       | head => exact prop_nbrᵥ₀;
                       | tail _ mem_cases => exact prop_pstᵤ₀ (List.Mem.tail U0.NUMBER mem_cases); );
  apply And.intro ( by exact COLLAPSE.Check_Numbers_Cons prop_nbrᵥ₀ prop_coloursᵥ₀; );            /- := check_numbers (colour::colours) -/
  /- Incoming Edges -/------------------------------------------------------------------------------------------------------------------------------
  apply And.intro ( by exact prop_incomingᵥ₁; );
  /- Outgoing Edges -/------------------------------------------------------------------------------------------------------------------------------
  apply And.intro ( by simp only [prop_outgoingᵥ₁];
                       simp only [is_collapse.update_edges_end];
                       simp only [is_collapse.update_edges_end.loop];
                       simp only [collapse.center];
                                            rewrite [prop_eq_lvl, prop_eq_fml];
                       rewrite [←Prop_Edge_Startᵥ, ←Prop_Edge_Endᵥ];
                       rewrite [prop_outgoingᵥ₁] at prop_mem_outgoingᵥ₁;
                       cases prop_mem_outgoingᵥ₁ with | head _ => simp only [List.cons.injEq, ite_true];
                                                      | tail _ mem_cases => trivial; );
  /- Direct Paths -/--------------------------------------------------------------------------------------------------------------------------------
  apply And.intro ( by simp only [prop_incomingᵥ₀, prop_outgoingᵥ₀, prop_directᵥ₀];
                       simp only [pre_collapse.indirect, prop_hptᵥ₀];
                       simp only [pre_collapse.indirect.move_up];
                       rewrite [←Prop_Edge_Startᵥ, ←Prop_Edge_Endᵥ];
                       rewrite [prop_incomingᵥ₀] at prop_mem_incomingᵥ₀;
                       cases prop_mem_incomingᵥ₀ with | head _ => simp only [get_rule.direct.loop];
                                                                  simp_arith;
                                                      | tail _ mem_cases => cases mem_cases with
                                                                            | head _ => simp only [get_rule.direct.loop];
                                                                                        simp_arith;
                                                                            | tail _ mem_cases => trivial; );
  /- Indirect Paths -/------------------------------------------------------------------------------------------------------------------------------
  exact prop_indirectᵥ₁;
end COVERAGE.UP.T2E

namespace COVERAGE.UP.T2I
  /- Lemma: Restrictions on Upper Nodes -/
  theorem Not_Above_T2I {U0 U1 : Vertex} {DLDS : Graph} :
    ( type2_introduction (get_rule U0 DLDS) ) →
    ( ∃(edge : Deduction), ( edge ∈ get_rule.outgoing U1 DLDS )
                         ∧ ( edge ∈ get_rule.incoming U0 DLDS ) ) →
    ------------------------------------------------------
    ( ¬type2_elimination (get_rule U1 DLDS) )
  ∧ ( ¬type2_introduction (get_rule U1 DLDS) )
  ∧ ( ¬type2_hypothesis (get_rule U1 DLDS) ) := by
  intro prop_typeᵤ₀;
  simp only [get_rule] at prop_typeᵤ₀;
  simp only [type2_introduction] at prop_typeᵤ₀;
  cases prop_typeᵤ₀ with | intro prop_nbrᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_lvlᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_hptᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_colᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_pstᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro inc_nbrᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro out_nbrᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro anc_nbrᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro anc_lvlᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro antecedentᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro consequentᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro out_fmlᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro anc_fmlᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro out_hptᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro inc_depᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro pastᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro colourᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro pastsᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro coloursᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_fmlᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_inc_nbrᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_out_nbrᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_anc_nbrᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_anc_lvlᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_colourᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_pastsᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_coloursᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_incomingᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_outgoingᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_directᵤ₀ prop_indirectᵤ₀ =>
  --
  intro prop_incomingᵤ₀;
  cases prop_incomingᵤ₀ with | intro edge prop_incomingᵤ₀ =>
  cases prop_incomingᵤ₀ with | intro prop_mem_outgoingᵤ₁ prop_mem_incomingᵤ₀ =>
  have Prop_Edge_Startᵤ : edge.START = U1 := COLLAPSE.Simp_Start_Outgoing prop_mem_outgoingᵤ₁;
  --
  have Prop_Directᵤ₁ := COLLAPSE.Simp_Direct_Indirect₀₂ prop_mem_incomingᵤ₀ prop_indirectᵤ₀;
  rewrite [Prop_Edge_Startᵤ] at Prop_Directᵤ₁;
  /- ¬type2_elimination U1 -/
  apply And.intro ( by rewrite [←imp_false];
                       intro prop_typeᵤ₁;
                       apply absurd Prop_Directᵤ₁;
                       simp only [get_rule] at prop_typeᵤ₁;
                       simp only [type2_elimination] at prop_typeᵤ₁;
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_directᵤ₁ _ =>
                       rewrite [prop_directᵤ₁];
                       simp only [List.cons.injEq];
                       trivial; );
  /- ¬type2_hypothesis U1 -/
  /- ¬type2_introduction U1 -/
  apply And.intro ( by rewrite [←imp_false];
                       intro prop_typeᵤ₁;
                       apply absurd Prop_Directᵤ₁;
                       simp only [get_rule] at prop_typeᵤ₁;
                       simp only [type2_introduction] at prop_typeᵤ₁;
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_directᵤ₁ _ =>
                       rewrite [prop_directᵤ₁];
                       simp only [List.cons.injEq];
                       trivial; );
  /- ¬type2_hypothesis U1 -/
  rewrite [←imp_false];
  intro prop_typeᵤ₁;
  apply absurd Prop_Directᵤ₁;
  simp only [get_rule] at prop_typeᵤ₁;
  simp only [type2_hypothesis] at prop_typeᵤ₁;
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro prop_directᵤ₁ _ =>
  rewrite [prop_directᵤ₁];
  simp only [List.cons.injEq];
  trivial;

  /- Lemma: Collapse Moves Towards Unique Premise -/
  theorem Above_Left_T2I {U0 V0 U1 : Vertex} {DLDS : Graph} :
    ( CLPS.is_collapse U0 V0 DLDS ) →
    ( type2_introduction (get_rule U0 DLDS) ) →
    ( V0.NUMBER > 0 ) →
    ( ∃(edge : Deduction), ( edge ∈ get_rule.outgoing U1 DLDS )
                         ∧ ( edge ∈ get_rule.incoming U0 DLDS ) ) →
    ------------------------------------------------------
    ( U1.LEVEL = U0.LEVEL + 1 )
  ∧ ( type0_elimination (get_rule U1 DLDS) → type2_elimination (get_rule U1 CLPS) )
  ∧ ( type0_introduction (get_rule U1 DLDS) → type2_introduction (get_rule U1 CLPS) )
  ∧ ( type0_hypothesis (get_rule U1 DLDS) → type2_hypothesis (get_rule U1 CLPS) ) := by
  intro prop_collapse;
  --
  intro prop_typeᵤ₀;
  simp only [get_rule] at prop_typeᵤ₀;
  simp only [type2_introduction] at prop_typeᵤ₀;
  cases prop_typeᵤ₀ with | intro prop_nbrᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_lvlᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_hptᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_colᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_pstᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro inc_nbrᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro out_nbrᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro anc_nbrᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro anc_lvlᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro antecedentᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro consequentᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro out_fmlᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro anc_fmlᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro out_hptᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro inc_depᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro pastᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro colourᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro pastsᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro coloursᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_fmlᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_inc_nbrᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_out_nbrᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_anc_nbrᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_anc_lvlᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_colourᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_pastsᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_coloursᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_incomingᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_outgoingᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_directᵤ₀ prop_indirectᵤ₀ =>
  --
  intro  prop_nbrᵥ₀;
  --
  intro prop_incomingᵤ₀;
  cases prop_incomingᵤ₀ with | intro edge prop_incomingᵤ₀ =>
  cases prop_incomingᵤ₀ with | intro prop_mem_outgoingᵤ₁ prop_mem_incomingᵤ₀ =>
  /- U1.LEVEL = U0.LEVEL + 1 -/
  have Prop_Edge_Startᵤ : edge.START = U1 := COLLAPSE.Simp_Start_Outgoing prop_mem_outgoingᵤ₁;
  have Prop_Edge_Endᵤ : edge.END = U0 := COLLAPSE.Simp_End_Incoming prop_mem_incomingᵤ₀;
  have Prop_Upper_LVLᵤ : U1.LEVEL = U0.LEVEL + 1 := by rewrite [←Prop_Edge_Startᵤ, ←Prop_Edge_Endᵤ];
                                                       rewrite [prop_incomingᵤ₀] at prop_mem_incomingᵤ₀;
                                                       cases prop_mem_incomingᵤ₀ with | head _ => trivial;
                                                                                      | tail _ mem_cases => trivial;
  apply And.intro ( by exact Prop_Upper_LVLᵤ; );
  /- Unfold "get_rule U1 CLPS" -/
  rewrite [←Prop_Edge_Startᵤ];
  rewrite [COLLAPSE.Simp_Rule_Above_Left prop_colᵤ₀ prop_collapse prop_mem_incomingᵤ₀];
  rewrite [Prop_Edge_Startᵤ];
  /- type0_elimination U1 → type2_elimination U1 -/
  apply And.intro ( by intro prop_typeᵤ₁;
                       simp only [get_rule] at prop_typeᵤ₁;
                       simp only [type0_elimination] at prop_typeᵤ₁;
                       cases prop_typeᵤ₁ with | intro prop_nbrᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_lvlᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_hptᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_colᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_pstᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro inc_nbrᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro out_nbrᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro antecedentᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro out_fmlᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro major_hptᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro minor_hptᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro major_depᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro minor_depᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_inc_nbrᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_out_nbrᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_incomingᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_outgoingᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_directᵤ₁ prop_indirectᵤ₁ =>
                       --
                       simp only [type2_elimination];
                       apply And.intro ( by exact prop_nbrᵤ₁; );              /- := RULE.CENTER.NUMBER > 0 -/
                       apply And.intro ( by exact prop_lvlᵤ₁; );              /- := RULE.CENTER.LEVEL > 0 -/
                       apply And.intro ( by exact prop_hptᵤ₁; );              /- := RULE.CENTER.HYPOTHESIS = false -/
                       apply And.intro ( by exact prop_colᵤ₁; );              /- := RULE.CENTER.COLLAPSED = false -/
                       apply And.intro ( by exact prop_pstᵤ₁; );              /- := RULE.CENTER.PAST = [] -/
                       apply Exists.intro inc_nbrᵤ₁;                          /- := inc_nbr -/
                       apply Exists.intro U0.NUMBER;                          /- := out_nbr -/
                       apply Exists.intro anc_nbrᵤ₀;                          /- := anc_nbr -/
                       apply Exists.intro anc_lvlᵤ₀;                          /- := anc_lvl -/
                       apply Exists.intro antecedentᵤ₁;                       /- := antecedent -/
                       apply Exists.intro U0.FORMULA;                         /- := out_fml -/
                       apply Exists.intro anc_fmlᵤ₀;                          /- := anc_fml -/
                       apply Exists.intro major_hptᵤ₁;                        /- := major_hpt -/
                       apply Exists.intro minor_hptᵤ₁;                        /- := minor_hpt -/
                       apply Exists.intro (U0.HYPOTHESIS || V0.HYPOTHESIS);   /- := out_hpt -/
                       apply Exists.intro major_depᵤ₁;                        /- := major_dep -/
                       apply Exists.intro minor_depᵤ₁;                        /- := minor_dep -/
                       apply Exists.intro V0.NUMBER;                          /- := past -/
                       apply Exists.intro U0.NUMBER;                          /- := colour -/
                       apply Exists.intro U0.PAST;                            /- := pasts -/
                       apply Exists.intro (colourᵤ₀ :: coloursᵤ₀);            /- := colours -/
                       apply And.intro ( by exact prop_inc_nbrᵤ₁; );                           /- := inc_nbr > 0 -/
                       apply And.intro ( by exact prop_nbrᵤ₀; );                               /- := out_nbr > 0 -/
                       apply And.intro ( by exact prop_anc_nbrᵤ₀; );                           /- := anc_nbr > 0 -/
                       apply And.intro ( by rewrite [Prop_Upper_LVLᵤ];                         /- := anc_lvl + List.length (0::colour::colours) = RULE.CENTER.LEVEL -/
                                            rewrite [←prop_anc_lvlᵤ₀];
                                            simp only [List.length, Nat.add_assoc]; );
                       apply And.intro ( by exact List.Mem.head (V0.NUMBER :: U0.PAST); );                    /- := colour ∈ (out_nbr::past::pasts) -/
                       apply And.intro ( by rewrite [prop_pstᵤ₀];                                             /- := check_numbers (past::pasts) -/
                                            exact COLLAPSE.Check_Numbers_Unit prop_nbrᵥ₀; );
                       apply And.intro ( by exact COLLAPSE.Check_Numbers_Cons prop_nbrᵤ₀ prop_coloursᵤ₀; );   /- := check_numbers (colour::colours) -/
                       /- Incoming Edges -/------------------------------------------------------------------------------------------------------------------------------
                       apply And.intro ( by exact prop_incomingᵤ₁; );
                       /- Outgoing Edges -/------------------------------------------------------------------------------------------------------------------------------
                       apply And.intro ( by simp only [prop_outgoingᵤ₁];
                                            simp only [is_collapse.update_edges_end];
                                            simp only [is_collapse.update_edges_end.loop];
                                            simp only [collapse.center];
                                            rewrite [←Prop_Edge_Startᵤ, ←Prop_Edge_Endᵤ];
                                            rewrite [prop_outgoingᵤ₁] at prop_mem_outgoingᵤ₁;
                                            cases prop_mem_outgoingᵤ₁ with | head _ => simp only [List.cons.injEq, ite_true];
                                                                           | tail _ mem_cases => trivial; );
                       /- Direct Edges -/--------------------------------------------------------------------------------------------------------------------------------
                       apply And.intro ( by simp only [prop_incomingᵤ₀, prop_outgoingᵤ₀, prop_directᵤ₀];
                                            simp only [pre_collapse.indirect, prop_hptᵤ₀];
                                            simp only [pre_collapse.indirect.move_up];
                                            rewrite [←Prop_Edge_Startᵤ, ←Prop_Edge_Endᵤ];
                                            rewrite [prop_incomingᵤ₀] at prop_mem_incomingᵤ₀;
                                            cases prop_mem_incomingᵤ₀ with | head _ => simp only [get_rule.direct.loop];
                                                                                       simp_arith;
                                                                           | tail _ mem_cases => trivial; );
                       /- Indirect Edges -/------------------------------------------------------------------------------------------------------------------------------
                       exact prop_indirectᵤ₁; );
  /- type0_introduction U1 → type2_introduction U1 -/
  apply And.intro ( by intro prop_typeᵤ₁;
                       simp only [get_rule] at prop_typeᵤ₁;
                       simp only [type0_introduction] at prop_typeᵤ₁;
                       cases prop_typeᵤ₁ with | intro prop_nbrᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_lvlᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_hptᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_colᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_pstᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro inc_nbrᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro out_nbrᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro antecedentᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro consequentᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro out_fmlᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro inc_depᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_fmlᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_inc_nbrᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_out_nbrᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_incomingᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_outgoingᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_directᵤ₁ prop_indirectᵤ₁ =>
                       --
                       simp only [type2_introduction];
                       apply And.intro ( by exact prop_nbrᵤ₁; );
                       apply And.intro ( by exact prop_lvlᵤ₁; );
                       apply And.intro ( by exact prop_hptᵤ₁; );
                       apply And.intro ( by exact prop_colᵤ₁; );
                       apply And.intro ( by exact prop_pstᵤ₁; );
                       apply Exists.intro inc_nbrᵤ₁;                          /- := inc_nbr -/
                       apply Exists.intro U0.NUMBER;                          /- := out_nbr -/
                       apply Exists.intro anc_nbrᵤ₀;                          /- := anc_nbr -/
                       apply Exists.intro anc_lvlᵤ₀;                          /- := anc_lvl -/
                       apply Exists.intro antecedentᵤ₁;                       /- := antecedent -/
                       apply Exists.intro consequentᵤ₁;                       /- := consequent -/
                       apply Exists.intro U0.FORMULA;                         /- := out_fml -/
                       apply Exists.intro anc_fmlᵤ₀;                          /- := anc_fml -/
                       apply Exists.intro (U0.HYPOTHESIS || V0.HYPOTHESIS);   /- := out_hpt -/
                       apply Exists.intro inc_depᵤ₁;                          /- := inc_dep -/
                       apply Exists.intro V0.NUMBER;                          /- := past -/
                       apply Exists.intro U0.NUMBER;                          /- := colour -/
                       apply Exists.intro U0.PAST;                            /- := pasts -/
                       apply Exists.intro (colourᵤ₀ :: coloursᵤ₀);            /- := colours -/
                       apply And.intro ( by exact prop_fmlᵤ₁; );                               /- := RULE.CENTER.FORMULA = antecedent>>consequent -/
                       apply And.intro ( by exact prop_inc_nbrᵤ₁; );                           /- := inc_nbr > 0 -/
                       apply And.intro ( by exact prop_nbrᵤ₀; );                               /- := out_nbr > 0 -/
                       apply And.intro ( by exact prop_anc_nbrᵤ₀; );                           /- := anc_nbr > 0 -/
                       apply And.intro ( by rewrite [Prop_Upper_LVLᵤ];                         /- := anc_lvl + List.length (0::colour::colours) = RULE.CENTER.LEVEL -/
                                            rewrite [←prop_anc_lvlᵤ₀];
                                            simp only [List.length, Nat.add_assoc]; );
                       apply And.intro ( by exact List.Mem.head (V0.NUMBER :: U0.PAST); );                    /- := colour ∈ (out_nbr::past::pasts) -/
                       apply And.intro ( by rewrite [prop_pstᵤ₀];                                             /- := check_numbers (past::pasts) -/
                                            exact COLLAPSE.Check_Numbers_Unit prop_nbrᵥ₀; );
                       apply And.intro ( by exact COLLAPSE.Check_Numbers_Cons prop_nbrᵤ₀ prop_coloursᵤ₀; );   /- := check_numbers (colour::colours) -/
                       /- Incoming Edges -/------------------------------------------------------------------------------------------------------------------------------
                       apply And.intro ( by exact prop_incomingᵤ₁; );
                       /- Outgoing Edges -/------------------------------------------------------------------------------------------------------------------------------
                       apply And.intro ( by simp only [prop_outgoingᵤ₁];
                                            simp only [is_collapse.update_edges_end];
                                            simp only [is_collapse.update_edges_end.loop];
                                            simp only [collapse.center];
                                            rewrite [←Prop_Edge_Startᵤ, ←Prop_Edge_Endᵤ];
                                            rewrite [prop_outgoingᵤ₁] at prop_mem_outgoingᵤ₁;
                                            cases prop_mem_outgoingᵤ₁ with | head _ => simp only [List.cons.injEq, ite_true];
                                                                           | tail _ mem_cases => trivial; );
                       /- Direct Edges -/--------------------------------------------------------------------------------------------------------------------------------
                       apply And.intro ( by simp only [prop_incomingᵤ₀, prop_outgoingᵤ₀, prop_directᵤ₀];
                                            simp only [pre_collapse.indirect, prop_hptᵤ₀];
                                            simp only [pre_collapse.indirect.move_up];
                                            rewrite [←Prop_Edge_Startᵤ, ←Prop_Edge_Endᵤ];
                                            rewrite [prop_incomingᵤ₀] at prop_mem_incomingᵤ₀;
                                            cases prop_mem_incomingᵤ₀ with | head _ => simp only [get_rule.direct.loop];
                                                                                       simp_arith;
                                                                           | tail _ mem_cases => trivial; );
                       /- Indirect Edges -/------------------------------------------------------------------------------------------------------------------------------
                       exact prop_indirectᵤ₁; );
  /- type0_hypothesis U1 → type2_hypothesis U1 -/
  intro prop_typeᵤ₁;
  simp only [get_rule] at prop_typeᵤ₁;
  simp only [type0_hypothesis] at prop_typeᵤ₁;
  cases prop_typeᵤ₁ with | intro prop_nbrᵤ₁ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro prop_lvlᵤ₁ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro prop_hptᵤ₁ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro prop_colᵤ₁ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro prop_pstᵤ₁ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro out_nbrᵤ₁ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro out_fmlᵤ₁ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro prop_out_nbrᵤ₁ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro prop_incomingᵤ₁ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro prop_outgoingᵤ₁ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro prop_directᵤ₁ prop_indirectᵤ₁ =>
  --
  simp only [type2_hypothesis];
  apply And.intro ( by exact prop_nbrᵤ₁; );
  apply And.intro ( by exact prop_lvlᵤ₁; );
  apply And.intro ( by exact prop_hptᵤ₁; );
  apply And.intro ( by exact prop_colᵤ₁; );
  apply And.intro ( by exact prop_pstᵤ₁; );
  apply Exists.intro U0.NUMBER;                          /- := out_nbr -/
  apply Exists.intro anc_nbrᵤ₀;                          /- := anc_nbr -/
  apply Exists.intro anc_lvlᵤ₀;                          /- := anc_lvl -/
  apply Exists.intro U0.FORMULA;                         /- := out_fml -/
  apply Exists.intro anc_fmlᵤ₀;                          /- := anc_fml -/
  apply Exists.intro (U0.HYPOTHESIS || V0.HYPOTHESIS);   /- := out_hpt -/
  apply Exists.intro V0.NUMBER;                          /- := past -/
  apply Exists.intro U0.NUMBER;                          /- := colour -/
  apply Exists.intro U0.PAST;                            /- := pasts -/
  apply Exists.intro (colourᵤ₀ :: coloursᵤ₀);            /- := colours -/
  apply And.intro ( by exact prop_nbrᵤ₀; );                               /- := out_nbr > 0 -/
  apply And.intro ( by exact prop_anc_nbrᵤ₀; );                           /- := anc_nbr > 0 -/
  apply And.intro ( by rewrite [Prop_Upper_LVLᵤ];                         /- := anc_lvl + List.length (0::colour::colours) = RULE.CENTER.LEVEL -/
                       rewrite [←prop_anc_lvlᵤ₀];
                       simp only [List.length, Nat.add_assoc]; );
  apply And.intro ( by exact List.Mem.head (V0.NUMBER :: U0.PAST); );                    /- := colour ∈ (out_nbr::past::pasts) -/
  apply And.intro ( by rewrite [prop_pstᵤ₀];                                             /- := check_numbers (past::pasts) -/
                       exact COLLAPSE.Check_Numbers_Unit prop_nbrᵥ₀; );
  apply And.intro ( by exact COLLAPSE.Check_Numbers_Cons prop_nbrᵤ₀ prop_coloursᵤ₀; );   /- := check_numbers (colour::colours) -/
  /- Incoming Edges -/------------------------------------------------------------------------------------------------------------------------------
  apply And.intro ( by exact prop_incomingᵤ₁; );
  /- Outgoing Edges -/------------------------------------------------------------------------------------------------------------------------------
  apply And.intro ( by simp only [prop_outgoingᵤ₁];
                       simp only [is_collapse.update_edges_end];
                       simp only [is_collapse.update_edges_end.loop];
                       simp only [collapse.center];
                       rewrite [←Prop_Edge_Startᵤ, ←Prop_Edge_Endᵤ];
                       rewrite [prop_outgoingᵤ₁] at prop_mem_outgoingᵤ₁;
                       cases prop_mem_outgoingᵤ₁ with | head _ => simp only [List.cons.injEq, ite_true];
                                                      | tail _ mem_cases => trivial; );
  /- Direct Edges -/--------------------------------------------------------------------------------------------------------------------------------
  apply And.intro ( by simp only [prop_incomingᵤ₀, prop_outgoingᵤ₀, prop_directᵤ₀];
                       simp only [pre_collapse.indirect, prop_hptᵤ₀];
                       simp only [pre_collapse.indirect.move_up];
                       rewrite [←Prop_Edge_Startᵤ, ←Prop_Edge_Endᵤ];
                       rewrite [prop_incomingᵤ₀] at prop_mem_incomingᵤ₀;
                       cases prop_mem_incomingᵤ₀ with | head _ => simp only [get_rule.direct.loop];
                                                                  simp_arith;
                                                      | tail _ mem_cases => trivial; );
  /- Indirect Edges -/------------------------------------------------------------------------------------------------------------------------------
  exact prop_indirectᵤ₁;

  /- Lemma: Collapse Moves Towards Unique Premise -/
  theorem Above_Right_T2I {U0 V0 V1 : Vertex} {DLDS : Graph} :
    ( CLPS.is_collapse U0 V0 DLDS ) →
    ( U0.LEVEL = V0.LEVEL ) → ( U0.FORMULA = V0.FORMULA ) →
    ( U0.NUMBER > 0 ) → ( check_numbers (U0.NUMBER::U0.PAST) ) →
    ( type2_introduction (get_rule V0 DLDS) ) →
    ( ∃(edge : Deduction), ( edge ∈ get_rule.outgoing V1 DLDS )
                         ∧ ( edge ∈ get_rule.incoming V0 DLDS ) ) →
    ------------------------------------------------------
    ( V1.LEVEL = V0.LEVEL + 1 )
  ∧ ( type0_elimination (get_rule V1 DLDS) → type2_elimination (get_rule V1 CLPS) )
  ∧ ( type0_introduction (get_rule V1 DLDS) → type2_introduction (get_rule V1 CLPS) )
  ∧ ( type0_hypothesis (get_rule V1 DLDS) → type2_hypothesis (get_rule V1 CLPS) ) := by
  intro prop_collapse;
  --
  intro prop_eq_lvl prop_eq_fml;
  --
  intro prop_nbrᵤ₀ prop_pstᵤ₀;
  --
  intro prop_typeᵥ₀;
  simp only [get_rule] at prop_typeᵥ₀;
  simp only [type2_introduction] at prop_typeᵥ₀;
  cases prop_typeᵥ₀ with | intro prop_nbrᵥ₀ prop_typeᵥ₀ =>
  cases prop_typeᵥ₀ with | intro prop_lvlᵥ₀ prop_typeᵥ₀ =>
  cases prop_typeᵥ₀ with | intro prop_hptᵥ₀ prop_typeᵥ₀ =>
  cases prop_typeᵥ₀ with | intro prop_colᵥ₀ prop_typeᵥ₀ =>
  cases prop_typeᵥ₀ with | intro prop_pstᵥ₀ prop_typeᵥ₀ =>
  cases prop_typeᵥ₀ with | intro inc_nbrᵥ₀ prop_typeᵥ₀ =>
  cases prop_typeᵥ₀ with | intro out_nbrᵥ₀ prop_typeᵥ₀ =>
  cases prop_typeᵥ₀ with | intro anc_nbrᵥ₀ prop_typeᵥ₀ =>
  cases prop_typeᵥ₀ with | intro anc_lvlᵥ₀ prop_typeᵥ₀ =>
  cases prop_typeᵥ₀ with | intro antecedentᵥ₀ prop_typeᵥ₀ =>
  cases prop_typeᵥ₀ with | intro consequentᵥ₀ prop_typeᵥ₀ =>
  cases prop_typeᵥ₀ with | intro out_fmlᵥ₀ prop_typeᵥ₀ =>
  cases prop_typeᵥ₀ with | intro anc_fmlᵥ₀ prop_typeᵥ₀ =>
  cases prop_typeᵥ₀ with | intro out_hptᵥ₀ prop_typeᵥ₀ =>
  cases prop_typeᵥ₀ with | intro inc_depᵥ₀ prop_typeᵥ₀ =>
  cases prop_typeᵥ₀ with | intro pastᵥ₀ prop_typeᵥ₀ =>
  cases prop_typeᵥ₀ with | intro colourᵥ₀ prop_typeᵥ₀ =>
  cases prop_typeᵥ₀ with | intro pastsᵥ₀ prop_typeᵥ₀ =>
  cases prop_typeᵥ₀ with | intro coloursᵥ₀ prop_typeᵥ₀ =>
  cases prop_typeᵥ₀ with | intro prop_fmlᵥ₀ prop_typeᵥ₀ =>
  cases prop_typeᵥ₀ with | intro prop_inc_nbrᵥ₀ prop_typeᵥ₀ =>
  cases prop_typeᵥ₀ with | intro prop_out_nbrᵥ₀ prop_typeᵥ₀ =>
  cases prop_typeᵥ₀ with | intro prop_anc_nbrᵥ₀ prop_typeᵥ₀ =>
  cases prop_typeᵥ₀ with | intro prop_anc_lvlᵥ₀ prop_typeᵥ₀ =>
  cases prop_typeᵥ₀ with | intro prop_colourᵥ₀ prop_typeᵥ₀ =>
  cases prop_typeᵥ₀ with | intro prop_pastsᵥ₀ prop_typeᵥ₀ =>
  cases prop_typeᵥ₀ with | intro prop_coloursᵥ₀ prop_typeᵥ₀ =>
  cases prop_typeᵥ₀ with | intro prop_incomingᵥ₀ prop_typeᵥ₀ =>
  cases prop_typeᵥ₀ with | intro prop_outgoingᵥ₀ prop_typeᵥ₀ =>
  cases prop_typeᵥ₀ with | intro prop_directᵥ₀ prop_indirectᵥ₀ =>
  --
  intro prop_incomingᵥ₀;
  cases prop_incomingᵥ₀ with | intro edge prop_incomingᵥ₀ =>
  cases prop_incomingᵥ₀ with | intro prop_mem_outgoingᵥ₁ prop_mem_incomingᵥ₀ =>
  /- U1.LEVEL = U0.LEVEL + 1 -/
  have Prop_Edge_Startᵥ : edge.START = V1 := COLLAPSE.Simp_Start_Outgoing prop_mem_outgoingᵥ₁;
  have Prop_Edge_Endᵥ : edge.END = V0 := COLLAPSE.Simp_End_Incoming prop_mem_incomingᵥ₀;
  have Prop_Upper_LVLᵥ : V1.LEVEL = V0.LEVEL + 1 := by rewrite [←Prop_Edge_Startᵥ, ←Prop_Edge_Endᵥ];
                                                       rewrite [prop_incomingᵥ₀] at prop_mem_incomingᵥ₀;
                                                       cases prop_mem_incomingᵥ₀ with | head _ => trivial;
                                                                                      | tail _ mem_cases => trivial;
  apply And.intro ( by exact Prop_Upper_LVLᵥ; );
  /- Unfold "get_rule U1 CLPS" -/
  rewrite [←Prop_Edge_Startᵥ];
  rewrite [COLLAPSE.Simp_Rule_Above_Right prop_collapse prop_mem_incomingᵥ₀];
  rewrite [Prop_Edge_Startᵥ];
  /- type0_elimination V1 → type2_elimination V1 -/
  apply And.intro ( by intro prop_typeᵥ₁;
                       simp only [get_rule] at prop_typeᵥ₁;
                       simp only [type0_elimination] at prop_typeᵥ₁;
                       cases prop_typeᵥ₁ with | intro prop_nbrᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro prop_lvlᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro prop_hptᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro prop_colᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro prop_pstᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro inc_nbrᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro out_nbrᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro antecedentᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro out_fmlᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro major_hptᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro minor_hptᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro major_depᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro minor_depᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro prop_inc_nbrᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro prop_out_nbrᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro prop_incomingᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro prop_outgoingᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro prop_directᵥ₁ prop_indirectᵥ₁ =>
                       --
                       simp only [type2_elimination];
                       apply And.intro ( by exact prop_nbrᵥ₁; );
                       apply And.intro ( by exact prop_lvlᵥ₁; );
                       apply And.intro ( by exact prop_hptᵥ₁; );
                       apply And.intro ( by exact prop_colᵥ₁; );
                       apply And.intro ( by exact prop_pstᵥ₁; );
                       apply Exists.intro inc_nbrᵥ₁;                          /- := inc_nbr -/
                       apply Exists.intro U0.NUMBER;                          /- := out_nbr -/
                       apply Exists.intro anc_nbrᵥ₀;                          /- := anc_nbr -/
                       apply Exists.intro anc_lvlᵥ₀;                          /- := anc_lvl -/
                       apply Exists.intro antecedentᵥ₁;                       /- := antecedent -/
                       apply Exists.intro V0.FORMULA;                         /- := out_fml -/
                       apply Exists.intro anc_fmlᵥ₀;                          /- := anc_fml -/
                       apply Exists.intro major_hptᵥ₁;                        /- := major_hpt -/
                       apply Exists.intro minor_hptᵥ₁;                        /- := minor_hpt -/
                       apply Exists.intro (U0.HYPOTHESIS || V0.HYPOTHESIS);   /- := out_hpt -/
                       apply Exists.intro major_depᵥ₁;                        /- := major_dep -/
                       apply Exists.intro minor_depᵥ₁;                        /- := minor_dep -/
                       apply Exists.intro V0.NUMBER;                          /- := past -/
                       apply Exists.intro V0.NUMBER;                          /- := colour -/
                       apply Exists.intro U0.PAST;                            /- := pasts -/
                       apply Exists.intro (colourᵥ₀ :: coloursᵥ₀);            /- := colours -/
                       apply And.intro ( by exact prop_inc_nbrᵥ₁; );                                    /- := inc_nbr > 0 -/
                       apply And.intro ( by exact prop_nbrᵤ₀; );                                        /- := out_nbr > 0 -/
                       apply And.intro ( by exact prop_anc_nbrᵥ₀; );                                    /- := anc_nbr > 0 -/
                       apply And.intro ( by rewrite [Prop_Upper_LVLᵥ];                                  /- := anc_lvl + List.length (0::colour::colours) = RULE.CENTER.LEVEL -/
                                            rewrite [←prop_anc_lvlᵥ₀];
                                            simp only [List.length, Nat.add_assoc]; );
                       apply And.intro ( by exact List.Mem.tail U0.NUMBER (List.Mem.head U0.PAST); );                  /- := colour ∈ (out_nbr::past::pasts) -/
                       apply And.intro ( by simp only [check_numbers] at prop_pstᵤ₀ ⊢;                                 /- := check_numbers (past::pasts) -/
                                            apply And.intro ( by simp only [ne_eq, List.cons.injEq]; trivial; );
                                            cases prop_pstᵤ₀ with | intro _ prop_pstᵤ₀ =>
                                            intro nbr mem_cases;
                                            cases mem_cases with
                                            | head => exact prop_nbrᵥ₀;
                                            | tail _ mem_cases => exact prop_pstᵤ₀ (List.Mem.tail U0.NUMBER mem_cases); );
                       apply And.intro ( by exact COLLAPSE.Check_Numbers_Cons prop_nbrᵥ₀ prop_coloursᵥ₀; );            /- := check_numbers (colour::colours) -/
                       /- Incoming Edges -/------------------------------------------------------------------------------------------------------------------------------
                       apply And.intro ( by exact prop_incomingᵥ₁; );
                       /- Outgoing Edges -/------------------------------------------------------------------------------------------------------------------------------
                       apply And.intro ( by simp only [prop_outgoingᵥ₁];
                                            simp only [is_collapse.update_edges_end];
                                            simp only [is_collapse.update_edges_end.loop];
                                            simp only [collapse.center];
                                            rewrite [prop_eq_lvl, prop_eq_fml];
                                            rewrite [←Prop_Edge_Startᵥ, ←Prop_Edge_Endᵥ];
                                            rewrite [prop_outgoingᵥ₁] at prop_mem_outgoingᵥ₁;
                                            cases prop_mem_outgoingᵥ₁ with | head _ => simp only [List.cons.injEq, ite_true];
                                                                           | tail _ mem_cases => trivial; );
                       /- Direct Paths -/--------------------------------------------------------------------------------------------------------------------------------
                       apply And.intro ( by simp only [prop_incomingᵥ₀, prop_outgoingᵥ₀, prop_directᵥ₀];
                                            simp only [pre_collapse.indirect, prop_hptᵥ₀];
                                            simp only [pre_collapse.indirect.move_up];
                                            rewrite [←Prop_Edge_Startᵥ, ←Prop_Edge_Endᵥ];
                                            rewrite [prop_incomingᵥ₀] at prop_mem_incomingᵥ₀;
                                            cases prop_mem_incomingᵥ₀ with | head _ => simp only [get_rule.direct.loop];
                                                                                       simp_arith;
                                                                           | tail _ mem_cases => trivial; );
                       /- Indirect Paths -/------------------------------------------------------------------------------------------------------------------------------
                       exact prop_indirectᵥ₁; );
  /- type0_introduction V1 → type2_introduction V1 -/
  apply And.intro ( by intro prop_typeᵥ₁;
                       simp only [get_rule] at prop_typeᵥ₁;
                       simp only [type0_introduction] at prop_typeᵥ₁;
                       cases prop_typeᵥ₁ with | intro prop_nbrᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro prop_lvlᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro prop_hptᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro prop_colᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro prop_pstᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro inc_nbrᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro out_nbrᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro antecedentᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro consequentᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro out_fmlᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro inc_depᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro prop_fmlᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro prop_inc_nbrᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro prop_out_nbrᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro prop_incomingᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro prop_outgoingᵥ₁ prop_typeᵥ₁ =>
                       cases prop_typeᵥ₁ with | intro prop_directᵥ₁ prop_indirectᵥ₁ =>
                       --
                       simp only [type2_introduction];
                       apply And.intro ( by exact prop_nbrᵥ₁; );
                       apply And.intro ( by exact prop_lvlᵥ₁; );
                       apply And.intro ( by exact prop_hptᵥ₁; );
                       apply And.intro ( by exact prop_colᵥ₁; );
                       apply And.intro ( by exact prop_pstᵥ₁; );
                       apply Exists.intro inc_nbrᵥ₁;                          /- := inc_nbr -/
                       apply Exists.intro U0.NUMBER;                          /- := out_nbr -/
                       apply Exists.intro anc_nbrᵥ₀;                          /- := anc_nbr -/
                       apply Exists.intro anc_lvlᵥ₀;                          /- := anc_lvl -/
                       apply Exists.intro antecedentᵥ₁;                       /- := antecedent -/
                       apply Exists.intro consequentᵥ₁;                       /- := consequent -/
                       apply Exists.intro V0.FORMULA;                         /- := out_fml -/
                       apply Exists.intro anc_fmlᵥ₀;                          /- := anc_fml -/
                       apply Exists.intro (U0.HYPOTHESIS || V0.HYPOTHESIS);   /- := out_hpt -/
                       apply Exists.intro inc_depᵥ₁;                          /- := inc_dep -/
                       apply Exists.intro V0.NUMBER;                          /- := past -/
                       apply Exists.intro V0.NUMBER;                          /- := colour -/
                       apply Exists.intro U0.PAST;                            /- := pasts -/
                       apply Exists.intro (colourᵥ₀ :: coloursᵥ₀);            /- := colours -/
                       apply And.intro ( by exact prop_fmlᵥ₁; );                                        /- := RULE.CENTER.FORMULA = antecedent>>consequent -/
                       apply And.intro ( by exact prop_inc_nbrᵥ₁; );                                    /- := inc_nbr > 0 -/
                       apply And.intro ( by exact prop_nbrᵤ₀; );                                        /- := out_nbr > 0 -/
                       apply And.intro ( by exact prop_anc_nbrᵥ₀; );                                    /- := anc_nbr > 0 -/
                       apply And.intro ( by rewrite [Prop_Upper_LVLᵥ];                                  /- := anc_lvl + List.length (0::colour::colours) = RULE.CENTER.LEVEL -/
                                            rewrite [←prop_anc_lvlᵥ₀];
                                            simp only [List.length, Nat.add_assoc]; );
                       apply And.intro ( by exact List.Mem.tail U0.NUMBER (List.Mem.head U0.PAST); );                  /- := colour ∈ (out_nbr::past::pasts) -/
                       apply And.intro ( by simp only [check_numbers] at prop_pstᵤ₀ ⊢;                                 /- := check_numbers (past::pasts) -/
                                            apply And.intro ( by simp only [ne_eq, List.cons.injEq]; trivial; );
                                            cases prop_pstᵤ₀ with | intro _ prop_pstᵤ₀ =>
                                            intro nbr mem_cases;
                                            cases mem_cases with
                                            | head => exact prop_nbrᵥ₀;
                                            | tail _ mem_cases => exact prop_pstᵤ₀ (List.Mem.tail U0.NUMBER mem_cases); );
                       apply And.intro ( by exact COLLAPSE.Check_Numbers_Cons prop_nbrᵥ₀ prop_coloursᵥ₀; );            /- := check_numbers (colour::colours) -/
                       /- Incoming Edges -/------------------------------------------------------------------------------------------------------------------------------
                       apply And.intro ( by exact prop_incomingᵥ₁; );
                       /- Outgoing Edges -/------------------------------------------------------------------------------------------------------------------------------
                       apply And.intro ( by simp only [prop_outgoingᵥ₁];
                                            simp only [is_collapse.update_edges_end];
                                            simp only [is_collapse.update_edges_end.loop];
                                            simp only [collapse.center];
                                            rewrite [prop_eq_lvl, prop_eq_fml];
                                            rewrite [←Prop_Edge_Startᵥ, ←Prop_Edge_Endᵥ];
                                            rewrite [prop_outgoingᵥ₁] at prop_mem_outgoingᵥ₁;
                                            cases prop_mem_outgoingᵥ₁ with | head _ => simp only [List.cons.injEq, ite_true];
                                                                           | tail _ mem_cases => trivial; );
                       /- Direct Paths -/--------------------------------------------------------------------------------------------------------------------------------
                       apply And.intro ( by simp only [prop_incomingᵥ₀, prop_outgoingᵥ₀, prop_directᵥ₀];
                                            simp only [pre_collapse.indirect, prop_hptᵥ₀];
                                            simp only [pre_collapse.indirect.move_up];
                                            rewrite [←Prop_Edge_Startᵥ, ←Prop_Edge_Endᵥ];
                                            rewrite [prop_incomingᵥ₀] at prop_mem_incomingᵥ₀;
                                            cases prop_mem_incomingᵥ₀ with | head _ => simp only [get_rule.direct.loop];
                                                                                       simp_arith;
                                                                           | tail _ mem_cases => trivial; );
                       /- Indirect Paths -/------------------------------------------------------------------------------------------------------------------------------
                       exact prop_indirectᵥ₁; );
  /- type0_hypothesis V1 → type2_hypothesis V1 -/
  intro prop_typeᵥ₁;
  simp only [get_rule] at prop_typeᵥ₁;
  simp only [type0_hypothesis] at prop_typeᵥ₁;
  cases prop_typeᵥ₁ with | intro prop_nbrᵥ₁ prop_typeᵥ₁ =>
  cases prop_typeᵥ₁ with | intro prop_lvlᵥ₁ prop_typeᵥ₁ =>
  cases prop_typeᵥ₁ with | intro prop_hptᵥ₁ prop_typeᵥ₁ =>
  cases prop_typeᵥ₁ with | intro prop_colᵥ₁ prop_typeᵥ₁ =>
  cases prop_typeᵥ₁ with | intro prop_pstᵥ₁ prop_typeᵥ₁ =>
  cases prop_typeᵥ₁ with | intro out_nbrᵥ₁ prop_typeᵥ₁ =>
  cases prop_typeᵥ₁ with | intro out_fmlᵥ₁ prop_typeᵥ₁ =>
  cases prop_typeᵥ₁ with | intro prop_out_nbrᵥ₁ prop_typeᵥ₁ =>
  cases prop_typeᵥ₁ with | intro prop_incomingᵥ₁ prop_typeᵥ₁ =>
  cases prop_typeᵥ₁ with | intro prop_outgoingᵥ₁ prop_typeᵥ₁ =>
  cases prop_typeᵥ₁ with | intro prop_directᵥ₁ prop_indirectᵥ₁ =>
  --
  simp only [type2_hypothesis];
  apply And.intro ( by exact prop_nbrᵥ₁; );
  apply And.intro ( by exact prop_lvlᵥ₁; );
  apply And.intro ( by exact prop_hptᵥ₁; );
  apply And.intro ( by exact prop_colᵥ₁; );
  apply And.intro ( by exact prop_pstᵥ₁; );
  apply Exists.intro U0.NUMBER;                          /- := out_nbr -/
  apply Exists.intro anc_nbrᵥ₀;                          /- := anc_nbr -/
  apply Exists.intro anc_lvlᵥ₀;                          /- := anc_lvl -/
  apply Exists.intro V0.FORMULA;                         /- := out_fml -/
  apply Exists.intro anc_fmlᵥ₀;                          /- := anc_fml -/
  apply Exists.intro (U0.HYPOTHESIS || V0.HYPOTHESIS);   /- := out_hpt -/
  apply Exists.intro V0.NUMBER;                          /- := past -/
  apply Exists.intro V0.NUMBER;                          /- := colour -/
  apply Exists.intro U0.PAST;                            /- := pasts -/
  apply Exists.intro (colourᵥ₀ :: coloursᵥ₀);            /- := colours -/
  apply And.intro ( by exact prop_nbrᵤ₀; );                                        /- := out_nbr > 0 -/
  apply And.intro ( by exact prop_anc_nbrᵥ₀; );                                    /- := anc_nbr > 0 -/
  apply And.intro ( by rewrite [Prop_Upper_LVLᵥ];                                  /- := anc_lvl + List.length (0::colour::colours) = RULE.CENTER.LEVEL -/
                       rewrite [←prop_anc_lvlᵥ₀];
                       simp only [List.length, Nat.add_assoc]; );
  apply And.intro ( by exact List.Mem.tail U0.NUMBER (List.Mem.head U0.PAST); );                  /- := colour ∈ (out_nbr::past::pasts) -/
  apply And.intro ( by simp only [check_numbers] at prop_pstᵤ₀ ⊢;                                 /- := check_numbers (past::pasts) -/
                       apply And.intro ( by simp only [ne_eq, List.cons.injEq]; trivial; );
                       cases prop_pstᵤ₀ with | intro _ prop_pstᵤ₀ =>
                       intro nbr mem_cases;
                       cases mem_cases with
                       | head => exact prop_nbrᵥ₀;
                       | tail _ mem_cases => exact prop_pstᵤ₀ (List.Mem.tail U0.NUMBER mem_cases); );
  apply And.intro ( by exact COLLAPSE.Check_Numbers_Cons prop_nbrᵥ₀ prop_coloursᵥ₀; );            /- := check_numbers (colour::colours) -/
  /- Incoming Edges -/------------------------------------------------------------------------------------------------------------------------------
  apply And.intro ( by exact prop_incomingᵥ₁; );
  /- Outgoing Edges -/------------------------------------------------------------------------------------------------------------------------------
  apply And.intro ( by simp only [prop_outgoingᵥ₁];
                       simp only [is_collapse.update_edges_end];
                       simp only [is_collapse.update_edges_end.loop];
                       simp only [collapse.center];
                                            rewrite [prop_eq_lvl, prop_eq_fml];
                       rewrite [←Prop_Edge_Startᵥ, ←Prop_Edge_Endᵥ];
                       rewrite [prop_outgoingᵥ₁] at prop_mem_outgoingᵥ₁;
                       cases prop_mem_outgoingᵥ₁ with | head _ => simp only [List.cons.injEq, ite_true];
                                                      | tail _ mem_cases => trivial; );
  /- Direct Paths -/--------------------------------------------------------------------------------------------------------------------------------
  apply And.intro ( by simp only [prop_incomingᵥ₀, prop_outgoingᵥ₀, prop_directᵥ₀];
                       simp only [pre_collapse.indirect, prop_hptᵥ₀];
                       simp only [pre_collapse.indirect.move_up];
                       rewrite [←Prop_Edge_Startᵥ, ←Prop_Edge_Endᵥ];
                       rewrite [prop_incomingᵥ₀] at prop_mem_incomingᵥ₀;
                       cases prop_mem_incomingᵥ₀ with | head _ => simp only [get_rule.direct.loop];
                                                                  simp_arith;
                                                      | tail _ mem_cases => trivial; );
  /- Indirect Paths -/------------------------------------------------------------------------------------------------------------------------------
  exact prop_indirectᵥ₁;
end COVERAGE.UP.T2I


namespace COVERAGE.UP.T1X
  /- Lemma: Restrictions on Upper Nodes -/
  theorem Not_Above_T1X {U0 U1 : Vertex} {DLDS : Graph} :
    ( type1_collapse (get_rule U0 DLDS) ) →
    ( ∃(edge : Deduction), ( edge ∈ get_rule.outgoing U1 DLDS )
                         ∧ ( edge ∈ get_rule.incoming U0 DLDS ) ) →
    ------------------------------------------------------
    ( ¬type0_elimination (get_rule U1 DLDS) )
  ∧ ( ¬type0_introduction (get_rule U1 DLDS) )
  ∧ ( ¬type0_hypothesis (get_rule U1 DLDS) ) := by
  intro prop_typeᵤ₀;
  simp only [get_rule] at prop_typeᵤ₀;
  simp only [type1_collapse] at prop_typeᵤ₀;
  cases prop_typeᵤ₀ with | intro prop_nbrᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_lvlᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_colᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_pstᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_inc_nilᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_out_consᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_out_coloursᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_dir_nilᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_ind_lenᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_ind_coloursᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_incomingᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_outgoingᵤ₀ prop_indirectᵤ₀ =>
  --
  intro prop_incomingᵤ₀;
  cases prop_incomingᵤ₀ with | intro edge prop_incomingᵤ₀ =>
  cases prop_incomingᵤ₀ with | intro prop_mem_outgoingᵤ₁ prop_mem_incomingᵤ₀ =>
  have Prop_Edge_Startᵤ : edge.START = U1 := COLLAPSE.Simp_Start_Outgoing prop_mem_outgoingᵤ₁;
  --
  simp only [type_incoming] at prop_incomingᵤ₀;
  have Prop_Inc_Indᵤ₀ := prop_incomingᵤ₀ prop_mem_incomingᵤ₀;
  simp only [type_incoming.check] at Prop_Inc_Indᵤ₀;
  cases Prop_Inc_Indᵤ₀ with | intro Prop_Inc_Ind_Startᵤ₀ Prop_Inc_Indᵤ₀ =>
  cases Prop_Inc_Indᵤ₀ with | intro Prop_Inc_Ind_Endᵤ₀ Prop_Inc_Indᵤ₀ =>
  cases Prop_Inc_Indᵤ₀ with | intro Prop_Inc_Ind_Colourᵤ₀ Prop_Inc_Indᵤ₀ =>
  cases Prop_Inc_Indᵤ₀ with | intro Colourᵤ₀ Prop_Inc_Indᵤ₀ =>
  cases Prop_Inc_Indᵤ₀ with | intro Coloursᵤ₀ Prop_Inc_Indᵤ₀ =>
  cases Prop_Inc_Indᵤ₀ with | intro Ancᵤ₀ Prop_Inc_Ind_Duoᵤ₀ =>
  --
  rewrite [Prop_Edge_Startᵤ] at Prop_Inc_Ind_Duoᵤ₀;
  have Prop_Directᵤ₁ := COLLAPSE.Simp_Direct_Indirect₁₃ Prop_Inc_Ind_Duoᵤ₀;
  /- ¬type0_elimination U1 -/
  apply And.intro ( by rewrite [←imp_false];
                       intro prop_typeᵤ₁;
                       apply absurd Prop_Directᵤ₁;
                       simp only [get_rule] at prop_typeᵤ₁;
                       simp only [type0_elimination] at prop_typeᵤ₁;
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_directᵤ₁ _ =>
                       rewrite [prop_directᵤ₁];
                       exact List.not_mem_nil _; );
  /- ¬type0_introduction U1 -/
  apply And.intro ( by rewrite [←imp_false];
                       intro prop_typeᵤ₁;
                       apply absurd Prop_Directᵤ₁;
                       simp only [get_rule] at prop_typeᵤ₁;
                       simp only [type0_introduction] at prop_typeᵤ₁;
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_directᵤ₁ _ =>
                       rewrite [prop_directᵤ₁];
                       exact List.not_mem_nil _; );
  /- ¬type0_hypothesis U1 -/
  rewrite [←imp_false];
  intro prop_typeᵤ₁;
  apply absurd Prop_Directᵤ₁;
  simp only [get_rule] at prop_typeᵤ₁;
  simp only [type0_hypothesis] at prop_typeᵤ₁;
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro prop_directᵤ₁ _ =>
  rewrite [prop_directᵤ₁];
  exact List.not_mem_nil _;

  /- Lemma: Upper Nodes Unaffected by Further Collapses -/
  theorem Above_Left_T1X {U0 V0 U1 : Vertex} {DLDS : Graph} :
    ( CLPS.is_collapse U0 V0 DLDS ) →
    ( type1_collapse (get_rule U0 DLDS) ) →
    ( V0.NUMBER > 0 ) →
    ( ∃(edge : Deduction), ( edge ∈ get_rule.outgoing U1 DLDS )
                         ∧ ( edge ∈ get_rule.incoming U0 DLDS ) ) →
    ------------------------------------------------------
    ( U1.LEVEL = U0.LEVEL + 1 )
  ∧ ( type2_elimination (get_rule U1 DLDS) → type2_elimination (get_rule U1 CLPS) )
  ∧ ( type2_introduction (get_rule U1 DLDS) → type2_introduction (get_rule U1 CLPS) )
  ∧ ( type2_hypothesis (get_rule U1 DLDS) → type2_hypothesis (get_rule U1 CLPS) ) := by
  intro prop_collapse;
  --
  intro prop_typeᵤ₀;
  simp only [get_rule] at prop_typeᵤ₀;
  simp only [type1_collapse] at prop_typeᵤ₀;
  cases prop_typeᵤ₀ with | intro prop_nbrᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_lvlᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_colᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_pstᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_inc_nilᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_out_consᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_out_coloursᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_dir_nilᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_ind_lenᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_ind_coloursᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_incomingᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_outgoingᵤ₀ prop_indirectᵤ₀ =>
  --
  intro  prop_nbrᵥ₀;
  --
  intro prop_incomingᵤ₀;
  cases prop_incomingᵤ₀ with | intro edge prop_incomingᵤ₀ =>
  cases prop_incomingᵤ₀ with | intro prop_mem_outgoingᵤ₁ prop_mem_incomingᵤ₀ =>
  /- U1.LEVEL = U0.LEVEL + 1 -/
  have Prop_Edge_Startᵤ : edge.START = U1 := COLLAPSE.Simp_Start_Outgoing prop_mem_outgoingᵤ₁;
  have Prop_Edge_Endᵤ : edge.END = U0 := COLLAPSE.Simp_End_Incoming prop_mem_incomingᵤ₀;
  have Prop_Upper_LVLᵤ : U1.LEVEL = U0.LEVEL + 1 := by rewrite [←Prop_Edge_Startᵤ];
                                                       cases prop_incomingᵤ₀ prop_mem_incomingᵤ₀ with | intro Prop_Startᵤ₀ _ =>
                                                       cases Prop_Startᵤ₀ with | intro _ Prop_Startᵤ₀ =>
                                                       cases Prop_Startᵤ₀ with | intro Prop_Start_LVLᵤ₀ _ =>
                                                       simp only [get_rule] at Prop_Start_LVLᵤ₀;
                                                       exact Prop_Start_LVLᵤ₀;
  apply And.intro ( by exact Prop_Upper_LVLᵤ; );
  /- Unfold "get_rule U1 CLPS" -/
  rewrite [←Prop_Edge_Startᵤ];
  rewrite [COLLAPSE.Simp_Rule_Above_Collapse prop_colᵤ₀ prop_collapse prop_mem_incomingᵤ₀];
  rewrite [Prop_Edge_Startᵤ];
  /- type2_elimination U1 → type2_elimination U1 -/
  apply And.intro ( by intro prop_typeᵤ₁;
                       simp only [get_rule] at prop_typeᵤ₁;
                       simp only [type2_elimination] at prop_typeᵤ₁;
                       cases prop_typeᵤ₁ with | intro prop_nbrᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_lvlᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_hptᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_colᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_pstᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro inc_nbrᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro out_nbrᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro anc_nbrᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro anc_lvlᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro antecedentᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro out_fmlᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro anc_fmlᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro major_hptᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro minor_hptᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro out_hptᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro major_depᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro minor_depᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro pastᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro colourᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro pastsᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro coloursᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_inc_nbrᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_out_nbrᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_anc_nbrᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_anc_lvlᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_colourᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_pastsᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_coloursᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_incomingᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_outgoingᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_directᵤ₁ prop_indirectᵤ₁ =>
                       --
                       simp only [type2_elimination];
                       apply And.intro ( by exact prop_nbrᵤ₁; );              /- := RULE.CENTER.NUMBER > 0 -/
                       apply And.intro ( by exact prop_lvlᵤ₁; );              /- := RULE.CENTER.LEVEL > 0 -/
                       apply And.intro ( by exact prop_hptᵤ₁; );              /- := RULE.CENTER.HYPOTHESIS = false -/
                       apply And.intro ( by exact prop_colᵤ₁; );              /- := RULE.CENTER.COLLAPSED = false -/
                       apply And.intro ( by exact prop_pstᵤ₁; );              /- := RULE.CENTER.PAST = [] -/
                       apply Exists.intro inc_nbrᵤ₁;                          /- := inc_nbr -/
                       apply Exists.intro U0.NUMBER;                          /- := out_nbr -/
                       apply Exists.intro anc_nbrᵤ₁;                          /- := anc_nbr -/
                       apply Exists.intro anc_lvlᵤ₁;                          /- := anc_lvl -/
                       apply Exists.intro antecedentᵤ₁;                       /- := antecedent -/
                       apply Exists.intro U0.FORMULA;                         /- := out_fml -/
                       apply Exists.intro anc_fmlᵤ₁;                          /- := anc_fml -/
                       apply Exists.intro major_hptᵤ₁;                        /- := major_hpt -/
                       apply Exists.intro minor_hptᵤ₁;                        /- := minor_hpt -/
                       apply Exists.intro (U0.HYPOTHESIS || V0.HYPOTHESIS);   /- := out_hpt -/
                       apply Exists.intro major_depᵤ₁;                        /- := major_dep -/
                       apply Exists.intro minor_depᵤ₁;                        /- := minor_dep -/
                       apply Exists.intro V0.NUMBER;                          /- := past -/
                       apply Exists.intro colourᵤ₁;                           /- := colour -/
                       apply Exists.intro U0.PAST;                            /- := pasts -/
                       apply Exists.intro coloursᵤ₁;                          /- := colours -/
                       apply And.intro ( by exact prop_inc_nbrᵤ₁; );                           /- := inc_nbr > 0 -/
                       apply And.intro ( by exact prop_nbrᵤ₀; );                               /- := out_nbr > 0 -/
                       apply And.intro ( by exact prop_anc_nbrᵤ₁; );                           /- := anc_nbr > 0 -/
                       apply And.intro ( by exact prop_anc_lvlᵤ₁; );                           /- := anc_lvl + List.length (0::colour::colours) = RULE.CENTER.LEVEL -/
                       apply And.intro ( by rewrite [←Prop_Edge_Endᵤ];                         /- := colour ∈ (out_nbr::past::pasts) -/
                                            rewrite [prop_outgoingᵤ₁] at prop_mem_outgoingᵤ₁;
                                            cases prop_mem_outgoingᵤ₁ with | head _ => simp only [List.cons.injEq];
                                                                                       cases prop_colourᵤ₁ with
                                                                                       | head => exact List.Mem.head (V0.NUMBER :: pastᵤ₁ :: pastsᵤ₁);
                                                                                       | tail _ prop_colourᵤ₁ => exact List.Mem.tail ( out_nbrᵤ₁ )
                                                                                                                                     ( List.Mem.tail V0.NUMBER prop_colourᵤ₁ );
                                                                           | tail _ mem_cases => trivial; );
                       apply And.intro ( by cases prop_pstᵤ₀ with | intro pastᵤ₀ prop_pstᵤ₀ =>                    /- := check_numbers (past::pasts) -/
                                            cases prop_pstᵤ₀ with | intro pastsᵤ₀ prop_pstᵤ₀ =>
                                            cases prop_pstᵤ₀ with | intro prop_check_pstᵤ₀ prop_pstᵤ₀ =>
                                            rewrite [prop_pstᵤ₀];
                                            exact COLLAPSE.Check_Numbers_Cons prop_nbrᵥ₀ prop_check_pstᵤ₀; );
                       apply And.intro ( by exact prop_coloursᵤ₁; );                                              /- := check_numbers (colour::colours) -/
                       /- Incoming Edges -/--------------------------------------------------------------------------------------------------------------------------
                       apply And.intro ( by exact prop_incomingᵤ₁; );
                       /- Outgoing Edges -/--------------------------------------------------------------------------------------------------------------------------
                       apply And.intro ( by simp only [prop_outgoingᵤ₁];
                                            simp only [is_collapse.update_edges_end];
                                            simp only [is_collapse.update_edges_end.loop];
                                            simp only [collapse.center];
                                            rewrite [←Prop_Edge_Startᵤ, ←Prop_Edge_Endᵤ];
                                            rewrite [prop_outgoingᵤ₁] at prop_mem_outgoingᵤ₁;
                                            cases prop_mem_outgoingᵤ₁ with | head _ => simp only [List.cons.injEq, ite_true];
                                                                           | tail _ mem_cases => trivial; );
                       /- Direct Paths -/----------------------------------------------------------------------------------------------------------------------------
                       apply And.intro ( by exact prop_directᵤ₁; );
                       /- Indirect Paths -/--------------------------------------------------------------------------------------------------------------------------
                       exact prop_indirectᵤ₁; );
  /- type2_introduction U1 → type2_introduction U1 -/
  apply And.intro ( by intro prop_typeᵤ₁;
                       simp only [get_rule] at prop_typeᵤ₁;
                       simp only [type2_introduction] at prop_typeᵤ₁;
                       cases prop_typeᵤ₁ with | intro prop_nbrᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_lvlᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_hptᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_colᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_pstᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro inc_nbrᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro out_nbrᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro anc_nbrᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro anc_lvlᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro antecedentᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro consequentᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro out_fmlᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro anc_fmlᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro out_hptᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro inc_depᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro pastᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro colourᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro pastsᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro coloursᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_fmlᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_inc_nbrᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_out_nbrᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_anc_nbrᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_anc_lvlᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_colourᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_pastsᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_coloursᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_incomingᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_outgoingᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_directᵤ₁ prop_indirectᵤ₁ =>
                       --
                       simp only [type2_introduction];
                       apply And.intro ( by exact prop_nbrᵤ₁; );
                       apply And.intro ( by exact prop_lvlᵤ₁; );
                       apply And.intro ( by exact prop_hptᵤ₁; );
                       apply And.intro ( by exact prop_colᵤ₁; );
                       apply And.intro ( by exact prop_pstᵤ₁; );
                       apply Exists.intro inc_nbrᵤ₁;                          /- := inc_nbr -/
                       apply Exists.intro U0.NUMBER;                          /- := out_nbr -/
                       apply Exists.intro anc_nbrᵤ₁;                          /- := anc_nbr -/
                       apply Exists.intro anc_lvlᵤ₁;                          /- := anc_lvl -/
                       apply Exists.intro antecedentᵤ₁;                       /- := antecedent -/
                       apply Exists.intro consequentᵤ₁;                       /- := consequent -/
                       apply Exists.intro U0.FORMULA;                         /- := out_fml -/
                       apply Exists.intro anc_fmlᵤ₁;                          /- := anc_fml -/
                       apply Exists.intro (U0.HYPOTHESIS || V0.HYPOTHESIS);   /- := out_hpt -/
                       apply Exists.intro inc_depᵤ₁;                          /- := inc_dep -/
                       apply Exists.intro V0.NUMBER;                          /- := past -/
                       apply Exists.intro colourᵤ₁;                           /- := colour -/
                       apply Exists.intro U0.PAST;                            /- := pasts -/
                       apply Exists.intro coloursᵤ₁;                          /- := colours -/
                       apply And.intro ( by exact prop_fmlᵤ₁; );                               /- := RULE.CENTER.FORMULA = antecedent>>consequent -/
                       apply And.intro ( by exact prop_inc_nbrᵤ₁; );                           /- := inc_nbr > 0 -/
                       apply And.intro ( by exact prop_nbrᵤ₀; );                               /- := out_nbr > 0 -/
                       apply And.intro ( by exact prop_anc_nbrᵤ₁; );                           /- := anc_nbr > 0 -/
                       apply And.intro ( by exact prop_anc_lvlᵤ₁; );                           /- := anc_lvl + List.length (0::colour::colours) = RULE.CENTER.LEVEL -/
                       apply And.intro ( by rewrite [←Prop_Edge_Endᵤ];                         /- := colour ∈ (out_nbr::past::pasts) -/
                                            rewrite [prop_outgoingᵤ₁] at prop_mem_outgoingᵤ₁;
                                            cases prop_mem_outgoingᵤ₁ with | head _ => simp only [List.cons.injEq];
                                                                                       cases prop_colourᵤ₁ with
                                                                                       | head => exact List.Mem.head (V0.NUMBER :: pastᵤ₁ :: pastsᵤ₁);
                                                                                       | tail _ prop_colourᵤ₁ => exact List.Mem.tail ( out_nbrᵤ₁ )
                                                                                                                                     ( List.Mem.tail V0.NUMBER prop_colourᵤ₁ );
                                                                           | tail _ mem_cases => trivial; );
                       apply And.intro ( by cases prop_pstᵤ₀ with | intro pastᵤ₀ prop_pstᵤ₀ =>                    /- := check_numbers (past::pasts) -/
                                            cases prop_pstᵤ₀ with | intro pastsᵤ₀ prop_pstᵤ₀ =>
                                            cases prop_pstᵤ₀ with | intro prop_check_pstᵤ₀ prop_pstᵤ₀ =>
                                            rewrite [prop_pstᵤ₀];
                                            exact COLLAPSE.Check_Numbers_Cons prop_nbrᵥ₀ prop_check_pstᵤ₀; );
                       apply And.intro ( by exact prop_coloursᵤ₁; );                                              /- := check_numbers (colour::colours) -/
                       /- Incoming Edges -/--------------------------------------------------------------------------------------------------------------------------
                       apply And.intro ( by exact prop_incomingᵤ₁; );
                       /- Outgoing Edges -/--------------------------------------------------------------------------------------------------------------------------
                       apply And.intro ( by simp only [prop_outgoingᵤ₁];
                                            simp only [is_collapse.update_edges_end];
                                            simp only [is_collapse.update_edges_end.loop];
                                            simp only [collapse.center];
                                            rewrite [←Prop_Edge_Startᵤ, ←Prop_Edge_Endᵤ];
                                            rewrite [prop_outgoingᵤ₁] at prop_mem_outgoingᵤ₁;
                                            cases prop_mem_outgoingᵤ₁ with | head _ => simp only [List.cons.injEq, ite_true];
                                                                           | tail _ mem_cases => trivial; );
                       /- Direct Paths -/----------------------------------------------------------------------------------------------------------------------------
                       apply And.intro ( by exact prop_directᵤ₁; );
                       /- Indirect Paths -/--------------------------------------------------------------------------------------------------------------------------
                       exact prop_indirectᵤ₁; );
  /- type2_hypothesis U1 → type2_hypothesis U1 -/
  intro prop_typeᵤ₁;
  simp only [get_rule] at prop_typeᵤ₁;
  simp only [type2_hypothesis] at prop_typeᵤ₁;
  cases prop_typeᵤ₁ with | intro prop_nbrᵤ₁ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro prop_lvlᵤ₁ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro prop_hptᵤ₁ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro prop_colᵤ₁ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro prop_pstᵤ₁ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro out_nbrᵤ₁ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro anc_nbrᵤ₁ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro anc_lvlᵤ₁ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro out_fmlᵤ₁ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro anc_fmlᵤ₁ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro out_hptᵤ₁ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro pastᵤ₁ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro colourᵤ₁ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro pastsᵤ₁ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro coloursᵤ₁ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro prop_out_nbrᵤ₁ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro prop_anc_nbrᵤ₁ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro prop_anc_lvlᵤ₁ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro prop_colourᵤ₁ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro prop_pastsᵤ₁ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro prop_coloursᵤ₁ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro prop_incomingᵤ₁ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro prop_outgoingᵤ₁ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro prop_directᵤ₁ prop_indirectᵤ₁ =>
  --
  simp only [type2_hypothesis];
  apply And.intro ( by exact prop_nbrᵤ₁; );
  apply And.intro ( by exact prop_lvlᵤ₁; );
  apply And.intro ( by exact prop_hptᵤ₁; );
  apply And.intro ( by exact prop_colᵤ₁; );
  apply And.intro ( by exact prop_pstᵤ₁; );
  apply Exists.intro U0.NUMBER;                          /- := out_nbr -/
  apply Exists.intro anc_nbrᵤ₁;                          /- := anc_nbr -/
  apply Exists.intro anc_lvlᵤ₁;                          /- := anc_lvl -/
  apply Exists.intro U0.FORMULA;                         /- := out_fml -/
  apply Exists.intro anc_fmlᵤ₁;                          /- := anc_fml -/
  apply Exists.intro (U0.HYPOTHESIS || V0.HYPOTHESIS);   /- := out_hpt -/
  apply Exists.intro V0.NUMBER;                          /- := past -/
  apply Exists.intro colourᵤ₁;                           /- := colour -/
  apply Exists.intro U0.PAST;                            /- := pasts -/
  apply Exists.intro coloursᵤ₁;                          /- := colours -/
  apply And.intro ( by exact prop_nbrᵤ₀; );                               /- := out_nbr > 0 -/
  apply And.intro ( by exact prop_anc_nbrᵤ₁; );                           /- := anc_nbr > 0 -/
  apply And.intro ( by exact prop_anc_lvlᵤ₁; );                           /- := anc_lvl + List.length (0::colour::colours) = RULE.CENTER.LEVEL -/
  apply And.intro ( by rewrite [←Prop_Edge_Endᵤ];                         /- := colour ∈ (out_nbr::past::pasts) -/
                       rewrite [prop_outgoingᵤ₁] at prop_mem_outgoingᵤ₁;
                       cases prop_mem_outgoingᵤ₁ with | head _ => simp only [List.cons.injEq];
                                                                  cases prop_colourᵤ₁ with
                                                                  | head => exact List.Mem.head (V0.NUMBER :: pastᵤ₁ :: pastsᵤ₁);
                                                                  | tail _ prop_colourᵤ₁ => exact List.Mem.tail ( out_nbrᵤ₁ )
                                                                                                                ( List.Mem.tail V0.NUMBER prop_colourᵤ₁ );
                                                      | tail _ mem_cases => trivial; );
  apply And.intro ( by cases prop_pstᵤ₀ with | intro pastᵤ₀ prop_pstᵤ₀ =>                    /- := check_numbers (past::pasts) -/
                       cases prop_pstᵤ₀ with | intro pastsᵤ₀ prop_pstᵤ₀ =>
                       cases prop_pstᵤ₀ with | intro prop_check_pstᵤ₀ prop_pstᵤ₀ =>
                       rewrite [prop_pstᵤ₀];
                       exact COLLAPSE.Check_Numbers_Cons prop_nbrᵥ₀ prop_check_pstᵤ₀; );
  apply And.intro ( by exact prop_coloursᵤ₁; );                                              /- := check_numbers (colour::colours) -/
  /- Incoming Edges -/--------------------------------------------------------------------------------------------------------------------------
  apply And.intro ( by exact prop_incomingᵤ₁; );
  /- Outgoing Edges -/--------------------------------------------------------------------------------------------------------------------------
  apply And.intro ( by simp only [prop_outgoingᵤ₁];
                       simp only [is_collapse.update_edges_end];
                       simp only [is_collapse.update_edges_end.loop];
                       simp only [collapse.center];
                       rewrite [←Prop_Edge_Startᵤ, ←Prop_Edge_Endᵤ];
                       rewrite [prop_outgoingᵤ₁] at prop_mem_outgoingᵤ₁;
                       cases prop_mem_outgoingᵤ₁ with | head _ => simp only [List.cons.injEq, ite_true];
                                                      | tail _ mem_cases => trivial; );
  /- Direct Paths -/----------------------------------------------------------------------------------------------------------------------------
  apply And.intro ( by exact prop_directᵤ₁; );
  /- Indirect Paths -/--------------------------------------------------------------------------------------------------------------------------
  exact prop_indirectᵤ₁;
end COVERAGE.UP.T1X


namespace COVERAGE.UP.T3X
  /- Lemma: Restrictions on Upper Nodes -/
  theorem Not_Above_T3X {U0 U1 : Vertex} {DLDS : Graph} :
    ( type3_collapse (get_rule U0 DLDS) ) →
    ( ∃(edge : Deduction), ( edge ∈ get_rule.outgoing U1 DLDS )
                         ∧ ( edge ∈ get_rule.incoming U0 DLDS ) ) →
    ------------------------------------------------------
    ( ¬type0_elimination (get_rule U1 DLDS) )
  ∧ ( ¬type0_introduction (get_rule U1 DLDS) )
  ∧ ( ¬type0_hypothesis (get_rule U1 DLDS) ) := by
  intro prop_typeᵤ₀;
  simp only [get_rule] at prop_typeᵤ₀;
  simp only [type3_collapse] at prop_typeᵤ₀;
  cases prop_typeᵤ₀ with | intro prop_nbrᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_lvlᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_colᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_pstᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_inc_nilᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_out_consᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_out_coloursᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_dir_nilᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_dir_consᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_ind_lenᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_incomingᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_outgoingᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_outgoingᵤ₀ prop_indirectᵤ₀ =>
  --
  intro prop_incomingᵤ₀;
  cases prop_incomingᵤ₀ with | intro edge prop_incomingᵤ₀ =>
  cases prop_incomingᵤ₀ with | intro prop_mem_outgoingᵤ₁ prop_mem_incomingᵤ₀ =>
  have Prop_Edge_Startᵤ : edge.START = U1 := COLLAPSE.Simp_Start_Outgoing prop_mem_outgoingᵤ₁;
  --
  simp only [type_incoming] at prop_incomingᵤ₀;
  have Prop_Inc_Indᵤ₀ := prop_incomingᵤ₀ prop_mem_incomingᵤ₀;
  simp only [type_incoming.check] at Prop_Inc_Indᵤ₀;
  cases Prop_Inc_Indᵤ₀ with | intro Prop_Inc_Ind_Startᵤ₀ Prop_Inc_Indᵤ₀ =>
  cases Prop_Inc_Indᵤ₀ with | intro Prop_Inc_Ind_Endᵤ₀ Prop_Inc_Indᵤ₀ =>
  cases Prop_Inc_Indᵤ₀ with | intro Prop_Inc_Ind_Colourᵤ₀ Prop_Inc_Indᵤ₀ =>
  cases Prop_Inc_Indᵤ₀ with | intro Colourᵤ₀ Prop_Inc_Indᵤ₀ =>
  cases Prop_Inc_Indᵤ₀ with | intro Coloursᵤ₀ Prop_Inc_Indᵤ₀ =>
  cases Prop_Inc_Indᵤ₀ with | intro Ancᵤ₀ Prop_Inc_Ind_Duoᵤ₀ =>
  --
  rewrite [Prop_Edge_Startᵤ] at Prop_Inc_Ind_Duoᵤ₀;
  have Prop_Directᵤ₁ := COLLAPSE.Simp_Direct_Indirect₁₃ Prop_Inc_Ind_Duoᵤ₀;
  /- ¬type0_elimination U1 -/
  apply And.intro ( by rewrite [←imp_false];
                       intro prop_typeᵤ₁;
                       apply absurd Prop_Directᵤ₁;
                       simp only [get_rule] at prop_typeᵤ₁;
                       simp only [type0_elimination] at prop_typeᵤ₁;
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_directᵤ₁ _ =>
                       rewrite [prop_directᵤ₁];
                       exact List.not_mem_nil _; );
  /- ¬type0_introduction U1 -/
  apply And.intro ( by rewrite [←imp_false];
                       intro prop_typeᵤ₁;
                       apply absurd Prop_Directᵤ₁;
                       simp only [get_rule] at prop_typeᵤ₁;
                       simp only [type0_introduction] at prop_typeᵤ₁;
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_directᵤ₁ _ =>
                       rewrite [prop_directᵤ₁];
                       exact List.not_mem_nil _; );
  /- ¬type0_hypothesis U1 -/
  rewrite [←imp_false];
  intro prop_typeᵤ₁;
  apply absurd Prop_Directᵤ₁;
  simp only [get_rule] at prop_typeᵤ₁;
  simp only [type0_hypothesis] at prop_typeᵤ₁;
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro _ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro prop_directᵤ₁ _ =>
  rewrite [prop_directᵤ₁];
  exact List.not_mem_nil _;

  /- Lemma: Upper Nodes Unaffected by Further Collapses -/
  theorem Above_Left_T3X {U0 V0 U1 : Vertex} {DLDS : Graph} :
    ( CLPS.is_collapse U0 V0 DLDS ) →
    ( type3_collapse (get_rule U0 DLDS) ) →
    ( V0.NUMBER > 0 ) →
    ( ∃(edge : Deduction), ( edge ∈ get_rule.outgoing U1 DLDS )
                         ∧ ( edge ∈ get_rule.incoming U0 DLDS ) ) →
    ------------------------------------------------------
    ( U1.LEVEL = U0.LEVEL + 1 )
  ∧ ( type2_elimination (get_rule U1 DLDS) → type2_elimination (get_rule U1 CLPS) )
  ∧ ( type2_introduction (get_rule U1 DLDS) → type2_introduction (get_rule U1 CLPS) )
  ∧ ( type2_hypothesis (get_rule U1 DLDS) → type2_hypothesis (get_rule U1 CLPS) ) := by
  intro prop_collapse;
  --
  intro prop_typeᵤ₀;
  simp only [get_rule] at prop_typeᵤ₀;
  simp only [type3_collapse] at prop_typeᵤ₀;
  cases prop_typeᵤ₀ with | intro prop_nbrᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_lvlᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_colᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_pstᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_inc_nilᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_out_consᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_out_coloursᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_dir_nilᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_dir_consᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_ind_lenᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_incomingᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_outgoingᵤ₀ prop_typeᵤ₀ =>
  cases prop_typeᵤ₀ with | intro prop_outgoingᵤ₀ prop_indirectᵤ₀ =>
  --
  intro  prop_nbrᵥ₀;
  --
  intro prop_incomingᵤ₀;
  cases prop_incomingᵤ₀ with | intro edge prop_incomingᵤ₀ =>
  cases prop_incomingᵤ₀ with | intro prop_mem_outgoingᵤ₁ prop_mem_incomingᵤ₀ =>
  /- U1.LEVEL = U0.LEVEL + 1 -/
  have Prop_Edge_Startᵤ : edge.START = U1 := COLLAPSE.Simp_Start_Outgoing prop_mem_outgoingᵤ₁;
  have Prop_Edge_Endᵤ : edge.END = U0 := COLLAPSE.Simp_End_Incoming prop_mem_incomingᵤ₀;
  have Prop_Upper_LVLᵤ : U1.LEVEL = U0.LEVEL + 1 := by rewrite [←Prop_Edge_Startᵤ];
                                                       cases prop_incomingᵤ₀ prop_mem_incomingᵤ₀ with | intro Prop_Startᵤ₀ _ =>
                                                       cases Prop_Startᵤ₀ with | intro _ Prop_Startᵤ₀ =>
                                                       cases Prop_Startᵤ₀ with | intro Prop_Start_LVLᵤ₀ _ =>
                                                       simp only [get_rule] at Prop_Start_LVLᵤ₀;
                                                       exact Prop_Start_LVLᵤ₀;
  apply And.intro ( by exact Prop_Upper_LVLᵤ; );
  /- Unfold "get_rule U1 CLPS" -/
  rewrite [←Prop_Edge_Startᵤ];
  rewrite [COLLAPSE.Simp_Rule_Above_Collapse prop_colᵤ₀ prop_collapse prop_mem_incomingᵤ₀];
  rewrite [Prop_Edge_Startᵤ];
  /- type2_elimination U1 → type2_elimination U1 -/
  apply And.intro ( by intro prop_typeᵤ₁;
                       simp only [get_rule] at prop_typeᵤ₁;
                       simp only [type2_elimination] at prop_typeᵤ₁;
                       cases prop_typeᵤ₁ with | intro prop_nbrᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_lvlᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_hptᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_colᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_pstᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro inc_nbrᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro out_nbrᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro anc_nbrᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro anc_lvlᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro antecedentᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro out_fmlᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro anc_fmlᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro major_hptᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro minor_hptᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro out_hptᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro major_depᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro minor_depᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro pastᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro colourᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro pastsᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro coloursᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_inc_nbrᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_out_nbrᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_anc_nbrᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_anc_lvlᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_colourᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_pastsᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_coloursᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_incomingᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_outgoingᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_directᵤ₁ prop_indirectᵤ₁ =>
                       --
                       simp only [type2_elimination];
                       apply And.intro ( by exact prop_nbrᵤ₁; );              /- := RULE.CENTER.NUMBER > 0 -/
                       apply And.intro ( by exact prop_lvlᵤ₁; );              /- := RULE.CENTER.LEVEL > 0 -/
                       apply And.intro ( by exact prop_hptᵤ₁; );              /- := RULE.CENTER.HYPOTHESIS = false -/
                       apply And.intro ( by exact prop_colᵤ₁; );              /- := RULE.CENTER.COLLAPSED = false -/
                       apply And.intro ( by exact prop_pstᵤ₁; );              /- := RULE.CENTER.PAST = [] -/
                       apply Exists.intro inc_nbrᵤ₁;                          /- := inc_nbr -/
                       apply Exists.intro U0.NUMBER;                          /- := out_nbr -/
                       apply Exists.intro anc_nbrᵤ₁;                          /- := anc_nbr -/
                       apply Exists.intro anc_lvlᵤ₁;                          /- := anc_lvl -/
                       apply Exists.intro antecedentᵤ₁;                       /- := antecedent -/
                       apply Exists.intro U0.FORMULA;                         /- := out_fml -/
                       apply Exists.intro anc_fmlᵤ₁;                          /- := anc_fml -/
                       apply Exists.intro major_hptᵤ₁;                        /- := major_hpt -/
                       apply Exists.intro minor_hptᵤ₁;                        /- := minor_hpt -/
                       apply Exists.intro (U0.HYPOTHESIS || V0.HYPOTHESIS);   /- := out_hpt -/
                       apply Exists.intro major_depᵤ₁;                        /- := major_dep -/
                       apply Exists.intro minor_depᵤ₁;                        /- := minor_dep -/
                       apply Exists.intro V0.NUMBER;                          /- := past -/
                       apply Exists.intro colourᵤ₁;                           /- := colour -/
                       apply Exists.intro U0.PAST;                            /- := pasts -/
                       apply Exists.intro coloursᵤ₁;                          /- := colours -/
                       apply And.intro ( by exact prop_inc_nbrᵤ₁; );                           /- := inc_nbr > 0 -/
                       apply And.intro ( by exact prop_nbrᵤ₀; );                               /- := out_nbr > 0 -/
                       apply And.intro ( by exact prop_anc_nbrᵤ₁; );                           /- := anc_nbr > 0 -/
                       apply And.intro ( by exact prop_anc_lvlᵤ₁; );                           /- := anc_lvl + List.length (0::colour::colours) = RULE.CENTER.LEVEL -/
                       apply And.intro ( by rewrite [←Prop_Edge_Endᵤ];                         /- := colour ∈ (out_nbr::past::pasts) -/
                                            rewrite [prop_outgoingᵤ₁] at prop_mem_outgoingᵤ₁;
                                            cases prop_mem_outgoingᵤ₁ with | head _ => simp only [List.cons.injEq];
                                                                                       cases prop_colourᵤ₁ with
                                                                                       | head => exact List.Mem.head (V0.NUMBER :: pastᵤ₁ :: pastsᵤ₁);
                                                                                       | tail _ prop_colourᵤ₁ => exact List.Mem.tail ( out_nbrᵤ₁ )
                                                                                                                                     ( List.Mem.tail V0.NUMBER prop_colourᵤ₁ );
                                                                           | tail _ mem_cases => trivial; );
                       apply And.intro ( by cases prop_pstᵤ₀ with | intro pastᵤ₀ prop_pstᵤ₀ =>                    /- := check_numbers (past::pasts) -/
                                            cases prop_pstᵤ₀ with | intro pastsᵤ₀ prop_pstᵤ₀ =>
                                            cases prop_pstᵤ₀ with | intro prop_check_pstᵤ₀ prop_pstᵤ₀ =>
                                            rewrite [prop_pstᵤ₀];
                                            exact COLLAPSE.Check_Numbers_Cons prop_nbrᵥ₀ prop_check_pstᵤ₀; );
                       apply And.intro ( by exact prop_coloursᵤ₁; );                                              /- := check_numbers (colour::colours) -/
                       /- Incoming Edges -/--------------------------------------------------------------------------------------------------------------------------
                       apply And.intro ( by exact prop_incomingᵤ₁; );
                       /- Outgoing Edges -/--------------------------------------------------------------------------------------------------------------------------
                       apply And.intro ( by simp only [prop_outgoingᵤ₁];
                                            simp only [is_collapse.update_edges_end];
                                            simp only [is_collapse.update_edges_end.loop];
                                            simp only [collapse.center];
                                            rewrite [←Prop_Edge_Startᵤ, ←Prop_Edge_Endᵤ];
                                            rewrite [prop_outgoingᵤ₁] at prop_mem_outgoingᵤ₁;
                                            cases prop_mem_outgoingᵤ₁ with | head _ => simp only [List.cons.injEq, ite_true];
                                                                           | tail _ mem_cases => trivial; );
                       /- Direct Paths -/----------------------------------------------------------------------------------------------------------------------------
                       apply And.intro ( by exact prop_directᵤ₁; );
                       /- Indirect Paths -/--------------------------------------------------------------------------------------------------------------------------
                       exact prop_indirectᵤ₁; );
  /- type2_introduction U1 → type2_introduction U1 -/
  apply And.intro ( by intro prop_typeᵤ₁;
                       simp only [get_rule] at prop_typeᵤ₁;
                       simp only [type2_introduction] at prop_typeᵤ₁;
                       cases prop_typeᵤ₁ with | intro prop_nbrᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_lvlᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_hptᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_colᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_pstᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro inc_nbrᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro out_nbrᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro anc_nbrᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro anc_lvlᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro antecedentᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro consequentᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro out_fmlᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro anc_fmlᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro out_hptᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro inc_depᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro pastᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro colourᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro pastsᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro coloursᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_fmlᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_inc_nbrᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_out_nbrᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_anc_nbrᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_anc_lvlᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_colourᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_pastsᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_coloursᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_incomingᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_outgoingᵤ₁ prop_typeᵤ₁ =>
                       cases prop_typeᵤ₁ with | intro prop_directᵤ₁ prop_indirectᵤ₁ =>
                       --
                       simp only [type2_introduction];
                       apply And.intro ( by exact prop_nbrᵤ₁; );
                       apply And.intro ( by exact prop_lvlᵤ₁; );
                       apply And.intro ( by exact prop_hptᵤ₁; );
                       apply And.intro ( by exact prop_colᵤ₁; );
                       apply And.intro ( by exact prop_pstᵤ₁; );
                       apply Exists.intro inc_nbrᵤ₁;                          /- := inc_nbr -/
                       apply Exists.intro U0.NUMBER;                          /- := out_nbr -/
                       apply Exists.intro anc_nbrᵤ₁;                          /- := anc_nbr -/
                       apply Exists.intro anc_lvlᵤ₁;                          /- := anc_lvl -/
                       apply Exists.intro antecedentᵤ₁;                       /- := antecedent -/
                       apply Exists.intro consequentᵤ₁;                       /- := consequent -/
                       apply Exists.intro U0.FORMULA;                         /- := out_fml -/
                       apply Exists.intro anc_fmlᵤ₁;                          /- := anc_fml -/
                       apply Exists.intro (U0.HYPOTHESIS || V0.HYPOTHESIS);   /- := out_hpt -/
                       apply Exists.intro inc_depᵤ₁;                          /- := inc_dep -/
                       apply Exists.intro V0.NUMBER;                          /- := past -/
                       apply Exists.intro colourᵤ₁;                           /- := colour -/
                       apply Exists.intro U0.PAST;                            /- := pasts -/
                       apply Exists.intro coloursᵤ₁;                          /- := colours -/
                       apply And.intro ( by exact prop_fmlᵤ₁; );                               /- := RULE.CENTER.FORMULA = antecedent>>consequent -/
                       apply And.intro ( by exact prop_inc_nbrᵤ₁; );                           /- := inc_nbr > 0 -/
                       apply And.intro ( by exact prop_nbrᵤ₀; );                               /- := out_nbr > 0 -/
                       apply And.intro ( by exact prop_anc_nbrᵤ₁; );                           /- := anc_nbr > 0 -/
                       apply And.intro ( by exact prop_anc_lvlᵤ₁; );                           /- := anc_lvl + List.length (0::colour::colours) = RULE.CENTER.LEVEL -/
                       apply And.intro ( by rewrite [←Prop_Edge_Endᵤ];                         /- := colour ∈ (out_nbr::past::pasts) -/
                                            rewrite [prop_outgoingᵤ₁] at prop_mem_outgoingᵤ₁;
                                            cases prop_mem_outgoingᵤ₁ with | head _ => simp only [List.cons.injEq];
                                                                                       cases prop_colourᵤ₁ with
                                                                                       | head => exact List.Mem.head (V0.NUMBER :: pastᵤ₁ :: pastsᵤ₁);
                                                                                       | tail _ prop_colourᵤ₁ => exact List.Mem.tail ( out_nbrᵤ₁ )
                                                                                                                                     ( List.Mem.tail V0.NUMBER prop_colourᵤ₁ );
                                                                           | tail _ mem_cases => trivial; );
                       apply And.intro ( by cases prop_pstᵤ₀ with | intro pastᵤ₀ prop_pstᵤ₀ =>                    /- := check_numbers (past::pasts) -/
                                            cases prop_pstᵤ₀ with | intro pastsᵤ₀ prop_pstᵤ₀ =>
                                            cases prop_pstᵤ₀ with | intro prop_check_pstᵤ₀ prop_pstᵤ₀ =>
                                            rewrite [prop_pstᵤ₀];
                                            exact COLLAPSE.Check_Numbers_Cons prop_nbrᵥ₀ prop_check_pstᵤ₀; );
                       apply And.intro ( by exact prop_coloursᵤ₁; );                                              /- := check_numbers (colour::colours) -/
                       /- Incoming Edges -/--------------------------------------------------------------------------------------------------------------------------
                       apply And.intro ( by exact prop_incomingᵤ₁; );
                       /- Outgoing Edges -/--------------------------------------------------------------------------------------------------------------------------
                       apply And.intro ( by simp only [prop_outgoingᵤ₁];
                                            simp only [is_collapse.update_edges_end];
                                            simp only [is_collapse.update_edges_end.loop];
                                            simp only [collapse.center];
                                            rewrite [←Prop_Edge_Startᵤ, ←Prop_Edge_Endᵤ];
                                            rewrite [prop_outgoingᵤ₁] at prop_mem_outgoingᵤ₁;
                                            cases prop_mem_outgoingᵤ₁ with | head _ => simp only [List.cons.injEq, ite_true];
                                                                           | tail _ mem_cases => trivial; );
                       /- Direct Paths -/----------------------------------------------------------------------------------------------------------------------------
                       apply And.intro ( by exact prop_directᵤ₁; );
                       /- Indirect Paths -/--------------------------------------------------------------------------------------------------------------------------
                       exact prop_indirectᵤ₁; );
  /- type2_hypothesis U1 → type2_hypothesis U1 -/
  intro prop_typeᵤ₁;
  simp only [get_rule] at prop_typeᵤ₁;
  simp only [type2_hypothesis] at prop_typeᵤ₁;
  cases prop_typeᵤ₁ with | intro prop_nbrᵤ₁ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro prop_lvlᵤ₁ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro prop_hptᵤ₁ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro prop_colᵤ₁ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro prop_pstᵤ₁ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro out_nbrᵤ₁ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro anc_nbrᵤ₁ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro anc_lvlᵤ₁ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro out_fmlᵤ₁ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro anc_fmlᵤ₁ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro out_hptᵤ₁ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro pastᵤ₁ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro colourᵤ₁ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro pastsᵤ₁ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro coloursᵤ₁ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro prop_out_nbrᵤ₁ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro prop_anc_nbrᵤ₁ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro prop_anc_lvlᵤ₁ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro prop_colourᵤ₁ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro prop_pastsᵤ₁ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro prop_coloursᵤ₁ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro prop_incomingᵤ₁ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro prop_outgoingᵤ₁ prop_typeᵤ₁ =>
  cases prop_typeᵤ₁ with | intro prop_directᵤ₁ prop_indirectᵤ₁ =>
  --
  simp only [type2_hypothesis];
  apply And.intro ( by exact prop_nbrᵤ₁; );
  apply And.intro ( by exact prop_lvlᵤ₁; );
  apply And.intro ( by exact prop_hptᵤ₁; );
  apply And.intro ( by exact prop_colᵤ₁; );
  apply And.intro ( by exact prop_pstᵤ₁; );
  apply Exists.intro U0.NUMBER;                          /- := out_nbr -/
  apply Exists.intro anc_nbrᵤ₁;                          /- := anc_nbr -/
  apply Exists.intro anc_lvlᵤ₁;                          /- := anc_lvl -/
  apply Exists.intro U0.FORMULA;                         /- := out_fml -/
  apply Exists.intro anc_fmlᵤ₁;                          /- := anc_fml -/
  apply Exists.intro (U0.HYPOTHESIS || V0.HYPOTHESIS);   /- := out_hpt -/
  apply Exists.intro V0.NUMBER;                          /- := past -/
  apply Exists.intro colourᵤ₁;                           /- := colour -/
  apply Exists.intro U0.PAST;                            /- := pasts -/
  apply Exists.intro coloursᵤ₁;                          /- := colours -/
  apply And.intro ( by exact prop_nbrᵤ₀; );                               /- := out_nbr > 0 -/
  apply And.intro ( by exact prop_anc_nbrᵤ₁; );                           /- := anc_nbr > 0 -/
  apply And.intro ( by exact prop_anc_lvlᵤ₁; );                           /- := anc_lvl + List.length (0::colour::colours) = RULE.CENTER.LEVEL -/
  apply And.intro ( by rewrite [←Prop_Edge_Endᵤ];                         /- := colour ∈ (out_nbr::past::pasts) -/
                       rewrite [prop_outgoingᵤ₁] at prop_mem_outgoingᵤ₁;
                       cases prop_mem_outgoingᵤ₁ with | head _ => simp only [List.cons.injEq];
                                                                  cases prop_colourᵤ₁ with
                                                                  | head => exact List.Mem.head (V0.NUMBER :: pastᵤ₁ :: pastsᵤ₁);
                                                                  | tail _ prop_colourᵤ₁ => exact List.Mem.tail ( out_nbrᵤ₁ )
                                                                                                                ( List.Mem.tail V0.NUMBER prop_colourᵤ₁ );
                                                      | tail _ mem_cases => trivial; );
  apply And.intro ( by cases prop_pstᵤ₀ with | intro pastᵤ₀ prop_pstᵤ₀ =>                    /- := check_numbers (past::pasts) -/
                       cases prop_pstᵤ₀ with | intro pastsᵤ₀ prop_pstᵤ₀ =>
                       cases prop_pstᵤ₀ with | intro prop_check_pstᵤ₀ prop_pstᵤ₀ =>
                       rewrite [prop_pstᵤ₀];
                       exact COLLAPSE.Check_Numbers_Cons prop_nbrᵥ₀ prop_check_pstᵤ₀; );
  apply And.intro ( by exact prop_coloursᵤ₁; );                                              /- := check_numbers (colour::colours) -/
  /- Incoming Edges -/--------------------------------------------------------------------------------------------------------------------------
  apply And.intro ( by exact prop_incomingᵤ₁; );
  /- Outgoing Edges -/--------------------------------------------------------------------------------------------------------------------------
  apply And.intro ( by simp only [prop_outgoingᵤ₁];
                       simp only [is_collapse.update_edges_end];
                       simp only [is_collapse.update_edges_end.loop];
                       simp only [collapse.center];
                       rewrite [←Prop_Edge_Startᵤ, ←Prop_Edge_Endᵤ];
                       rewrite [prop_outgoingᵤ₁] at prop_mem_outgoingᵤ₁;
                       cases prop_mem_outgoingᵤ₁ with | head _ => simp only [List.cons.injEq, ite_true];
                                                      | tail _ mem_cases => trivial; );
  /- Direct Paths -/----------------------------------------------------------------------------------------------------------------------------
  apply And.intro ( by exact prop_directᵤ₁; );
  /- Indirect Paths -/--------------------------------------------------------------------------------------------------------------------------
  exact prop_indirectᵤ₁;
end COVERAGE.UP.T3X

/- End -/
